<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>4 Clases y Objetos - Python Práctico</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "4 Clases y Objetos";
    var mkdocs_page_input_path = "4.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/shell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Python Práctico</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Sobre el curso</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../temario/">Temario</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../faq/">Preguntas</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../0/">0 Empiece aqui</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../1/">1 Intro a Python</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../2/">2 Trabajando con Data</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../3/">3 Organización de un Programa</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">4 Clases y Objetos</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#41-clases">4.1 Clases</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#411-programacion-orientada-a-objetos-oo">4.1.1 Programación orientada a objetos (OO)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#412-instancias">4.1.2 Instancias</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#413-datos-de-instancia">4.1.3 Datos de instancia</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#414-metodos-de-instancia">4.1.4 Métodos de instancia</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#415-alcance-de-la-clase">4.1.5 Alcance de la clase</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#416-ejercicios">4.1.6 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#417-ejercicio-41-objetos-como-estructuras-de-datos">4.1.7 Ejercicio 4.1: Objetos como estructuras de datos</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-42-adicion-de-algunos-metodos">Ejercicio 4.2: Adición de algunos métodos</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-43-creando-una-lista-de-instancias">Ejercicio 4.3: Creando una lista de instancias</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-44-usar-tu-clase">Ejercicio 4.4: Usar tu clase</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#42-herencia">4.2 Herencia</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#421-introduccion">4.2.1 Introducción</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#422-extension">4.2.2 Extensión</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#423-ejemplo">4.2.3 Ejemplo</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#424-agregando-un-nuevo-metodo">4.2.4 Agregando un nuevo método</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#425-redefiniendo-un-metodo-existente">4.2.5 Redefiniendo un método existente</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#426-comportamiento-primordial">4.2.6 Comportamiento Primordial</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#427-__init__-y-herencia">4.2.7 __init__ y herencia</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#428-usando-la-herencia">4.2.8 Usando la herencia</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#429-relacion-es-un">4.2.9 Relación "es un"</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4210-clase-base-object">4.2.10 clase base object</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4211-herencia-multiple">4.2.11 Herencia múltiple</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4212-ejercicios">4.2.12 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-45-un-problema-de-extensibilidad">Ejercicio 4.5: un problema de extensibilidad</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-46-uso-de-la-herencia-para-producir-resultados-diferentes">Ejercicio 4.6: Uso de la herencia para producir resultados diferentes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-47-polimorfismo-en-accion">Ejercicio 4.7: Polimorfismo en acción</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-48-poniendo-todo-junto">Ejercicio 4.8: Poniendo todo junto</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#discusion">Discusión</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#43-metodos-especiales">4.3 Métodos especiales</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#431-introduccion">4.3.1 Introducción</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#432-metodos-especiales-para-conversiones-de-cadenas">4.3.2 Métodos especiales para conversiones de cadenas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#433-metodos-especiales-para-matematicas">4.3.3 Métodos especiales para matemáticas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#434-metodos-especiales-para-acceder-a-los-elementos">4.3.4 Métodos especiales para acceder a los elementos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#435-invocacion-de-metodo">4.3.5 Invocación de método</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#436-metodos-vinculados">4.3.6 Métodos vinculados</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#437-acceso-a-atributos">4.3.7 Acceso a atributos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#438-ejercicios">4.3.8 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-49-mejor-resultado-para-imprimir-objetos">Ejercicio 4.9: Mejor resultado para imprimir objetos</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-410-un-ejemplo-de-uso-de-getattr">Ejercicio 4.10: un ejemplo de uso de getattr()</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../5/">5 Entrañas del Objeto</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../6/">6 Generadores</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../7/">7 Temas avanzados</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../8/">8 Prueba y Depuración</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../9/">9 Paquetes</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../licencia/">Licencia</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Python Práctico</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>4 Clases y Objetos</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="4-clases-y-objetos">4. Clases y Objetos</h1>
<p>Introduciremos el concepto de clases y objetos. Aprenderemos sobre la 
declaración class que nos permite crear nuevos objetos. También 
introcimos el concepto de inherencia, unaherramienta que es 
comunmente utilizada para construir programar extensibles. 
Finalmente, veremos otras características de clases como los métodos 
especiales, búsqueda dinamica de atributos, y la definición de nuevas 
excepciones.</p>
<h2 id="41-clases">4.1 Clases</h2>
<p>Esta sección presenta la declaración de clase y la idea de crear 
nuevos objetos.</p>
<h3 id="411-programacion-orientada-a-objetos-oo">4.1.1 Programación orientada a objetos (OO)</h3>
<p>Una técnica de programación en la que el código se organiza como una 
colección de objetos .</p>
<p>Un objeto consta de:</p>
<ul>
<li>Datos. Atributos</li>
<li>Comportamiento. Métodos que son funciones aplicadas al objeto.</li>
</ul>
<p>Ya ha estado utilizando OO durante este curso.</p>
<p>Por ejemplo, manipular una lista.</p>
<pre><code class="language-python">&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; nums.append(4)      # Metodo
&gt;&gt;&gt; nums.insert(1,10)   # Metodo 
&gt;&gt;&gt; nums
[1, 10, 2, 3, 4]        # Data 
&gt;&gt;&gt;
</code></pre>
<p><code>nums</code> es una instancia de una lista.</p>
<p>Los métodos (<code>append()</code> e <code>insert()</code>) se adjuntan a la instancia 
(<code>nums</code>).</p>
<p>La declaración <code>class</code></p>
<p>Utilice la declaración <code>class</code> para definir un nuevo objeto.</p>
<pre><code class="language-python">class Player:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.health = 100

    def move(self, dx, dy):
        self.x += dx
        self.y += dy

    def damage(self, pts):
        self.health -= pts
</code></pre>
<p>En pocas palabras, una clase es un conjunto de funciones que realizan 
varias operaciones en las denominadas <em>instancias</em>.</p>
<h3 id="412-instancias">4.1.2 Instancias</h3>
<p>Las instancias son los objetos reales que manipula en su programa.</p>
<p>Se crean llamando a la clase como función.</p>
<pre><code class="language-python">&gt;&gt;&gt; a = Player(2, 3)
&gt;&gt;&gt; b = Player(10, 20)
&gt;&gt;&gt;
</code></pre>
<p><code>a</code> y <code>b</code> son instancias de <code>Player</code>.</p>
<p><em>Importante: La declaración de clase es solo la definición 
(no hace nada por sí misma). Similar a la definición de una función.</em></p>
<h3 id="413-datos-de-instancia">4.1.3 Datos de instancia</h3>
<p>Cada instancia tiene sus propios datos locales.</p>
<pre><code class="language-python">&gt;&gt;&gt; a.x
2
&gt;&gt;&gt; b.x
10
</code></pre>
<p>Estos datos son inicializados por <code>__init__()</code>.</p>
<pre><code class="language-python">class Player:
    def __init__(self, x, y):
        # Cualquier valor guardado en `self` es data de la instancia         
        self.x = x
        self.y = y
        self.health = 100
</code></pre>
<p>No hay restricciones sobre el número total o el tipo de atributos 
almacenados.</p>
<h3 id="414-metodos-de-instancia">4.1.4 Métodos de instancia</h3>
<p>Los métodos de instancia son funciones aplicadas a instancias de un 
objeto.</p>
<pre><code class="language-python">class Player:
    ...
    # `move` es un metodo     
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
</code></pre>
<p>El objeto en sí siempre se pasa como primer argumento.</p>
<pre><code class="language-python">&gt;&gt;&gt; a.move(1, 2)

# empareja `a` a `self` 
# empareja `1` a `dx` 
# empareja `2` a `dy` 
def move(self, dx, dy):
</code></pre>
<p>Por convención, se llama la instancia <code>self</code>. Sin embargo, el nombre 
real utilizado no es importante. El objeto siempre se pasa como 
primer argumento. Es simplemente estilo de programación Python para 
llamar a este argumento <code>self</code>.</p>
<h3 id="415-alcance-de-la-clase">4.1.5 Alcance de la clase</h3>
<p>Las clases no definen un ámbito / espacio de nombres.</p>
<pre><code class="language-python">class Player:
    ...
    def move(self, dx, dy):
        self.x += dx
        self.y += dy

    def left(self, amt):
        move(-amt, 0)       # NO. Llama función global `move`         
        self.move(-amt, 0)  # SI. Llama metodo `move` de arriba. 
</code></pre>
<p>Si desea operar en una instancia, siempre se refiere a ella 
explícitamente (por ejemplo, <code>self</code>).</p>
<h3 id="416-ejercicios">4.1.6 Ejercicios</h3>
<p>A partir de este conjunto de ejercicios, comenzamos a realizar una 
serie de cambios en el código existente de las secciones anteriores. 
Es fundamental que tenga una versión funcional del ejercicio 3.18 
para comenzar. Si no la tiene, trabaje con el código de solución que 
se encuentra en el directorio <code>Solutions/3_18</code>. Está bien copiarlo.</p>
<h4 id="417-ejercicio-41-objetos-como-estructuras-de-datos">4.1.7 Ejercicio 4.1: Objetos como estructuras de datos</h4>
<p>En la sección 2 y 3, trabajamos con datos representados como tuplas y 
diccionarios. Por ejemplo, una tenencia de acciones podría 
representarse como una tupla como esta:</p>
<pre><code class="language-python">s = ('GOOG',100,490.10)
</code></pre>
<p>o como un diccionario como este:</p>
<pre><code class="language-python">s = { 'name'   : 'GOOG',
      'shares' : 100,
      'price'  : 490.10
}
</code></pre>
<p>Incluso puede escribir funciones para manipular dichos datos. </p>
<p>Por ejemplo:</p>
<pre><code class="language-python">def cost(s):
    return s['shares'] * s['price']
</code></pre>
<p>Sin embargo, a medida que su programa crece, es posible que desee 
crear un mejor sentido de organización. Por lo tanto, otro enfoque 
para representar datos sería definir una clase. Cree un archivo 
llamado <code>stock.py</code> y defina una clase <code>Stock</code> que represente una sola 
tenencia de acciones. Las instancias de <code>Stock</code> deben tener los 
atributos de <code>name</code>, <code>shares</code> y <code>price</code>. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; import stock
&gt;&gt;&gt; a = stock.Stock('GOOG',100,490.10)
&gt;&gt;&gt; a.name
'GOOG'
&gt;&gt;&gt; a.shares
100
&gt;&gt;&gt; a.price
490.1
&gt;&gt;&gt;
</code></pre>
<p>Cree algunos objetos <code>Stock</code> más y manipúlelos. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; b = stock.Stock('AAPL', 50, 122.34)
&gt;&gt;&gt; c = stock.Stock('IBM', 75, 91.75)
&gt;&gt;&gt; b.shares * b.price
6117.0
&gt;&gt;&gt; c.shares * c.price
6881.25
&gt;&gt;&gt; stocks = [a, b, c]
&gt;&gt;&gt; stocks
[&lt;stock.Stock object at 0x37d0b0&gt;, &lt;stock.Stock object at 0x37d110&gt;, 
&lt;stock.Stock object at 0x37d050&gt;]
&gt;&gt;&gt; for s in stocks:
     print(f'{s.name:&gt;10s} {s.shares:&gt;10d} {s.price:&gt;10.2f}')

... mire la salida ...
&gt;&gt;&gt;
</code></pre>
<p>Una cosa a enfatizar aquí es que la clase <code>Stock</code> actúa como una 
fábrica para crear instancias de objetos. Básicamente, la llamas como 
una función y crea un nuevo objeto para ti. Además, debe enfatizarse 
que cada objeto es distinto: cada uno tiene sus propios datos que 
están separados de otros objetos que se han creado.</p>
<p>Un objeto definido por una clase es algo similar a un diccionario, 
solo que con una sintaxis algo diferente. Por ejemplo, en lugar de 
escribir <code>s['name']</code> o <code>s['price']</code>, ahora escribe <code>s.name</code> y 
<code>s.price</code>.</p>
<h4 id="ejercicio-42-adicion-de-algunos-metodos">Ejercicio 4.2: Adición de algunos métodos</h4>
<p>Con las clases, puede adjuntar funciones a sus objetos. Estos se 
conocen como métodos y son funciones que operan sobre los datos 
almacenados dentro de un objeto. Agregue un método <code>cost()</code> y 
<code>sell()</code> a su objeto <code>Stock</code>. Deberían funcionar así:</p>
<pre><code class="language-python">&gt;&gt;&gt; import stock
&gt;&gt;&gt; s = stock.Stock('GOOG', 100, 490.10)
&gt;&gt;&gt; s.cost()
49010.0
&gt;&gt;&gt; s.shares
100
&gt;&gt;&gt; s.sell(25)
&gt;&gt;&gt; s.shares
75
&gt;&gt;&gt; s.cost()
36757.5
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-43-creando-una-lista-de-instancias">Ejercicio 4.3: Creando una lista de instancias</h4>
<p>Pruebe estos pasos para hacer una lista de instancias de <code>Stock</code> a 
partir de una lista de diccionarios. Luego calcule el costo total:</p>
<pre><code class="language-python">&gt;&gt;&gt; import fileparse
&gt;&gt;&gt; with open('Data/portfolio.csv') as lines:
...     portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float])
...
&gt;&gt;&gt; portfolio = [ stock.Stock(d['name'], d['shares'], d['price']) for d in portdicts]
&gt;&gt;&gt; portfolio
[&lt;stock.Stock object at 0x10c9e2128&gt;, &lt;stock.Stock object at 0x10c9e2048&gt;, &lt;stock.Stock object at 0x10c9e2080&gt;,
 &lt;stock.Stock object at 0x10c9e25f8&gt;, &lt;stock.Stock object at 0x10c9e2630&gt;, &lt;stock.Stock object at 0x10ca6f748&gt;,
 &lt;stock.Stock object at 0x10ca6f7b8&gt;]
&gt;&gt;&gt; sum([s.cost() for s in portfolio])
44671.15
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-44-usar-tu-clase">Ejercicio 4.4: Usar tu clase</h4>
<p>Modifique la función <code>read_portfolio()</code> en el programa <code>report.py</code> 
para que lea un portafolio en una lista de instancias <code>Stock</code> como se 
muestra en el ejercicio 4.3. Una vez que haya hecho eso, modifique 
todo el código en <code>report.py</code> y <code>pcost.py</code> para que funcione con 
<code>Stock</code> casos en lugar de los diccionarios.</p>
<p>Sugerencia: no debería tener que realizar cambios importantes en el 
código. Principalmente, cambiará el acceso al diccionario, como 
<code>s['shares']</code> en <code>s.shares</code>.</p>
<p>Debería poder ejecutar sus funciones de la misma manera que antes:</p>
<pre><code class="language-python">&gt;&gt;&gt; import pcost
&gt;&gt;&gt; pcost.portfolio_cost('Data/portfolio.csv')
44671.15
&gt;&gt;&gt; import report
&gt;&gt;&gt; report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
&gt;&gt;&gt;
</code></pre>
<h2 id="42-herencia">4.2 Herencia</h2>
<p>La herencia es una herramienta de uso común para escribir programas 
extensibles. Esta sección explora esa idea.</p>
<h3 id="421-introduccion">4.2.1 Introducción</h3>
<p>La herencia se usa para especializar objetos existentes:</p>
<pre><code class="language-python">class Parent:
    ...

class Child(Parent):
    ...
</code></pre>
<p>La nueva clase <code>Child</code> se denomina clase derivada o subclase. 
La clase <code>Parent</code> se conoce como clase base o superclase. <code>Parent</code> se 
especifica en <code>()</code> después de que el nombre de la clase, 
<code>class Child(Parent):</code>.</p>
<h3 id="422-extension">4.2.2 Extensión</h3>
<p>Con la herencia, estás tomando una clase existente y:</p>
<ul>
<li>Agregando nuevos métodos</li>
<li>Redefiniendo algunos de los métodos existentes</li>
<li>Agregando nuevos atributos a las instancias</li>
</ul>
<p>Al final, está ampliando el código existente.</p>
<h3 id="423-ejemplo">4.2.3 Ejemplo</h3>
<p>Suponga que esta es su clase inicial:</p>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    def cost(self):
        return self.shares * self.price

    def sell(self, nshares):
        self.shares -= nshares
</code></pre>
<p>Puede cambiar cualquier parte de esto mediante herencia.</p>
<h3 id="424-agregando-un-nuevo-metodo">4.2.4 Agregando un nuevo método</h3>
<pre><code class="language-python">class MyStock(Stock):
    def panic(self):
        self.sell(self.shares)
</code></pre>
<p>Ejemplo de uso.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = MyStock('GOOG', 100, 490.1)
&gt;&gt;&gt; s.sell(25)
&gt;&gt;&gt; s.shares
75
&gt;&gt;&gt; s.panic()
&gt;&gt;&gt; s.shares
0
&gt;&gt;&gt;
</code></pre>
<h3 id="425-redefiniendo-un-metodo-existente">4.2.5 Redefiniendo un método existente</h3>
<pre><code class="language-python">class MyStock(Stock):
    def cost(self):
        return 1.25 * self.shares * self.price
</code></pre>
<p>Ejemplo de uso.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = MyStock('GOOG', 100, 490.1)
&gt;&gt;&gt; s.cost()
61262.5
&gt;&gt;&gt;
</code></pre>
<p>El nuevo método reemplaza al antiguo. Los otros métodos no se ven 
afectados.</p>
<h3 id="426-comportamiento-primordial">4.2.6 Comportamiento Primordial</h3>
<p>A veces, una clase extiende un método existente, pero quiere usar 
la implementación original dentro de la redefinición. Para esto, 
haga uso de <code>super()</code>:</p>
<pre><code class="language-python">class Stock:
    ...
    def cost(self):
        return self.shares * self.price
    ...

class MyStock(Stock):
    def cost(self):
        # haga la llamada a `super`         
        actual_cost = super().cost()
        return 1.25 * actual_cost
</code></pre>
<p>Haga uso de <code>super()</code> para llamar a la versión anterior.</p>
<p><em>Precaución: en Python 2, la sintaxis era más detallada.</em></p>
<pre><code class="language-python">actual_cost = super(MyStock, self).cost()
</code></pre>
<h3 id="427-__init__-y-herencia">4.2.7 <code>__init__</code> y herencia</h3>
<p>Si <code>__init__</code> se redefine, es esencial inicializar la clase padre.</p>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

class MyStock(Stock):
    def __init__(self, name, shares, price, factor):
        # revise el llamado a `super` y `__init__`         
        super().__init__(name, shares, price)
        self.factor = factor

    def cost(self):
        return self.factor * super().cost()
</code></pre>
<p>Debe llamar el método <code>__init__()</code> en <code>super</code> cuál es la forma de 
llamar a la versión anterior como se mostró anteriormente.</p>
<h3 id="428-usando-la-herencia">4.2.8 Usando la herencia</h3>
<p>La herencia se usa a veces para organizar objetos relacionados.</p>
<pre><code class="language-python">class Shape:
    ...

class Circle(Shape):
    ...

class Rectangle(Shape):
    ...
</code></pre>
<p>Piense en una jerarquía lógica o taxonomía. Sin embargo, un uso más 
común (y práctico) está relacionado con hacer código reutilizable o 
extensible. Por ejemplo, un marco puede definir una clase base e 
indicarle que la personalice.</p>
<pre><code class="language-python">class CustomHandler(TCPHandler):
    def handle_request(self):
        ...
        # Custom processing 
</code></pre>
<p>La clase base contiene algún código de propósito general. Tu clase 
hereda y personaliza partes específicas.</p>
<h3 id="429-relacion-es-un">4.2.9 Relación "es un"</h3>
<p>La herencia establece una relación de tipo.</p>
<pre><code class="language-python">class Shape:
    ...

class Circle(Shape):
    ...
</code></pre>
<p>Compruebe la instancia del objeto.</p>
<pre><code class="language-python">&gt;&gt;&gt; c = Circle(4.0)
&gt;&gt;&gt; isinstance(c, Shape)
True
&gt;&gt;&gt;
</code></pre>
<p><em>Importante: lo ideal es que cualquier código que funcione con 
instancias de la clase principal también funcionará con instancias de 
la clase secundaria.</em></p>
<h3 id="4210-clase-base-object">4.2.10 clase base <code>object</code></h3>
<p>Si una clase no tiene padre, a veces se usa <code>object</code>  como base.</p>
<pre><code class="language-python">class Shape(object):
    ...
</code></pre>
<p><code>object</code> es la raíz de todos los objetos en Python.</p>
<p><em>Nota: no es técnicamente necesario, pero a menudo se lo ve 
especificado como una retención de su uso obligatorio en Python 2. 
Si se omite, la clase aún hereda implícitamente <code>object</code>.</em></p>
<h3 id="4211-herencia-multiple">4.2.11 Herencia múltiple</h3>
<p>Puede heredar de varias clases especificándolas en la definición de 
la clase.</p>
<pre><code class="language-python">class Mother:
    ...

class Father:
    ...

class Child(Mother, Father):
    ...
</code></pre>
<p>La clase <code>Child</code> hereda características de ambos padres. Hay algunos 
detalles bastante complicados. No lo haga a menos que sepa lo que 
está haciendo. Se proporcionará más información en la siguiente 
sección, pero no vamos a utilizar más la herencia múltiple en este 
curso.</p>
<h3 id="4212-ejercicios">4.2.12 Ejercicios</h3>
<p>Un uso importante de la herencia es la escritura de código que debe 
ampliarse o personalizarse de diversas formas, especialmente en 
bibliotecas o marcos de trabajo (frameworks). Para ilustrarlo, 
considere la <code>print_report()</code> función en su programa <code>report.py</code> . 
Debería verse algo como esto:</p>
<pre><code class="language-python">def print_report(reportdata):
    ''' Print a nicely formated table from a list of (name, shares, price, change) tuples. '''
    headers = ('Name','Shares','Price','Change')
    print('%10s %10s %10s %10s' % headers)
    print(('-'*10 + ' ')*len(headers))
    for row in reportdata:
        print('%10s %10d %10.2f %10.2f' % row)
</code></pre>
<p>Cuando ejecuta su programa de informes, debería obtener un resultado 
como este:</p>
<pre><code class="language-python">&gt;&gt;&gt; import report
&gt;&gt;&gt; report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
</code></pre>
<h4 id="ejercicio-45-un-problema-de-extensibilidad">Ejercicio 4.5: un problema de extensibilidad</h4>
<p>Suponga que desea modificar la función <code>print_report()</code> para admitir 
una variedad de formatos de salida diferentes, como texto sin 
formato, HTML, CSV o XML. Para hacer esto, podría intentar escribir 
una función gigantesca que lo hiciera todo. Sin embargo, hacerlo 
probablemente conduciría a un desorden insostenible. En cambio, esta 
es una oportunidad perfecta para usar la herencia.</p>
<p>Para comenzar, concéntrese en los pasos involucrados en la creación 
de una tabla. En la parte superior de la tabla hay un conjunto de 
encabezados de tabla. Después de eso, aparecen filas de datos de la 
tabla. Tomemos esos pasos y pongámoslos en su propia clase. Cree un 
archivo llamado <code>tableformat.py</code> y defina la siguiente clase:</p>
<pre><code class="language-python"># tableformat.py 
class TableFormatter:
    def headings(self, headers):
        ''' Emite el encabezado de la tabla '''
    raise NotImplementedError()

    def row(self, rowdata):
        ''' Emite una fila de data de tabla. '''
    raise NotImplementedError()
</code></pre>
<p>Esta clase no hace nada, pero sirve como una especie de 
especificación de diseño para clases adicionales que se definirán en 
breve. Una clase como esta a veces se denomina "clase base abstracta".</p>
<p>Modifique la función <code>print_report()</code> para que acepte un objeto 
<code>TableFormatter</code> como entrada e invoque métodos en él para producir 
la salida. Por ejemplo, así:</p>
<pre><code class="language-python"># report.py ...

def print_report(reportdata, formatter):
    ''' Imprima una tabla con un formato agradable a partir de una lista de tuplas (nombre, acciones, precio, cambio). '''
    formatter.headings(['Name','Shares','Price','Change'])
    for name, shares, price, change in reportdata:
        rowdata = [ name, str(shares), f'{price:0.2f}', f'{change:0.2f}' ]
        formatter.row(rowdata)
</code></pre>
<p>Toda vez que agregó un argumento a <code>print_report()</code>, también 
necesitará modificar la portfolio_report()función. Cámbielo para que 
cree un aspecto <code>TableFormatter</code> como este:</p>
<pre><code class="language-python"># report.py 
import tableformat

...
def portfolio_report(portfoliofile, pricefile):
    ''' Make a stock report given portfolio and price data files. '''
    # Read data files     portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Create the report data     report = make_report_data(portfolio, prices)

    # Print it out     formatter = tableformat.TableFormatter()
    print_report(report, formatter)
</code></pre>
<p>Ejecute este nuevo código:</p>
<pre><code class="language-python">&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; import report
&gt;&gt;&gt; report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
... el programa se bloquea ...
</code></pre>
<p>Debería bloquearse inmediatamente con una excepción 
<code>NotImplementedError</code>. Eso no es demasiado emocionante, pero es 
exactamente lo que esperábamos. Continúe con la siguiente parte.</p>
<h4 id="ejercicio-46-uso-de-la-herencia-para-producir-resultados-diferentes">Ejercicio 4.6: Uso de la herencia para producir resultados diferentes</h4>
<p>La clase <code>TableFormatter</code> que definió en la parte (a) está destinada 
a ampliarse mediante herencia. De hecho, esa es toda la idea. Para 
ilustrar, defina una clase <code>TextTableFormatter</code> como esta:</p>
<pre><code class="language-python"># tableformat.py ...
class TextTableFormatter(TableFormatter):
    ''' Emite una tabla de texto sin formato '''
    def headings(self, headers):
        for h in headers:
            print(f'{h:&gt;10s}', end=' ')
        print()
        print(('-'*10 + ' ')*len(headers))

    def row(self, rowdata):
        for d in rowdata:
            print(f'{d:&gt;10s}', end=' ')
        print()
</code></pre>
<p>Modifique la función <code>portfolio_report()</code> así y pruébela:</p>
<pre><code class="language-python"># report.py ...
def portfolio_report(portfoliofile, pricefile):
    ''' Hace un informe de acciones en función de los archivos de datos de precios y cartera. '''
    # Lee los archivos de data     
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Crea el reporte de data    
    report = make_report_data(portfolio, prices)

    # Lo imprime   
    formatter = tableformat.TextTableFormatter()
    print_report(report, formatter)
</code></pre>
<p>Esto debería producir el mismo resultado que antes:</p>
<pre><code class="language-python">&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; import report
&gt;&gt;&gt; report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
&gt;&gt;&gt;
</code></pre>
<p>Sin embargo, cambiemos la salida a otra cosa. Defina una nueva clase 
<code>CSVTableFormatter</code> que produzca resultados en formato CSV:</p>
<pre><code class="language-python"># tableformat.py ...
class CSVTableFormatter(TableFormatter):
    ''' Output de data de portfolio en formato CSV. '''
    def headings(self, headers):
        print(','.join(headers))

    def row(self, rowdata):
        print(','.join(rowdata))
</code></pre>
<p>Modifique su programa principal de la siguiente manera:</p>
<pre><code class="language-python">def portfolio_report(portfoliofile, pricefile):
    ''' Hace un informe de acciones en función de los archivos de datos de precios y cartera. '''  
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    report = make_report_data(portfolio, prices)

    formatter = tableformat.CSVTableFormatter()
    print_report(report, formatter)
</code></pre>
<p>Ahora debería ver una salida CSV como esta:</p>
<pre><code class="language-python">&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; import report
&gt;&gt;&gt; report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
Name,Shares,Price,Change
AA,100,9.22,-22.98
IBM,50,106.28,15.18
CAT,150,35.46,-47.98
MSFT,200,20.89,-30.34
GE,95,13.48,-26.89
MSFT,50,20.89,-44.21
IBM,100,106.28,35.84
</code></pre>
<p>Con una idea similar, defina una clase <code>HTMLTableFormatter</code> que 
produzca una tabla con el siguiente resultado:</p>
<pre><code class="language-python">&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Shares&lt;/th&gt;&lt;th&gt;Price&lt;/th&gt;&lt;th&gt;Change&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;AA&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;9.22&lt;/td&gt;&lt;td&gt;-22.98&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;IBM&lt;/td&gt;&lt;td&gt;50&lt;/td&gt;&lt;td&gt;106.28&lt;/td&gt;&lt;td&gt;15.18&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;CAT&lt;/td&gt;&lt;td&gt;150&lt;/td&gt;&lt;td&gt;35.46&lt;/td&gt;&lt;td&gt;-47.98&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;MSFT&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;20.89&lt;/td&gt;&lt;td&gt;-30.34&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;GE&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;td&gt;13.48&lt;/td&gt;&lt;td&gt;-26.89&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;MSFT&lt;/td&gt;&lt;td&gt;50&lt;/td&gt;&lt;td&gt;20.89&lt;/td&gt;&lt;td&gt;-44.21&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;IBM&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;td&gt;106.28&lt;/td&gt;&lt;td&gt;35.84&lt;/td&gt;&lt;/tr&gt;
</code></pre>
<p>Pruebe su código modificando el programa principal para crear un 
objeto <code>HTMLTableFormatter</code> en lugar de un objeto <code>CSVTableFormatter</code>.</p>
<h4 id="ejercicio-47-polimorfismo-en-accion">Ejercicio 4.7: Polimorfismo en acción</h4>
<p>Una característica importante de la programación orientada a objetos 
es que puede conectar un objeto a un programa y funcionará sin tener 
que cambiar el código existente. Por ejemplo, si escribiera un 
programa que esperaba usar un objeto <code>TableFormatter</code>, funcionaría sin 
importar qué tipo de <code>TableFormatter</code> le haya dado. Este comportamiento 
a veces se denomina "polimorfismo".</p>
<p>Un problema potencial es averiguar cómo permitir que un usuario 
elija el formateador que desee. El uso directo de los nombres de las 
clases <code>TextTableFormatter</code> es a menudo molesto. Por lo tanto, podría 
considerar algún enfoque simplificado. Quizás incruste una 
declaración-if en el código como esta:</p>
<pre><code class="language-python">def portfolio_report(portfoliofile, pricefile, fmt='txt'):
    ''' Hace un informe de acciones en función de los archivos de datos de precios y cartera. '''
    # Lea los archivos     
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Crea el reporte   
    report = make_report_data(portfolio, prices)

    # Lo imprime    
    if fmt == 'txt':
        formatter = tableformat.TextTableFormatter()
    elif fmt == 'csv':
        formatter = tableformat.CSVTableFormatter()
    elif fmt == 'html':
        formatter = tableformat.HTMLTableFormatter()
    else:
        raise RuntimeError(f'Unknown format {fmt}')
    print_report(report, formatter)
</code></pre>
<p>En este código, el usuario especifica un nombre simplificado como 
'txt'o 'csv' para elegir un formato. Sin embargo, ¿es la mejor idea 
poner una enorme declaración <code>if</code> en la función <code>portfolio_report()</code>? 
Podría ser mejor mover ese código a una función de propósito general 
en otro lugar.</p>
<p>En el archivo <code>tableformat.py</code>, agregar una función 
<code>create_formatter(name)</code> que permite a un usuario crear un 
formateador dado un nombre de salida como 'txt', 'csv'o 'html'. 
Modifique <code>portfolio_report()</code> para que se vea así:</p>
<pre><code class="language-python">def portfolio_report(portfoliofile, pricefile, fmt='txt'):
    ''' Hace un informe de acciones en función de los archivos de datos de precios y cartera. '''
    # Lea los archivos     
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Crea el reporte      
    report = make_report_data(portfolio, prices)

    # Lo imprime     
    formatter = tableformat.create_formatter(fmt)
    print_report(report, formatter)
</code></pre>
<p>Intente llamar a la función con diferentes formatos para asegurarse de que esté funcionando.</p>
<h4 id="ejercicio-48-poniendo-todo-junto">Ejercicio 4.8: Poniendo todo junto</h4>
<p>Modifique el programa <code>report.py</code> para que la función 
<code>portfolio_report()</code> tome un argumento opcional que especifique el 
formato de salida. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv', 'txt')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
&gt;&gt;&gt;
</code></pre>
<p>Modifique el programa principal para que se pueda dar un formato en 
la línea de comando:</p>
<pre><code class="language-shell">$ python report.py Data/portfolio.csv Data/prices.csv csv
Name,Shares,Price,Change
AA,100,9.22,-22.98
IBM,50,106.28,15.18
CAT,150,35.46,-47.98
MSFT,200,20.89,-30.34
GE,95,13.48,-26.89
MSFT,50,20.89,-44.21
IBM,100,106.28,35.84
bash $
</code></pre>
<h3 id="discusion">Discusión</h3>
<p>Escribir código extensible es uno de los usos más comunes de la 
herencia en bibliotecas y marcos de desarrollo. Por ejemplo, un marco 
puede indicarle que defina su propio objeto que hereda de una clase 
base proporcionada. Luego se le indica que complete varios métodos 
que implementan varios bits de funcionalidad.</p>
<p>Otro concepto algo más profundo es la idea de "ser dueño de sus 
abstracciones". En los ejercicios, definimos nuestra propia clase 
para formatear una tabla. Puede mirar su código y decirse a sí mismo: 
"¡Debería usar una biblioteca de formato o algo que ya haya creado 
otra persona!" No, debe usar AMBOS su clase y una biblioteca. 
El uso de su propia clase promueve un acoplamiento flexible y es más 
flexible. Siempre que su aplicación utilice la interfaz de 
programación de su clase, puede cambiar la implementación interna 
para que funcione de la forma que desee. Puede escribir código 
totalmente personalizado. Puede utilizar el paquete de terceros de 
alguien. Cambie un paquete de terceros por un paquete diferente 
cuando encuentre uno mejor. No importa, ninguno de los códigos de su 
aplicación se romperá mientras conserve la interfaz. Esa es una idea 
poderosa y es una de las razones por las que podría considerar la 
herencia para algo como esto.</p>
<p>Dicho esto, diseñar programas orientados a objetos puede ser 
extremadamente difícil. Para obtener más información, probablemente 
debería buscar libros sobre el tema de los patrones de diseño 
(aunque comprender lo que sucedió en este ejercicio lo llevará 
bastante lejos en términos de usar objetos de una manera 
práctica e útil).</p>
<h2 id="43-metodos-especiales">4.3 Métodos especiales</h2>
<p>Varias partes del comportamiento de Python se pueden personalizar a 
través de métodos especiales o llamados "mágicos". Esta sección 
presenta esa idea. Además, se analizan el acceso a atributos 
dinámicos y los métodos vinculados.</p>
<h3 id="431-introduccion">4.3.1 Introducción</h3>
<p>Las clases pueden definir métodos especiales. Estos tienen un 
significado especial para el intérprete de Python. Siempre van 
precedidos y seguidos de <code>__</code>. Por ejemplo <code>__init__</code>.</p>
<pre><code class="language-python">class Stock(object):
    def __init__(self):
        ...
    def __repr__(self):
        ...
</code></pre>
<p>Hay docenas de métodos especiales, pero solo veremos algunos ejemplos 
específicos.</p>
<h3 id="432-metodos-especiales-para-conversiones-de-cadenas">4.3.2 Métodos especiales para conversiones de cadenas</h3>
<p>Los objetos tienen dos representaciones de cadenas.</p>
<pre><code class="language-python">&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; d = date(2012, 12, 21)
&gt;&gt;&gt; print(d)
2012-12-21
&gt;&gt;&gt; d
datetime.date(2012, 12, 21)
&gt;&gt;&gt;
</code></pre>
<p>La función <code>str()</code> se usa para crear una buena salida imprimible:</p>
<pre><code class="language-python">&gt;&gt;&gt; str(d)
'2012-12-21'
&gt;&gt;&gt;
</code></pre>
<p>La función <code>repr()</code> se utiliza para crear una representación más 
detallada para los programadores.</p>
<pre><code class="language-python">&gt;&gt;&gt; repr(d)
'datetime.date(2012, 12, 21)'
&gt;&gt;&gt;
</code></pre>
<p>Esas funciones <code>str()</code> y <code>repr()</code> usan un par de métodos especiales 
en la clase para producir la cadena que se mostrará.</p>
<pre><code class="language-python">class Date(object):
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    # Utilicelo con `str()`     
    def __str__(self):
        return f'{self.year}-{self.month}-{self.day}'

    # Utilicelo con `repr()`     
    def __repr__(self):
        return f'Date({self.year},{self.month},{self.day})'
</code></pre>
<p><em>Nota: La convención para <strong>repr</strong>()es devolver una cadena que, 
cuando se alimenta eval(), recreará el objeto subyacente. Si esto no 
es posible, se utiliza en su lugar algún tipo de representación 
fácilmente legible.</em></p>
<h3 id="433-metodos-especiales-para-matematicas">4.3.3 Métodos especiales para matemáticas</h3>
<p>Los operadores matemáticos implican llamadas a los siguientes métodos.</p>
<pre><code class="language-python">a + b       a.__add__(b)
a - b       a.__sub__(b)
a * b       a.__mul__(b)
a / b       a.__truediv__(b)
a // b      a.__floordiv__(b)
a % b       a.__mod__(b)
a &lt;&lt; b      a.__lshift__(b)
a &gt;&gt; b      a.__rshift__(b)
a &amp; b       a.__and__(b)
a | b       a.__or__(b)
a ^ b       a.__xor__(b)
a ** b      a.__pow__(b)
-a          a.__neg__()
~a          a.__invert__()
abs(a)      a.__abs__()
</code></pre>
<h3 id="434-metodos-especiales-para-acceder-a-los-elementos">4.3.4 Métodos especiales para acceder a los elementos</h3>
<p>Estos son los métodos para implementar contenedores.</p>
<pre><code class="language-python">len(x)      x.__len__()
x[a]        x.__getitem__(a)
x[a] = v    x.__setitem__(a,v)
del x[a]    x.__delitem__(a)
</code></pre>
<p>Puedes usarlos en tus clases.</p>
<pre><code class="language-python">class Sequence:
    def __len__(self):
        ...
    def __getitem__(self,a):
        ...
    def __setitem__(self,a,v):
        ...
    def __delitem__(self,a):
        ...
</code></pre>
<h3 id="435-invocacion-de-metodo">4.3.5 Invocación de método</h3>
<p>Invocar un método es un proceso de dos pasos.</p>
<ul>
<li>Búsqueda: el .operador</li>
<li>Llamada de método: el operador <code>()</code></li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('GOOG',100,490.10)
&gt;&gt;&gt; c = s.cost  # Lookup &gt;&gt;&gt; c
&lt;bound method Stock.cost of &lt;Stock object at 0x590d0&gt;&gt;
&gt;&gt;&gt; c()         # Method call 49010.0
&gt;&gt;&gt;
</code></pre>
<h3 id="436-metodos-vinculados">4.3.6 Métodos vinculados</h3>
<p>Un método que aún no ha sido invocado por el operador de llamada de 
función <code>()</code> se conoce como método vinculado. Opera en la instancia 
donde se originó.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('GOOG', 100, 490.10)
&gt;&gt;&gt; s
&lt;Stock object at 0x590d0&gt;
&gt;&gt;&gt; c = s.cost
&gt;&gt;&gt; c
&lt;bound method Stock.cost of &lt;Stock object at 0x590d0&gt;&gt;
&gt;&gt;&gt; c()
49010.0
&gt;&gt;&gt;
</code></pre>
<p>Los métodos vinculados son a menudo una fuente de errores no evidentes 
por descuido. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('GOOG', 100, 490.10)
&gt;&gt;&gt; print('Cost : %0.2f' % s.cost)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: float argument required
&gt;&gt;&gt;
</code></pre>
<p>O comportamiento tortuoso que es difícil de depurar.</p>
<pre><code class="language-python">f = open(filename, 'w')
...
f.close     # Oops. `f` todavía abierto. 
</code></pre>
<p>En ambos casos, el error se debe a que se olvidó de incluir los 
paréntesis finales. Por ejemplo, <code>s.cost()</code> o <code>f.close()</code>.</p>
<h3 id="437-acceso-a-atributos">4.3.7 Acceso a atributos</h3>
<p>Existe una forma alternativa de acceder, manipular y gestionar 
atributos.</p>
<pre><code class="language-python">getattr(obj, 'name')          # Igual a obj.name 
setattr(obj, 'name', value)   # Igual a obj.name = value 
delattr(obj, 'name')          # Igual a del obj.name 
hasattr(obj, 'name')          # Comprueba si el atributo existe 
</code></pre>
<p>Ejemplo:</p>
<pre><code class="language-python">if hasattr(obj, 'x'):
    x = getattr(obj, 'x'):
else:
    x = None
</code></pre>
<p>Nota: <code>getattr()</code> también tiene un valor predeterminado útil <code>*arg</code>.</p>
<pre><code class="language-python">x = getattr(obj, 'x', None)
</code></pre>
<h3 id="438-ejercicios">4.3.8 Ejercicios</h3>
<h4 id="ejercicio-49-mejor-resultado-para-imprimir-objetos">Ejercicio 4.9: Mejor resultado para imprimir objetos</h4>
<p>Modifique el objeto <code>Stock</code> que definió <code>stock.py</code> para que el 
método <code>__repr__()</code> produzca una salida más útil. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; goog = Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; goog
Stock('GOOG', 100, 490.1)
&gt;&gt;&gt;
</code></pre>
<p>Vea lo que sucede cuando lee una cartera de acciones y vea la lista 
resultante después de haber realizado estos cambios. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; import report
&gt;&gt;&gt; portfolio = report.read_portfolio('Data/portfolio.csv')
&gt;&gt;&gt; portfolio
... see what the output is ...
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-410-un-ejemplo-de-uso-de-getattr">Ejercicio 4.10: un ejemplo de uso de <code>getattr()</code></h4>
<p><code>getattr()</code> es un mecanismo alternativo para leer atributos. 
Se puede usar para escribir código extremadamente flexible. 
Para empezar, prueba este ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; import stock
&gt;&gt;&gt; s = stock.Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; columns = ['name', 'shares']
&gt;&gt;&gt; for colname in columns:
        print(colname, '=', getattr(s, colname))

name = GOOG
shares = 100
&gt;&gt;&gt;
</code></pre>
<p>Observe con atención que los datos de salida están determinados por 
completo por los nombres de los atributos enumerados en la variable 
<code>columns</code>.</p>
<p>En el archivo <code>tableformat.py</code>, tome esta idea y amplíela en una 
función generalizada print_table()que imprima una tabla que muestra 
los atributos especificados por el usuario de una lista de objetos 
arbitrarios. Al igual que con la función <code>print_report()</code> anterior, 
<code>print_table()</code> también debería aceptar una instancia de 
<code>TableFormatter</code>  para controlar el formato de salida. Así es como 
debería funcionar:</p>
<pre><code class="language-python">&gt;&gt;&gt; import report
&gt;&gt;&gt; portfolio = report.read_portfolio('Data/portfolio.csv')
&gt;&gt;&gt; from tableformat import create_formatter, print_table
&gt;&gt;&gt; formatter = create_formatter('txt')
&gt;&gt;&gt; print_table(portfolio, ['name','shares'], formatter)
      name     shares
---------- ----------
        AA        100
       IBM         50
       CAT        150
      MSFT        200
        GE         95
      MSFT         50
       IBM        100

&gt;&gt;&gt; print_table(portfolio, ['name','shares','price'], formatter)
      name     shares      price
---------- ---------- ----------
        AA        100       32.2
       IBM         50       91.1
       CAT        150      83.44
      MSFT        200      51.23
        GE         95      40.37
      MSFT         50       65.1
       IBM        100      70.44
&gt;&gt;&gt;
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../5/" class="btn btn-neutral float-right" title="5 Entrañas del Objeto">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../3/" class="btn btn-neutral" title="3 Organización de un Programa"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../3/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../5/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
