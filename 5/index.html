<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>5 Entrañas del Objeto - Python Práctico</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "5 Entra\u00f1as del Objeto";
    var mkdocs_page_input_path = "5.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/shell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Python Práctico</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Sobre el curso</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../temario/">Temario</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../faq/">Preguntas</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../0/">0 Empiece aqui</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../1/">1 Intro a Python</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../2/">2 Trabajando con Data</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../3/">3 Organización de un Programa</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../4/">4 Clases y Objetos</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">5 Entrañas del Objeto</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#51-diccionarios-otra-visita">5.1 Diccionarios, Otra Visita</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#511-diccionarios">5.1.1 Diccionarios</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#512-dicts-y-modulos">5.1.2 Dicts y Modulos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#513-dicts-y-objetos">5.1.3 Dicts y objetos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#514-miembros-de-la-clase">5.1.4 Miembros de la clase</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#515-instancias-y-clases">5.1.5 Instancias y clases</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#517-modificar-instancias">5.1.7 Modificar instancias</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#518-atributos-de-lectura">5.1.8 Atributos de lectura</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#519-como-funciona-la-herencia">5.1.9 Cómo funciona la herencia</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5110-lectura-de-atributos-con-herencia">5.1.10 Lectura de atributos con herencia</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5111-lectura-de-atributos-con-herencia-unica">5.1.11 Lectura de atributos con herencia única</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5112-orden-de-resolucion-de-metodos-o-mro">5.1.12 Orden de resolución de métodos o MRO</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5113-mro-en-herencia-multiple">5.1.13 MRO en herencia múltiple</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5114-una-reutilizacion-de-codigo-extrano-que-implica-herencia-multiple">5.1.14 Una reutilización de código extraño (que implica herencia múltiple)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5115-el-patron-mixin">5.1.15 El patrón "Mixin"</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5116-por-que-super">5.1.16 Por qué super()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5117-algunas-precauciones">5.1.17 Algunas precauciones</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5118-ejercicios">5.1.18 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-51-representacion-de-instancias">Ejercicio 5.1: Representación de instancias</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-52-modificacion-de-datos-de-instancia">Ejercicio 5.2: Modificación de datos de instancia</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-53-el-papel-de-las-clases">Ejercicio 5.3: El papel de las clases</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-54-metodos-vinculados">Ejercicio 5.4: Métodos vinculados</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-55-herencia">Ejercicio 5.5: Herencia</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#52-clases-y-encapsulacion">5.2 Clases y encapsulación</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#521-publico-vs-privado">5.2.1 Público vs Privado</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#522-un-problema">5.2.2 Un problema</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#523-encapsulacion-de-python">5.2.3 Encapsulación de Python</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#524-atributos-privados">5.2.4 Atributos privados</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#525-atributos-simples">5.2.5 Atributos simples</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#526-atributos-gestionados">5.2.6 Atributos gestionados</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#527-propiedades">5.2.7 Propiedades</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#528-acceso-uniforme">5.2.8 Acceso uniforme</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#529-sintaxis-del-decorador">5.2.9 Sintaxis del decorador</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5210-slots-atributo">5.2.10 slots Atributo</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5211-comentarios-finales-sobre-encapsulacion">5.2.11 Comentarios finales sobre encapsulación</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5212-ejercicios">5.2.12 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-56-propiedades-simples">Ejercicio 5.6: Propiedades simples</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-57-propiedades-y-establecedores">Ejercicio 5.7: Propiedades y establecedores</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-58-agregar-ranuras">Ejercicio 5.8: Agregar ranuras</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../6/">6 Generadores</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../7/">7 Temas avanzados</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../8/">8 Prueba y Depuración</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../9/">9 Paquetes</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../licencia/">Licencia</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Python Práctico</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>5 Entrañas del Objeto</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="5-funcionamiento-interno-del-objeto-python">5. Funcionamiento interno del objeto Python</h1>
<p>En esta sección aprenderemos sobre el funcionamiento interno de los objetos en Python. Algunos programadores con experiencia en otros lenguajes de programación a menudo encuentran que la noción de clases en Python carece de ciertas características. Por ejemplo, no existe la noción de control de accesso (e.g. privado, protegido), el argumento self lo encuentran extraño, y trabajar con objetos se siente como una actividad con mucho libertinaje. Conoceremos como todo funciona y algunos patrones comunes para la encapsulación interna de objetos.</p>
<h2 id="51-diccionarios-otra-visita">5.1 Diccionarios, Otra Visita</h2>
<p>El sistema de objetos de Python se basa en gran medida en una implementación que incluye diccionarios. Esta sección trata sobre eso.</p>
<h3 id="511-diccionarios">5.1.1 Diccionarios</h3>
<p>Recuerde que un diccionario es una colección de valores con nombre.</p>
<pre><code class="language-python">stock = {
    'name' : 'GOOG',
    'shares' : 100,
    'price' : 490.1
}
</code></pre>
<p>Los diccionarios se utilizan comúnmente para estructuras de datos simples. Sin embargo, se utilizan para partes críticas del interpretador y pueden ser el tipo de datos más importante en Python .</p>
<h3 id="512-dicts-y-modulos">5.1.2 Dicts y Modulos</h3>
<p>Dentro de un módulo, un diccionario contiene todas las variables y funciones globales.</p>
<pre><code class="language-python"># foo.py
x = 42
def bar():
    ...

def spam():
    ...
</code></pre>
<p>Si inspecciona <code>foo.__dict__</code> o <code>globals()</code>, verá el diccionario.</p>
<pre><code class="language-python">{
    'x' : 42,
    'bar' : &lt;function bar&gt;,
    'spam' : &lt;function spam&gt;
}
</code></pre>
<h3 id="513-dicts-y-objetos">5.1.3 Dicts y objetos</h3>
<p>Los objetos definidos por el usuario también utilizan diccionarios para datos de instancia y clases. De hecho, todo el sistema de objetos es principalmente una capa adicional que se coloca encima de los diccionarios.</p>
<p>Un diccionario contiene los datos ejemplo, <code>__dict__</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; s.__dict__
{'name' : 'GOOG', 'shares' : 100, 'price': 490.1 }
</code></pre>
<p>Popule este <code>dict</code> (e instancia) al asignar a <code>self</code>.</p>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
</code></pre>
<p>Los datos de la instancia que se encuentran en <code>self.__dict__</code> tienen el siguiente aspecto:</p>
<pre><code class="language-python">{
    'name': 'GOOG',
    'shares': 100,
    'price': 490.1
}
</code></pre>
<p>Cada instancia tiene su propio diccionario privado.</p>
<pre><code class="language-python">s = Stock('GOOG', 100, 490.1)  # {'name' : 'GOOG','shares' : 100, 'price': 490.1 }
t = Stock('AAPL', 50, 123.45)  # {'name' : 'AAPL','shares' : 50, 'price': 123.45 }
</code></pre>
<p>Si creó 100 instancias de alguna clase, hay 100 diccionarios que contienen datos.</p>
<h3 id="514-miembros-de-la-clase">5.1.4 Miembros de la clase</h3>
<p>Un diccionario separado también contiene los métodos.</p>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    def cost(self):
        return self.shares * self.price

    def sell(self, nshares):
        self.shares -= nshares
</code></pre>
<p>El diccionario está en <code>Stock.__dict__</code>.</p>
<pre><code class="language-python">{
    'cost': &lt;function&gt;,
    'sell': &lt;function&gt;,
    '__init__': &lt;function&gt;
}
</code></pre>
<h3 id="515-instancias-y-clases">5.1.5 Instancias y clases</h3>
<p>Las instancias y clases están vinculadas entre sí. El atributo <code>__class__</code> hace referencia a la clase.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; s.__dict__
{ 'name': 'GOOG', 'shares': 100, 'price': 490.1 }
&gt;&gt;&gt; s.__class__
&lt;class '__main__.Stock'&gt; &gt;&gt;&gt;
````

El diccionario de instancias contiene datos únicos para cada instancia, mientras que el diccionario de clase contiene datos compartidos colectivamente por todas las instancias.

### 5.1.6 Acceso a atributos

Cuando trabaja con objetos, acceda a datos y métodos utilizando el operador `.`.

```python
x = obj.name  # Conseguir
obj.name = value  # Definir
del obj.name  # Remover
</code></pre>
<p>Estas operaciones están directamente vinculadas al diccionario subyacente del objeto.</p>
<h3 id="517-modificar-instancias">5.1.7 Modificar instancias</h3>
<p>Las operaciones que modifican un objeto actualizan el diccionario subyacente.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; s.__dict__
{ 'name':'GOOG', 'shares': 100, 'price': 490.1 }
&gt;&gt;&gt; s.shares = 50       # Setting &gt;&gt;&gt; s.date = '6/7/2007' # Setting &gt;&gt;&gt; s.__dict__
{ 'name': 'GOOG', 'shares': 50, 'price': 490.1, 'date': '6/7/2007' }
&gt;&gt;&gt; del s.shares        # Deleting &gt;&gt;&gt; s.__dict__
{ 'name': 'GOOG', 'price': 490.1, 'date': '6/7/2007' }
&gt;&gt;&gt;
</code></pre>
<h3 id="518-atributos-de-lectura">5.1.8 Atributos de lectura</h3>
<p>Suponga que lee un atributo en una instancia.</p>
<pre><code class="language-python">x = obj.name
</code></pre>
<p>El atributo puede existir en dos lugares:</p>
<ul>
<li>Diccionario de la instancia local.</li>
<li>Diccionario de la clase.</li>
</ul>
<p>Se deben revisar ambos diccionarios. Primero, verifique en el <code>__dict__</code> local. Si no se encuentra ahí, busque en el <code>__dict__</code> de la clase, a través de <code>__class__</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock(...)
&gt;&gt;&gt; s.name
'GOOG'
&gt;&gt;&gt; s.cost()
49010.0
&gt;&gt;&gt;
</code></pre>
<p>Este esquema de búsqueda es cómo los miembros de una clase son compartidos por todas las instancias.</p>
<h3 id="519-como-funciona-la-herencia">5.1.9 Cómo funciona la herencia</h3>
<p>Las clases pueden heredar de otras clases.</p>
<pre><code class="language-python">class A(B, C):
    ...
</code></pre>
<p>Las clases base se almacenan en una tupla en cada clase.</p>
<pre><code class="language-python">&gt;&gt;&gt; A.__bases__
(&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;)
&gt;&gt;&gt;
</code></pre>
<p>Esto proporciona un enlace a las clases padres.</p>
<h3 id="5110-lectura-de-atributos-con-herencia">5.1.10 Lectura de atributos con herencia</h3>
<p>Lógicamente, el proceso de búsqueda de un atributo es el siguiente. Primero, verifique en local <code>__dict__</code>. Si no lo encuentra, busque en el <code>__dict__</code> de la clase. Si no se encuentra en la clase, busque en las clases base a través de <code>__bases__</code>. Sin embargo, hay algunos aspectos sutiles de esto que se comentan a continuación.</p>
<h3 id="5111-lectura-de-atributos-con-herencia-unica">5.1.11 Lectura de atributos con herencia única</h3>
<p>En las jerarquías de herencia, los atributos se encuentran subiendo por el árbol de herencia en orden.</p>
<pre><code class="language-python">class A: pass
class B(A): pass
class C(A): pass
class D(B): pass
class E(D): pass
</code></pre>
<p>Con herencia única, hay un camino único a la cima.</p>
<h3 id="5112-orden-de-resolucion-de-metodos-o-mro">5.1.12 Orden de resolución de métodos o MRO</h3>
<p>Python calcula previamente una cadena de herencia y la almacena en el atributo MRO de la clase. Puedes verlo.</p>
<pre><code class="language-python">&gt;&gt;&gt; E.__mro__
(&lt;class '__main__.E'&gt;, &lt;class '__main__.D'&gt;,
 &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;,
 &lt;type 'object'&gt;)
&gt;&gt;&gt;
</code></pre>
<p>Esta cadena se denomina Orden de resolución de métodos . Para encontrar un atributo, Python recorre el MRO en orden.</p>
<h3 id="5113-mro-en-herencia-multiple">5.1.13 MRO en herencia múltiple</h3>
<p>Con la herencia múltiple, no hay un camino único hacia la cima.</p>
<p>Un ejemplo:</p>
<pre><code class="language-python">class A: pass
class B: pass
class C(A, B): pass
class D(B): pass
class E(C, D): pass
</code></pre>
<p>¿Qué sucede cuando accedes a un atributo?</p>
<pre><code class="language-python">e = E()
e.attr
</code></pre>
<p>Se realiza un proceso de búsqueda de atributos, pero ¿cuál es el orden? Eso es un problema.</p>
<p>Python usa herencia múltiple cooperativa que obedece a algunas reglas sobre el orden de clases.</p>
<ul>
<li>Los niños siempre son controlados antes que los padres</li>
<li>Los padres (si son múltiples) siempre se marcan en el orden indicado.</li>
</ul>
<p>El MRO se calcula ordenando todas las clases en una jerarquía de acuerdo con esas reglas.</p>
<pre><code class="language-python">&gt;&gt;&gt; E.__mro__
(
    &lt;class 'E'&gt;,
    &lt;class 'C'&gt;,
    &lt;class 'A'&gt;,
    &lt;class 'D'&gt;,
    &lt;class 'B'&gt;,
    &lt;class 'object'&gt;)
&gt;&gt;&gt;
</code></pre>
<p>El algoritmo subyacente se denomina "Algoritmo de linealización C3". Los detalles precisos no son importantes siempre que recuerde que una jerarquía de clases obedece las mismas reglas de ordenamiento que podría seguir si su casa se incendiara y tuviera que evacuar: los niños primero, seguidos de los padres.</p>
<h3 id="5114-una-reutilizacion-de-codigo-extrano-que-implica-herencia-multiple">5.1.14 Una reutilización de código extraño (que implica herencia múltiple)</h3>
<p>Considere dos objetos completamente no relacionados:</p>
<pre><code class="language-python">class Dog:
    def noise(self):
        return 'Bark'

    def chase(self):
        return 'Chasing!'

class LoudDog(Dog):
    def noise(self):
        # Codigo comun a LoudDog (abajo)
        return super().noise().upper()
</code></pre>
<p>Y</p>
<pre><code class="language-python">class Bike:
    def noise(self):
        return 'On Your Left'

    def pedal(self):
        return 'Pedaling!'

class LoudBike(Bike):
    def noise(self):
        # Codigo comun a LoudDog (arriba)
        return super().noise().upper()
</code></pre>
<p>Hay un código común en la implementación de <code>LoudDog.noise()</code> y <code>LoudBike.noise()</code>. De hecho, el código es exactamente el mismo. Naturalmente, un código como ese seguramente atraerá a los ingenieros de software.</p>
<h3 id="5115-el-patron-mixin">5.1.15 El patrón "Mixin"</h3>
<p>El patrón Mixin es una clase con un fragmento de código.</p>
<pre><code class="language-python">class Loud:
    def noise(self):
        return super().noise().upper()
</code></pre>
<p>Esta clase no se puede utilizar de forma aislada. Se mezcla con otras clases por herencia.</p>
<pre><code class="language-python">class LoudDog(Loud, Dog):
    pass

class LoudBike(Loud, Bike):
    pass
</code></pre>
<p>Milagrosamente, el altavoz ahora se implementó solo una vez y se reutilizó en dos clases completamente no relacionadas. Este tipo de truco es uno de los usos principales de la herencia múltiple en Python.</p>
<h3 id="5116-por-que-super">5.1.16 Por qué super()</h3>
<p>Use super() siempre que esta sobreescribiendo métodos.</p>
<pre><code class="language-python">class Loud:
    def noise(self):
        return super().noise().upper()
</code></pre>
<p><code>super()</code> delegates to the next class on the MRO.</p>
<p>El truco es que no sabes qué es. En especial, no sabe qué es si se utiliza la herencia múltiple.</p>
<h3 id="5117-algunas-precauciones">5.1.17 Algunas precauciones</h3>
<p>La herencia múltiple es una herramienta poderosa. Recuerde que con el poder viene la responsabilidad. Los marcos de desarrollo / bibliotecas / librerias / modulos a veces lo usan para funciones avanzadas que involucran la composición de componentes. Ok, ahora puedes olvidarte de que lo leíste.</p>
<h3 id="5118-ejercicios">5.1.18 Ejercicios</h3>
<p>En la Sección 4, definió una clase <code>Stock</code> que representaba una tenencia de acciones. En este ejercicio usaremos esa clase. Reinicie el intérprete y realice algunas instancias:</p>
<pre><code class="language-python">&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; from stock import Stock
&gt;&gt;&gt; goog = Stock('GOOG',100,490.10)
&gt;&gt;&gt; ibm  = Stock('IBM',50, 91.23)
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-51-representacion-de-instancias">Ejercicio 5.1: Representación de instancias</h4>
<p>En el shell interactivo, inspeccione los diccionarios subyacentes de las dos instancias que creó:</p>
<pre><code class="language-python">

&gt;&gt;&gt; goog.__dict__
... mire la salida ...
&gt;&gt;&gt; ibm.__dict__
... mire la salida ...
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-52-modificacion-de-datos-de-instancia">Ejercicio 5.2: Modificación de datos de instancia</h4>
<p>Intente establecer un nuevo atributo en una de las instancias anteriores:</p>
<pre><code class="language-python">&gt;&gt;&gt; goog.date = '6/11/2007'
&gt;&gt;&gt; goog.__dict__
... mire la salida ...
&gt;&gt;&gt; ibm.__dict__
... mire la salida ...
&gt;&gt;&gt;
</code></pre>
<p>En el resultado anterior, notará que la instancia <code>goog</code> tiene un atributo, <code>date</code>, mientras que la instancia <code>ibm</code> no. Es importante tener en cuenta que Python realmente no impone restricciones a los atributos. Por ejemplo, los atributos de una instancia no se limitan a los configurados en el método <code>__init__()</code>.</p>
<p>En lugar de establecer un atributo, intente colocar un nuevo valor directamente en el objeto <code>__dict__</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; goog.__dict__['time'] = '9:45am'
&gt;&gt;&gt; goog.time
'9:45am'
&gt;&gt;&gt;
</code></pre>
<p>Aquí, realmente se nota el hecho de que una instancia es solo una capa sobre un diccionario. Nota: vale destacar que la manipulación directa del diccionario es poco común; siempre debe escribir su código para usar la sintaxis (.).</p>
<h4 id="ejercicio-53-el-papel-de-las-clases">Ejercicio 5.3: El papel de las clases</h4>
<p>Las definiciones que componen una definición de clase son compartidas por todas las instancias de esa clase. Tenga en cuenta que todas las instancias tienen un enlace a su clase asociada:</p>
<pre><code class="language-python">&gt;&gt;&gt; goog.__class__
... mire la salida ...
&gt;&gt;&gt; ibm.__class__
... mire la salida ...
&gt;&gt;&gt;
</code></pre>
<p>Intente llamar a un método en las instancias:</p>
<pre><code class="language-python">&gt;&gt;&gt; goog.cost()
49010.0
&gt;&gt;&gt; ibm.cost()
4561.5
&gt;&gt;&gt;
</code></pre>
<p>Tenga en cuenta que el nombre de 'costo' no se define en cualquier <code>goog.__dict__</code> o <code>ibm.__dict__</code>. En cambio, lo proporciona el diccionario de la clase. Prueba esto:</p>
<pre><code class="language-python">&gt;&gt;&gt; Stock.__dict__['cost']
... mire la salida ...
&gt;&gt;&gt;
</code></pre>
<p>Intente llamar al método <code>cost()</code> directamente a través del diccionario:</p>
<pre><code class="language-python">&gt;&gt;&gt; Stock.__dict__['cost'](goog)
49010.0
&gt;&gt;&gt; Stock.__dict__['cost'](ibm)
4561.5
&gt;&gt;&gt;
</code></pre>
<p>Observe cómo está llamando a la función definida en la definición de clase y cómo el argumento <code>self</code> obtiene la instancia.</p>
<p>Intente agregar un nuevo atributo a la clase <code>Stock</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; Stock.foo = 42
&gt;&gt;&gt;
</code></pre>
<p>Observe cómo este nuevo atributo ahora aparece en todas las instancias:</p>
<pre><code class="language-python">&gt;&gt;&gt; goog.foo
42
&gt;&gt;&gt; ibm.foo
42
&gt;&gt;&gt;
</code></pre>
<p>Sin embargo, tenga en cuenta que no forma parte del diccionario de la instancia:</p>
<pre><code class="language-python">&gt;&gt;&gt; goog.__dict__
... mire la salida y verifique que no hay atributo 'foo' ...
&gt;&gt;&gt;
</code></pre>
<p>La razón por la que puede acceder al atributo <code>foo</code> en las instancias es que Python siempre verifica el diccionario de la clase si no puede encontrar algo en la propia instancia.</p>
<p>Nota: Esta parte del ejercicio ilustra algo conocido como variable de clase. Supongamos, por ejemplo, que tiene una clase como esta:</p>
<pre><code class="language-python">class Foo(object):
     a = 13                 # variable de Clase
     def __init__(self,b):
        self.b = b          # variable de Instancia
</code></pre>
<p>En esta clase, la variable <code>a</code>, asignada en el cuerpo de la propia clase, es una "variable de clase". Lo comparten todas las instancias que se crean. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; f = Foo(10)
&gt;&gt;&gt; g = Foo(20)
&gt;&gt;&gt; f.a
13
&gt;&gt;&gt; g.a
13
&gt;&gt;&gt; f.b          # Inspeccione la variable de instancia (difiere)
10
&gt;&gt;&gt; g.b
20
&gt;&gt;&gt; Foo.a = 42   # Change the value of the class variable
&gt;&gt;&gt; f.a
42
&gt;&gt;&gt; g.a
42
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-54-metodos-vinculados">Ejercicio 5.4: Métodos vinculados</h4>
<p>Una característica sutil de Python es que la invocación de un método en realidad implica dos pasos y algo conocido como método vinculado. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = goog.sell
&gt;&gt;&gt; s
&lt;bound method Stock.sell of Stock('GOOG', 100, 490.1)&gt;
&gt;&gt;&gt; s(25)
&gt;&gt;&gt; goog.shares
75
&gt;&gt;&gt;
</code></pre>
<p>Los métodos vinculados en realidad contienen todas las piezas necesarias para llamar a un método. Por ejemplo, mantienen un registro de la función que implementa el método:</p>
<pre><code class="language-python">&gt;&gt;&gt; s.__func__
&lt;function sell at 0x10049af50&gt;
&gt;&gt;&gt;
</code></pre>
<p>Este es el mismo valor que se encuentra en el diccionario <code>Stock</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; Stock.__dict__['sell']
&lt;function sell at 0x10049af50&gt;
&gt;&gt;&gt;
</code></pre>
<p>Los métodos enlazados también registran la instancia, que es el selfargumento.</p>
<pre><code class="language-python">&gt;&gt;&gt; s.__self__
Stock('GOOG',75,490.1)
&gt;&gt;&gt;
</code></pre>
<p>Cuando se invoca la función utilizando ()todas las piezas se unen. Por ejemplo, llamar s(25)realmente hace esto:</p>
<pre><code class="language-python">&gt;&gt;&gt; s.__func__(s.__self__, 25)    # Same as s(25) &gt;&gt;&gt; goog.shares
50
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-55-herencia">Ejercicio 5.5: Herencia</h4>
<p>Crea una nueva clase que herede de <code>Stock</code>s.</p>
<pre><code class="language-python">&gt;&gt;&gt; class NewStock(Stock):
...     def yow(self):
...         print('Yow!')
...
&gt;&gt;&gt; n = NewStock('ACME', 50, 123.45)
&gt;&gt;&gt; n.cost()
6172.50
&gt;&gt;&gt; n.yow()
Yow!
&gt;&gt;&gt;
</code></pre>
<p>La herencia se implementa ampliando el proceso de búsqueda de atributos. El atributo  <code>__bases__</code> tiene una tupla de los padres inmediatos:</p>
<pre><code class="language-python">&gt;&gt;&gt; NewStock.__bases__
(&lt;class 'stock.Stock'&gt;,)
&gt;&gt;&gt;
</code></pre>
<p>El atributo <code>__mro__</code> tiene una tupla de todos los padres, en el orden en que se buscarán los atributos.</p>
<pre><code class="language-python">&gt;&gt;&gt; NewStock.__mro__
(&lt;class '__main__.NewStock'&gt;, &lt;class 'stock.Stock'&gt;, &lt;class 'object'&gt;) &gt;&gt;&gt;
</code></pre>
<p>Así es como se encontraría el método <code>cost()</code> de la instancia anterior:</p>
<pre><code class="language-python">&gt;&gt;&gt; for cls in n.__class__.__mro__:
...     if 'cost' in cls.__dict__:
...         break
...
&gt;&gt;&gt; cls
&lt;class '__main__.Stock'&gt;
&gt;&gt;&gt; cls.__dict__['cost']
&lt;function cost at 0x101aed598&gt;
&gt;&gt;&gt;
</code></pre>
<h2 id="52-clases-y-encapsulacion">5.2 Clases y encapsulación</h2>
<p>Al escribir clases, es común intentar encapsular detalles internos.
Esta sección presenta algunos modismos de programación de Python para esto, incluyendo
propiedades y variables privadas.</p>
<h3 id="521-publico-vs-privado">5.2.1 Público vs Privado</h3>
<p>Uno de los roles principales de una clase es encapsular datos y
detalles de implementación de un objeto. Sin embargo, una clase también define un
Interfaz * pública * que se supone que el mundo exterior debe usar para
manipular el objeto. Esta distinción entre implementación
Los detalles y la interfaz pública son importantes.</p>
<h3 id="522-un-problema">5.2.2 Un problema</h3>
<p>En Python, casi todo lo relacionado con clases y objetos es <em>abierto</em>.</p>
<ul>
<li>Puede inspeccionar fácilmente el interior de los objetos.</li>
<li>Puedes cambiar las cosas a su antojo.</li>
<li>No existe una noción fuerte de control de acceso (es decir, miembros de clases privadas)</li>
</ul>
<p>Esto es un problema cuando intenta aislar detalles de la <em>implementación interna</em>.</p>
<h3 id="523-encapsulacion-de-python">5.2.3 Encapsulación de Python</h3>
<p>Python se basa en convenciones de programación para indicar el uso previsto
de algo. Estas convenciones se basan en la denominación o nombramiento.
El lenguaje no impone ciertas reglas, sino que le delega esa responsabilidad
al programador. El programador debe observar y cumplir ciertas reglas,
sin que el lenguaje lo obligue hacerlo. En ese sentido, Python se distingue de
otros lenguajes de programación que tienen reglas estrictas sobre lo que es
público y lo que es privado.</p>
<h3 id="524-atributos-privados">5.2.4 Atributos privados</h3>
<p>Cualquier nombre de atributo con "_" inicial se considera <em>privado</em>.</p>
<pre><code class="language-python">clase Persona (objeto):
    def __init__ (self, nombre):
        self._name = 0
</code></pre>
<p>Como se mencionó anteriormente, este es solo un estilo de programación. Todavia puede
acceder y modificarlo.</p>
<pre><code class="language-python">&gt;&gt;&gt; p = Persona('Guido')
&gt;&gt;&gt; p._name
'Guido'
&gt;&gt;&gt; p._name = 'Dave'
&gt;&gt;&gt;
</code></pre>
<p>Como regla general, cualquier nombre con un "_" inicial se considera implementación interna
ya sea una variable, una función o un nombre de módulo. Si se encuentra usando tales
nombres directamente, probablemente esté haciendo algo mal. Busque una funcionalidad de nivel superior.</p>
<h3 id="525-atributos-simples">5.2.5 Atributos simples</h3>
<p>Considere la siguiente clase.</p>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
</code></pre>
<p>Una característica sorprendente es que puede establecer los atributos en cualquier valor:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('IBM', 50, 91.1)
&gt;&gt;&gt; s.shares = 100
&gt;&gt;&gt; s.shares = &quot;hundred&quot;
&gt;&gt;&gt; s.shares = [1, 0, 0]
&gt;&gt;&gt;
</code></pre>
<p>Puede mirar eso y pensar que quiere algunas verificaciones adicionales.</p>
<pre><code class="language-python">s.shares = '50'     # Alza un TypeError, esto es una cadena
</code></pre>
<p>¿Como lo harias?</p>
<h3 id="526-atributos-gestionados">5.2.6 Atributos gestionados</h3>
<p>Un enfoque: introducir métodos de acceso.</p>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.set_shares(shares)
        self.price = price

    # Metodo que encapa la operación de acceso al atributo (get)
    def get_shares(self):
        return self._shares

    # Metodo que encapa la operacion de definición del atributo (set)
    def set_shares(self, value):
        if not isinstance(value, int):
            raise TypeError('Esperaba un int')
        self._shares = value
</code></pre>
<p>Lástima que esto rompa todo nuestro código existente. <code>s.shares = 50</code> se convierte en <code>s.set_shares(50)</code></p>
<h3 id="527-propiedades">5.2.7 Propiedades</h3>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    @property
    def shares(self):
        return self._shares

    @shares.setter
    def shares(self, value):
        if not isinstance(value, int):
            raise TypeError('Expected int')
        self._shares = value
</code></pre>
<p>El acceso normal a los atributos ahora activa los métodos getter y setter en @propertyy @shares.setter.</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('IBM', 50, 91.1)
&gt;&gt;&gt; s.shares         # Provoca @property
50
&gt;&gt;&gt; s.shares = 75    # Prooca @shares.setter
&gt;&gt;&gt;
</code></pre>
<p>Con este patrón, no se necesitan cambios en el código fuente. El nuevo setter también se llama cuando hay una asignación dentro de la clase, incluyendo en el interior del <code>__init__()</code> método.</p>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        ...
        # La asignación usa el método setter de abajo
        self.shares = shares
        ...

    ...
    @shares.setter
    def shares(self, value):
        if not isinstance(value, int):
            raise TypeError('Expected int')
        self._shares = value
</code></pre>
<p>A menudo existe una confusión entre una propiedad y el uso de nombres privados. Aunque una propiedad usa internamente un nombre privado como <code>_shares</code>, el resto de la clase (no la propiedad) puede continuar usando un nombre como <code>shares</code>.</p>
<p>Las propiedades también son útiles para los atributos de datos calculados.</p>
<pre><code class="language-python">class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    @property
    def cost(self):
        return self.shares * self.price
    ...
</code></pre>
<p>Esto le permite eliminar los paréntesis adicionales, ocultando el hecho de que en realidad es un método:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; s.shares # Instance variable 100
&gt;&gt;&gt; s.cost   # Computed Value 49010.0
&gt;&gt;&gt;
</code></pre>
<h3 id="528-acceso-uniforme">5.2.8 Acceso uniforme</h3>
<p>El último ejemplo muestra cómo poner una interfaz más uniforme en un objeto. Si no hace esto, un objeto puede resultar confuso de usar:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; a = s.cost() # Method
49010.0
&gt;&gt;&gt; b = s.shares # Data attribute
100
&gt;&gt;&gt;
</code></pre>
<p>¿Por qué se requiere <code>()</code> para el costo, pero no para las acciones? Una propiedad puede arreglar esto.</p>
<h3 id="529-sintaxis-del-decorador">5.2.9 Sintaxis del decorador</h3>
<p>La sintaxis <code>@</code> se conoce como "decoración". Especifica un modificador que se aplica a la definición de función que sigue inmediatamente.</p>
<pre><code class="language-python">...
@property
def cost(self):
    return self.shares * self.price
</code></pre>
<p>More details are given in Section 7.</p>
<h3 id="5210-slots-atributo">5.2.10 <strong>slots</strong> Atributo</h3>
<p>Puede restringir el conjunto de nombres de atributos.</p>
<pre><code class="language-python">class Stock:
    __slots__ = ('name','_shares','price')
    def __init__(self, name, shares, price):
        self.name = name
        ...
</code></pre>
<p>Generará un error para otros atributos.</p>
<pre><code class="language-python">&gt;&gt;&gt; s.price = 385.15
&gt;&gt;&gt; s.prices = 410.2
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in ?
AttributeError: 'Stock' object has no attribute 'prices'
</code></pre>
<p>Aunque esto evita errores y restringe el uso de objetos, en realidad se usa para el rendimiento y hace que Python use la memoria de manera más eficiente.</p>
<h3 id="5211-comentarios-finales-sobre-encapsulacion">5.2.11 Comentarios finales sobre encapsulación</h3>
<p>No se exceda con atributos privados, propiedades, espacios, etc. Sirven para un propósito específico y es posible que los vea al leer otro código de Python. Sin embargo, no son necesarios para la mayor parte de la codificación diaria.</p>
<h3 id="5212-ejercicios">5.2.12 Ejercicios</h3>
<h4 id="ejercicio-56-propiedades-simples">Ejercicio 5.6: Propiedades simples</h4>
<p>Las propiedades son una forma útil de agregar "atributos calculados" a un objeto. En <code>stock.py</code>, creaste un objeto Stock. Observe que en su objeto hay una ligera inconsistencia en cómo se extraen los diferentes tipos de datos:</p>
<pre><code class="language-python">&gt;&gt;&gt; from stock import Stock
&gt;&gt;&gt; s = Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; s.shares
100
&gt;&gt;&gt; s.price
490.1
&gt;&gt;&gt; s.cost()
49010.0
&gt;&gt;&gt;
</code></pre>
<p>Específicamente, observe cómo tiene que agregar extra <code>()</code> a <code>cost</code> porque es un método.</p>
<p>Puede deshacerse del extra <code>()</code> en <code>cost()</code> si lo convierte en una propiedad. Tome su clase <code>Stock</code> y modifíquela para que el cálculo del costo funcione así:</p>
<pre><code class="language-python">&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; from stock import Stock
&gt;&gt;&gt; s = Stock('GOOG', 100, 490.1)
&gt;&gt;&gt; s.cost
49010.0
&gt;&gt;&gt;
</code></pre>
<p>Intente llamar <code>s.cost()</code> como una función y observe que no funciona ahora que cost se ha definido como una propiedad.</p>
<pre><code class="language-python">&gt;&gt;&gt; s.cost()
... fracasa ...
&gt;&gt;&gt;
</code></pre>
<p>Hacer este cambio probablemente romperá su programa <code>pcost.py</code> anterior . Es posible que deba volver atrás y deshacerse del método <code>()</code> en <code>cost()</code>.</p>
<h4 id="ejercicio-57-propiedades-y-establecedores">Ejercicio 5.7: Propiedades y establecedores</h4>
<p>Modifique el atributo shares para que el valor se almacene en un atributo privado y que se utilicen un par de funciones de propiedad para garantizar que siempre se establezca en un valor entero. A continuación, se muestra un ejemplo del comportamiento esperado:</p>
<pre><code class="language-python">&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; from stock import Stock
&gt;&gt;&gt; s = Stock('GOOG',100,490.10)
&gt;&gt;&gt; s.shares = 50
&gt;&gt;&gt; s.shares = 'a lot'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: expected an integer
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-58-agregar-ranuras">Ejercicio 5.8: Agregar ranuras</h4>
<p>Modifique la clase <code>Stock</code> para que tenga un atributo <code>__slots__</code>. Luego, verifique que no se puedan agregar nuevos atributos:</p>
<pre><code class="language-python">&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt; from stock import Stock
&gt;&gt;&gt; s = Stock('GOOG', 100, 490.10)
&gt;&gt;&gt; s.name
'GOOG'
&gt;&gt;&gt; s.blah = 42
... mire lo que sucede ...
&gt;&gt;&gt;
</code></pre>
<p>Cuando lo usa <code>__slots__</code>, Python usa una representación interna de objetos más eficiente. ¿Qué sucede si intenta inspeccionar el diccionario subyacente de <code>s</code> arriba?</p>
<pre><code class="language-python">&gt;&gt;&gt; s.__dict__
... mire lo que sucede ...
&gt;&gt;&gt;
</code></pre>
<p>Cabe señalar que <code>__slots__</code> se usa más comúnmente como optimización en clases que sirven como estructuras de datos. El uso de ranuras hará que dichos programas usen mucha menos memoria y se ejecuten un poco más rápido. Sin embargo , probablemente debería evitar el uso de <code>__slots__</code> en la mayoría de las otras clases.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../6/" class="btn btn-neutral float-right" title="6 Generadores">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../4/" class="btn btn-neutral" title="4 Clases y Objetos"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../4/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../6/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
