{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Pr\u00e1ctico Python Pr\u00e1ctico es un curso de introducci\u00f3n a Python a trav\u00e9s del enfoque general de manipulaci\u00f3n de datos. Se abordan los temas desde un punto de vista pr\u00e1ctico y pragm\u00e1tico. Vale destacar que este no es un curso de desarrollo web o para ingenieros de software sobre como escribir o darle mantenimiento a una aplicaci\u00f3n Python de un mill\u00f3n de l\u00edneas de c\u00f3digo. Requisitos del curso Para completar el curso, se necesita: * Instalaci\u00f3n de Python versi\u00f3n 3.6+ * Determinaci\u00f3n para terminar el curso * Paciencia para comprender y hacer los ejercicios * Alrededor de 25-35 horas para leer, estudiar y completar alrededor de 130 ejercicios de programaci\u00f3n Autor y licencia El curso fue originalmente publicado en ingl\u00e9s por David Beazley. Ha sido adaptado al espa\u00f1ol por Adriaan Beiertz , para la comunidad Python Panama. Se comparte gratuitamente bajo el marco de la siguiente licencia: Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0) .","title":"Sobre el curso"},{"location":"#python-practico","text":"Python Pr\u00e1ctico es un curso de introducci\u00f3n a Python a trav\u00e9s del enfoque general de manipulaci\u00f3n de datos. Se abordan los temas desde un punto de vista pr\u00e1ctico y pragm\u00e1tico. Vale destacar que este no es un curso de desarrollo web o para ingenieros de software sobre como escribir o darle mantenimiento a una aplicaci\u00f3n Python de un mill\u00f3n de l\u00edneas de c\u00f3digo.","title":"Python Pr\u00e1ctico"},{"location":"#requisitos-del-curso","text":"Para completar el curso, se necesita: * Instalaci\u00f3n de Python versi\u00f3n 3.6+ * Determinaci\u00f3n para terminar el curso * Paciencia para comprender y hacer los ejercicios * Alrededor de 25-35 horas para leer, estudiar y completar alrededor de 130 ejercicios de programaci\u00f3n","title":"Requisitos del curso"},{"location":"#autor-y-licencia","text":"El curso fue originalmente publicado en ingl\u00e9s por David Beazley. Ha sido adaptado al espa\u00f1ol por Adriaan Beiertz , para la comunidad Python Panama. Se comparte gratuitamente bajo el marco de la siguiente licencia: Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0) .","title":"Autor y licencia"},{"location":"0/","text":"Empiece aqu\u00ed El curso fue originalmente dise\u00f1ado para que todo lo haga desde su ordenador. Sin embargo, hemos puesto a su disposici\u00f3n en la plataforma Repl.it un editor, consola Python, terminal Linux y los archivos correspondiente a cada secci\u00f3n, a fin de que pueda escribir y ejecutar c\u00f3digo en su navegador. Por tanto, sugerimos crear una cuenta en esta plataforma, a fin de que pueda guardar su trabajo y compartir el enlace cuando necesite ayuda. Si el curso lo har\u00e1 desde su ordenador, tendr\u00e1 que descargar los archivos de trabajo necesarios para completar el curso, aqu\u00ed . Adem\u00e1s, hemos adjuntado las soluciones aqu\u00ed . Contenido El enlace a la plataforma interactiva Repl.it con los archivos de la secci\u00f3n correspondiente siempre se encontrar\u00e1n al inicio del contenido de la secci\u00f3n y al inicio de los ejercicios de cada secci\u00f3n. Usted lee el contenido primero e ingresa las instrucciones Python en la Consola mientras va leyendo. Ejercicios Cuando termine con el contenido.md , deber\u00e1 continuar con el archivo ejercicios.md . Shell En muchas ocasiones, usted har\u00e1 uso de la Consola Python; no obstante, cuando tenga que escribir en un archivo, primero busque el archivo y escriba su c\u00f3digo ah\u00ed. Cuando tenga que ejecutarlo, tendr\u00e1 que acceder al Shell , como puede ver a continuaci\u00f3n. Por ejemplo, si tiene un archivo que se llama hipoteca.py tendr\u00e1 que ejecutar $ python hipoteca.py y pulsar Enter. Archivos nuevos Usted tambi\u00e9n puede crear archivos nuevos. Copiar el repositorio Para que usted tenga una copia propia de su trabajo, tiene que hacer un Fork . Compartir En algunas ocasiones tendr\u00e1 que compartirle el repositorio a alguien, especialmente cuando necesite ayuda. Por tanto, simplemente copie el enlace despu\u00e9s de haberle hecho un Fork . Comunidad Es importante aprender en p\u00fablico e interactuar con otras personas. En ese sentido, Python Panam\u00e1 ha puesto a disposici\u00f3n su servidor en Discord, donde el curso tiene su propia categor\u00eda organizado por canales, a fin de tener una conversaci\u00f3n ordenada. Aqu\u00ed podr\u00e1 encontrar a otros Pythonistas que estan tomando este curso o que puedan ayudarles con alguna pregunta. Puede acceder al servidor de Discord de Python Panama aqui .","title":"0 Empiece aqui"},{"location":"0/#empiece-aqui","text":"El curso fue originalmente dise\u00f1ado para que todo lo haga desde su ordenador. Sin embargo, hemos puesto a su disposici\u00f3n en la plataforma Repl.it un editor, consola Python, terminal Linux y los archivos correspondiente a cada secci\u00f3n, a fin de que pueda escribir y ejecutar c\u00f3digo en su navegador. Por tanto, sugerimos crear una cuenta en esta plataforma, a fin de que pueda guardar su trabajo y compartir el enlace cuando necesite ayuda. Si el curso lo har\u00e1 desde su ordenador, tendr\u00e1 que descargar los archivos de trabajo necesarios para completar el curso, aqu\u00ed . Adem\u00e1s, hemos adjuntado las soluciones aqu\u00ed .","title":"Empiece aqu\u00ed"},{"location":"0/#contenido","text":"El enlace a la plataforma interactiva Repl.it con los archivos de la secci\u00f3n correspondiente siempre se encontrar\u00e1n al inicio del contenido de la secci\u00f3n y al inicio de los ejercicios de cada secci\u00f3n. Usted lee el contenido primero e ingresa las instrucciones Python en la Consola mientras va leyendo.","title":"Contenido"},{"location":"0/#ejercicios","text":"Cuando termine con el contenido.md , deber\u00e1 continuar con el archivo ejercicios.md .","title":"Ejercicios"},{"location":"0/#shell","text":"En muchas ocasiones, usted har\u00e1 uso de la Consola Python; no obstante, cuando tenga que escribir en un archivo, primero busque el archivo y escriba su c\u00f3digo ah\u00ed. Cuando tenga que ejecutarlo, tendr\u00e1 que acceder al Shell , como puede ver a continuaci\u00f3n. Por ejemplo, si tiene un archivo que se llama hipoteca.py tendr\u00e1 que ejecutar $ python hipoteca.py y pulsar Enter.","title":"Shell"},{"location":"0/#archivos-nuevos","text":"Usted tambi\u00e9n puede crear archivos nuevos.","title":"Archivos nuevos"},{"location":"0/#copiar-el-repositorio","text":"Para que usted tenga una copia propia de su trabajo, tiene que hacer un Fork .","title":"Copiar el repositorio"},{"location":"0/#compartir","text":"En algunas ocasiones tendr\u00e1 que compartirle el repositorio a alguien, especialmente cuando necesite ayuda. Por tanto, simplemente copie el enlace despu\u00e9s de haberle hecho un Fork .","title":"Compartir"},{"location":"0/#comunidad","text":"Es importante aprender en p\u00fablico e interactuar con otras personas. En ese sentido, Python Panam\u00e1 ha puesto a disposici\u00f3n su servidor en Discord, donde el curso tiene su propia categor\u00eda organizado por canales, a fin de tener una conversaci\u00f3n ordenada. Aqu\u00ed podr\u00e1 encontrar a otros Pythonistas que estan tomando este curso o que puedan ayudarles con alguna pregunta. Puede acceder al servidor de Discord de Python Panama aqui .","title":"Comunidad"},{"location":"1/","text":"1. Intro a Python 1.1 Introduciendo Python El objetivo de este cap\u00edtulo es introducir las bases de Python. Iniciaremos desde cero y aprenderemos a editar, ejecutar, y depurar programas. Adem\u00e1s, escribiremos una secuencia de comandos que lee data en un archivo CSV y ejecuta un c\u00e1lculo. 1.1.1: Qu\u00e9 es Python? Python es un lenguaje interpretado de programaci\u00f3n de alto nivel. A menudo se le clasifica como un lenguaje de secuencias de comandos y tambi\u00e9n se le considera similar a lenguajes como Perl, Tcl o Ruby. La sintaxis de Python est\u00e1 vagamente inspirada en elementos de la programaci\u00f3n C. Python fue creado por Guido van Rossum alrededor de 1990, quien lo nombr\u00f3 en honor a la comedia de origen brit\u00e1nico Monty Python . 1.1.2: Donde consigo Python? Puedes obtener una versi\u00f3n de Python en Python.org . Para los prop\u00f3sitos de este curso, solo necesitas una instalaci\u00f3n b\u00e1sica. Recomiendo instalar Python 3.6 o una versi\u00f3n m\u00e1s reciente. Python 3.6 es el que se usa en las notas y en las soluciones, sin embargo puedes utilizar cualquier versi\u00f3n. 1.1.3: Porqu\u00e9 fue creado? En palabras del creador de Python: Mi motivaci\u00f3n original para crear Python fue la necesidad percibida de un lenguaje de alto nivel en el proyecto Amoeba [Sistemas Operativos]. Me di cuenta de que el desarrollo de las utilidades de administraci\u00f3n del sistema en C estaban tardando demasiado. Adem\u00e1s, hacer estas cosas en el shell Bourne no iba a funcionar por una variedad de razones. ... Entonces, era necesario un lenguaje que cerrara la brecha entre C y el shell. Guido van Rossum 1.1.4: D\u00f3nde est\u00e1 Python en mi Maquina? Aunque hay muchos entornos en los que puede ejecutar Python, Python normalmente se instala en su m\u00e1quina como un programa que se ejecuta desde la terminal o el shell de comandos. Desde la terminal, deber\u00eda poder escribir python as\u00ed: $ python Python 3.8.1 (default, Feb 20 2020, 09:29:22) [Clang 10.0.0 (clang-1000.10.44.4)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> print(\"hello world\") hello world >>> Aunque hay muchos entornos en donde puede programar en Python, ser\u00e1 un programador m\u00e1s fuerte si puede ejecutar, depurar e interactuar con Python en la terminal. Este es el entorno nativo de Python. Si puede usar Python aqu\u00ed, podr\u00e1 usarlo en cualquier otro lugar. 1.1.5: Ejercicios Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Ejercicio 1.1: Utilizando Python como Calculadora En su m\u00e1quina, inicie Python y util\u00edcelo como calculador para resolver el siguiente problema. El suertudo de Juan compr\u00f3 75 acciones de Google a un precio de $235.14 USD por acci\u00f3n. Hoy, las acciones de Google tienen un precio de $711.25 USD. Usando el modo interactivo de Python como una calculadora, averig\u00fce cu\u00e1ntas ganancias obtendr\u00eda Juan si vendiera todas sus acciones. >>> (711.25 - 235.14) * 75 35708.25 >>> Consejo profesional: use la variable de subrayado ( _ ) para usar el resultado del \u00faltimo c\u00e1lculo. Por ejemplo, \u00bfcu\u00e1ntas ganancias obtiene Juan despu\u00e9s de que su malvado corredor se lleva su parte del 20%? >>> _ * 0.80 28566.600000000002 >>> Ejercicio 1.2: Consiguiendo ayuda Utilice el comando help() para obtener ayuda sobre la funci\u00f3n abs() . Luego use help() para obtener ayuda sobre la funci\u00f3n round() . Escriba help() , asi sin valor alguno, para ingresar al visor de ayuda interactiva. Una advertencia con help() es que no funciona para declaraciones b\u00e1sicas de Python como for, if, while, etc. (es decir, si escribe help(for) obtendr\u00e1 un error de sintaxis). En su lugar, puede intentar poner el tema de la ayuda entre comillas: help('for') . Si eso no funciona, tendr\u00e1 que recurrir a una b\u00fasqueda en Internet. Seguimiento: vaya a http://docs.python.org y busque la documentaci\u00f3n de la funci\u00f3n abs() (pista: se encuentra en la referencia de la biblioteca relacionada con las funciones integradas). Ejercicio 1.3: Copiar y pegar Este curso est\u00e1 estructurado como una serie de p\u00e1ginas en las que se le anima a probar ejemplos interactivos de c\u00f3digo Python escribi\u00e9ndolos a mano. Si est\u00e1 aprendiendo Python por primera vez, se recomienda este \"enfoque lento\". Obtendr\u00e1 una mejor idea del idioma al reducir la velocidad, escribir cosas y pensar en lo que est\u00e1 haciendo. Si debe \"cortar y pegar\" ejemplos de c\u00f3digo, seleccione el c\u00f3digo comenzando despu\u00e9s del indicador >>> y subiendo hasta, pero no m\u00e1s all\u00e1 de la primera l\u00ednea en blanco o el siguiente mensaje >>> (lo que aparezca primero). Seleccione \"copiar\" en el navegador, vaya a la ventana de Python y seleccione \"pegar\" para copiarlo en el shell de Python. Para que el c\u00f3digo se ejecute, es posible que deba presionar \"Retorno\" una vez despu\u00e9s de haberlo pegado. Corte y pegue las siguientes declaraciones de Python: >>> 12 + 20 32 >>> (3 + 4 + 5 + 6) 18 >>> for i in range(5): print(i) 0 1 2 3 4 >>> Advertencia: No es posible pegar m\u00e1s de un comando de Python (declaraciones que aparecen despu\u00e9s de >>> ) en el shell b\u00e1sico de Python a la vez. Tienes que pegar cada comando de uno en uno. Ahora que ha hecho esto, recuerde que sacar\u00e1 m\u00e1s provecho de la clase escribiendo el c\u00f3digo lentamente y pensando en ello, no cortando y pegando. Ejercicio 1.4: Donde esta mi bus? Pruebe algo m\u00e1s avanzado y escriba estas declaraciones para averiguar cu\u00e1nto tiempo tendr\u00e1n que esperar las personas que esperan en la esquina de la calle Clark y Balmoral en Chicago al pr\u00f3ximo autob\u00fas CTA n. \u00b0 22 en direcci\u00f3n norte: >>> import urllib.request >>> u = urllib.request.urlopen('http://ctabustracker.com/bustime/map/getStopPredictions.jsp?stop=14791&route=22') >>> from xml.etree.ElementTree import parse >>> doc = parse(u) >>> for pt in doc.findall('.//pt'): print(pt.text) 6 MIN 18 MIN 28 MIN >>> S\u00ed, acaba de descargar una p\u00e1gina web, analizar un documento XML y extraer informaci\u00f3n \u00fatil en aproximadamente 6 l\u00edneas de c\u00f3digo. Los datos a los que accedi\u00f3 en realidad alimentan el sitio web http://ctabustracker.com/bustime/home.jsp. Int\u00e9ntelo nuevamente y observe c\u00f3mo cambian las predicciones. Si falla la primera declaraci\u00f3n de importaci\u00f3n import urllib.request , probablemente est\u00e9 usando Python 2. Para este curso, debe asegurarse de que est\u00e1 usando Python 3.6 o m\u00e1s reciente. Vaya a https://www.python.org para descargarlo si lo necesita. Si su entorno de trabajo requiere el uso de un servidor proxy HTTP, es posible que deba configurar la variable de entorno HTTP_PROXY para que esta parte del ejercicio funcione. Por ejemplo: >>> import os >>> os.environ['HTTP_PROXY'] = 'http://suproxy.server.com' >>> Si no puede hacer que esto funcione, no se preocupe. El resto de este curso no tiene nada que ver con analizar XML. 1.2 Un primer programa Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 1.2.1: Ejecutando Python Los programas de Python siempre se ejecutan dentro de un int\u00e9rprete. El int\u00e9rprete es una aplicaci\u00f3n \"basada en consola\" que normalmente se ejecuta desde un shell de comandos. python3 Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Los programadores expertos generalmente no tienen problemas para usar el int\u00e9rprete de esta manera, pero no es tan f\u00e1cil de usar para los principiantes. Es posible que est\u00e9 utilizando un entorno que proporciona una interfaz diferente a Python. Eso est\u00e1 bien, pero aprender a ejecutar la terminal de Python sigue siendo una habilidad \u00fatil. 1.2.2: Modo interactivo Cuando inicias Python, obtienes un modo interactivo donde puedes experimentar. Si comienza a escribir declaraciones, se ejecutar\u00e1n de inmediato. No hay ciclo de edici\u00f3n / compilaci\u00f3n / ejecuci\u00f3n / depuraci\u00f3n. >>> print('hello world') hello world >>> 37*42 1554 >>> for i in range(5): ... print(i) ... 0 1 2 3 4 >>> Este llamado ciclo de lectura-evaluaci\u00f3n-impresi\u00f3n (o REPL, por sus siglas en ingl\u00e9s) es muy \u00fatil para depurar y explorar. DETENTE : si no puedes descubrir c\u00f3mo interactuar con Python, detengase y descubra c\u00f3mo hacerlo. Si est\u00e1 utilizando un IDE, es posible que est\u00e9 oculto detr\u00e1s de una opci\u00f3n de men\u00fa u otra ventana. Muchas partes de este curso asumen que puede interactuar con el int\u00e9rprete. Let's take a closer look at the elements of the REPL: >>> es el indicador del int\u00e9rprete para iniciar una nueva declaraci\u00f3n. ... es la indicaci\u00f3n del int\u00e9rprete para continuar una declaraci\u00f3n. Ingrese una l\u00ednea en blanco para terminar de escribir y ejecutar lo que ingres\u00f3. El mensaje ... puede aparecer o no seg\u00fan el entorno. Para este curso, se muestra como espacios en blanco para que sea m\u00e1s f\u00e1cil cortar / pegar muestras de c\u00f3digo. El gui\u00f3n bajo _ contiene el \u00faltimo resultado. >>> 37 * 42 1554 >>> _ * 2 3108 >>> _ + 50 3158 >>> Esto solo es cierto en el modo interactivo. Nunca uses _ en un programa. 1.2.3: Creando programas Los programas se colocan en archivos .py . # hola.py print('hola mundo') Puede crear estos archivos con su editor de texto favorito. 1.2.4: Ejecutando programas Para ejecutar un programa, ejec\u00fatelo en la terminal con el comando python. Por ejemplo, en la l\u00ednea de comandos Unix: $ python hola.py hola mundo $ O desde el shell de Windows: C:\\AlgunDirectorio>hola.py hello world C:\\AlgunDirectorio>c:\\python36\\python hola.py hello world Nota: en Windows, es posible que deba especificar una ruta completa al int\u00e9rprete de Python, como c:\\python36\\python . Sin embargo, si Python se instala de la forma habitual, es posible que pueda simplemente escribir el nombre del programa, como hola.py. 1.2.5: Un ejemplo Resolvamos el siguiente problema: Una ma\u00f1ana, sales y colocas un billete de un d\u00f3lar en la acera de la torre Sears en Chicago. Cada d\u00eda a partir de entonces, sales y colocas el doble de billetes. \u00bfCu\u00e1nto tiempo tarda la pila de billetes en superar la altura de la torre? Una posible soluci\u00f3n: # sears.py billete_grosor = 0.11 * 0.001 # Metros (0.11 mm) sears_altura = 442 # Altura (metros) num_billetes = 1 dia = 1 while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 num_billetes = num_billetes * 2 print('N\u00famero de d\u00edas', dia) print('N\u00famero de facturas', num_billetes) print('Altura final', num_billetes * billete_grosor) Cuando lo ejecuta, obtiene el siguiente resultado: $ python3 sears.py 1 1 0.00011 2 2 0.00022 3 4 0.00044 4 8 0.00088 5 16 0.00176 6 32 0.00352 7 64 0.00704 8 128 0.01408 9 256 0.02816 10 512 0.05632 11 1024 0.11264 12 2048 0.22528 13 4096 0.45056 14 8192 0.90112 15 16384 1.80224 16 32768 3.60448 17 65536 7.20896 18 131072 14.41792 19 262144 28.83584 20 524288 57.67168 21 1048576 115.34336 22 2097152 230.68672 N\u00famero de d\u00edas 23 N\u00famero de facturas 4194304 Altura final 461.37344 Usando este programa como gu\u00eda, puede aprender una serie de conceptos b\u00e1sicos importantes sobre Python. 1.2.6: Declaraciones Un programa de Python es una secuencia de declaraciones: a = 3 + 4 b = a * 2 print(b) Cada declaraci\u00f3n termina con una nueva l\u00ednea. Las sentencias se ejecutan una tras otra hasta que el control llega al final del archivo. 1.2.7: Comentarios Los comentarios son texto que no se ejecutar\u00e1. a = 3 + 4 # Esto es un comentario b = a * 2 print(b) Los comentarios se indican con # y se extienden hasta el final de la l\u00ednea. 1.2.8: Variables Una variable es el nombre de un valor. Puede utilizar letras (min\u00fasculas y may\u00fasculas) de la a a la z, adem\u00e1s del car\u00e1cter subrayado _ . Los n\u00fameros tambi\u00e9n pueden formar parte del nombre de una variable, excepto como primer car\u00e1cter. altura = 442 # v\u00e1lido _height = 442 # v\u00e1lido altura2 = 442 # v\u00e1lido 2height = 442 # inv\u00e1lido 1.2.9: Tipos Las variables no necesitan declararse con el tipo de valor. El tipo est\u00e1 asociado con el valor del lado derecho, no con el nombre de la variable. altura = 442 # Un n\u00famero entero altura = 442.0 # Punto flotante height = 'Muy alto' # Una cadena Python se escribe din\u00e1micamente. El \"tipo\" percibido de una variable puede cambiar a medida que se ejecuta un programa en funci\u00f3n del valor actual que se le asigna. 1.2.10: Casos Sensitivos Python distingue entre may\u00fasculas y min\u00fasculas. Las letras may\u00fasculas y min\u00fasculas se consideran letras diferentes. Todas estas son variables diferentes: nombre = 'Jake' Nombre = 'Elwood' NOMBRE = 'Guido' Las declaraciones de idioma son siempre en min\u00fasculas. while x < 0: # OK WHILE x < 0: # ERROR 1.2.11: Ciclar La instrucci\u00f3n while ejecuta un ciclo. while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 num_billetes = num_billetes * 2 print('Numero de dias', dia) Las declaraciones con sangr\u00eda debajo del while se ejecutar\u00e1n siempre que la expresi\u00f3n posterior al while sea verdadera / cierta. 1.2.12: Sangr\u00edas (las de texto) La sangr\u00eda se usa para denotar grupos de declaraciones que van juntas. Considere el ejemplo anterior: while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 num_billetes = num_billetes * 2 print('Numero de dias', dia) La sangr\u00eda agrupa las siguientes declaraciones juntas como las operaciones que se repiten: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 num_billetes = num_billetes * 2 Debido a que la instrucci\u00f3n print() al final no tiene sangr\u00eda, no pertenece al ciclo. La l\u00ednea vac\u00eda es solo para facilitar la lectura. No afecta la ejecuci\u00f3n. Sangr\u00edas - Mejores pr\u00e1cticas Utilice espacios en lugar de tabulaciones. Utilice 4 espacios por nivel. Utilice un editor compatible con Python. El \u00fanico requisito de Python es que la sangr\u00eda dentro del mismo bloque sea consistente. Por ejemplo, esto es un error: while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 # error num_billetes = num_billetes * 2 1.2.13: Condicionales La instrucci\u00f3n if se usa para ejecutar un condicional: if a > b: print('Computadora dice no') else: print('Computadora dice si') Puede verificar m\u00faltiples condiciones agregando verificaciones adicionales usando elif. if a > b: print('Computadora dice no') elif a == b: print('Computadora dice si') else: print('Computadora dice quizas') 1.2.14: Imprimiendo La funci\u00f3n de impresi\u00f3n produce una sola l\u00ednea de texto con los valores pasados. print('\u00a1Hola mundo!') # Imprime el texto '\u00a1Hola mundo!' Puede utilizar variables. El texto impreso ser\u00e1 el valor de la variable, no el nombre. x = 100 print(x) # Imprime el texto '100' Si pasa m\u00e1s de un valor para imprimir, est\u00e1n separados por espacios. nombre = 'Jake' print('Mi nombre es', nombre) # Imprime el texto 'Mi nombre es Jake' print() siempre pone una nueva l\u00ednea al final. print('Hola') print('Mi nombre es', 'Jake') Esto imprime: shell Hola Mi nombre es Jake La nueva l\u00ednea adicional se puede suprimir: print('Hola', end = '') print('Mi nombre es', 'Jake') Este c\u00f3digo ahora se imprimir\u00e1: Hola mi nombre es Jake 1.2.15: Input (dato de entrada) de usuario Para leer una l\u00ednea de entrada de usuario escrita, use la funci\u00f3n input() : nombre = input('Ingrese su nombre:') print('Tu nombre es', nombre) input imprime un mensaje al usuario y devuelve su respuesta. Esto es \u00fatil para programas peque\u00f1os, ejercicios de aprendizaje o depuraci\u00f3n simple. No se usa mucho para programas reales. 1.2.16: La declaraci\u00f3n \"pass\" Sometimes you need to specify an empty code block. The keyword pass is used for it. if a > b: pass else: print('Computer says false') This is also called a \"no-op\" statement. It does nothing. It serves as a placeholder for statements, possibly to be added later. 1.2.17: Ejercicios Este es el primer conjunto de ejercicios en los que necesita crear archivos Python y ejecutarlos. A partir de este punto, se asume que est\u00e1 editando archivos en el directorio ./Work/ . Para ayudarle a localizar el lugar adecuado, se han creado varios archivos de inicio vac\u00edos con los nombres de archivo adecuados. Busque el archivo ./Work/rebote.py que se utiliz\u00f3 en el primer ejercicio. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Ejercicio 1.5: El rebote Una pelota de goma se deja caer desde una altura de 100 metros y cada vez que golpea el suelo, rebota hasta 3/5 de la altura a la que cay\u00f3. Escriba un programa bounce.py que imprima una tabla que muestre la altura de los primeros 10 rebotes. Su programa deber\u00eda crear una tabla que se parezca a esto: 1 60,0 2 36,0 3 21.599999999999998 4 12.959999999999999 5 7.775999999999999 6 4.6655999999999995 7 2.7993599999999996 8 1,6796159999999998 9 1,0077695999999998 10 0.6046617599999998 Nota: Puede limpiar un poco la salida si usa la funci\u00f3n round() . Intente usarlo para redondear la salida a 4 d\u00edgitos. 1 60,0 2 36,0 3 21,6 4 12,96 5 7.776 6 4.6656 7 2.7994 8 1,6796 9 1.0078 10 0.6047 Ejercicio 1.6: Depuraci\u00f3n El siguiente fragmento de c\u00f3digo contiene c\u00f3digo del problema de la torre Sears. Tambi\u00e9n tiene un error. billete_grosor = 0.11 * 0.001 # Metros (0.11 mm) sears_altura = 442 # Altura (metros) num_billetes = 1 dia = 1 while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dias + 1 num_billetes = num_billetes * 2 print ('N\u00famero de d\u00edas', dia) print ('N\u00famero de facturas', num_billetes) print ('Altura final', num_billetes * billete_grosor) Copie y pegue el c\u00f3digo que aparece arriba en un nuevo programa llamado sears.py . Cuando ejecute el c\u00f3digo, obtendr\u00e1 un mensaje de error que hace que el programa se bloquee de esta manera: Traceback (most recent call last): File \"sears.py\", line 10, in <module> day = dias + 1 NameError: name 'dias' is not defined Leer los mensajes de error es una parte importante del c\u00f3digo Python. Si su programa falla, la \u00faltima l\u00ednea del mensaje de rastreo es la raz\u00f3n real por la cual el programa falla. Por encima de eso, deber\u00eda ver un fragmento de c\u00f3digo fuente y luego un nombre de archivo de identificaci\u00f3n y un n\u00famero de l\u00ednea. \u00bfQu\u00e9 l\u00ednea es el error? Cual es el error? Arreglar el error Ejecute el programa con \u00e9xito 1.3 N\u00fameros Esta secci\u00f3n discute sobre c\u00e1lculos matem\u00e1ticos. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 1.3.1: Tipos de numeros Python tiene 4 tipos de n\u00fameros: Booleanos Enteros Punto flotante Complejo (n\u00fameros imaginarios) 1.3.2: Booleanos (bool) Los booleanos tienen dos valores: True , False . a = True b = False Num\u00e9ricamente, se eval\u00faan como n\u00fameros enteros con valor \"1\", \"0\". c = 4 + True # 5 d = False if d == 0: print('d is False') Pero no escriba c\u00f3digo como ese. Ser\u00eda extra\u00f1o. * 1.3.3: Enteros (int) Valores firmados de tama\u00f1o y base arbitraria: a = 37 b = -299392993727716627377128481812241231 c = 0x7fa8 # Hexadecimal d = 0o253 # Octal e = 0b10001111 # Binario Operaciones comunes: x + y Suma x - y Resta x * y Multiplicacion x / y Divisi\u00f3n (produce un flotante) x // y Divisi\u00f3n entera (produce un entero) x % y Modulo (devuelve el resto de la divisi\u00f3n) x ** y Potencia x << n Bit desplazamiento izquierda x >> n Bit desplazamiento derecha x & y Bit-wise AND x | y Bit-wise OR x ^ y Bit-wise XOR ~x Bit-wise NOT abs(x) Valor absoluto 1.3.4: Punto flotante (float) Utilice una notaci\u00f3n decimal o exponencial para especificar un valor de coma flotante: a = 37.45 b = 4e5 # 4 x 10**5 or 400,000 c = -1.345e-10 Los flotantes se representan con precisi\u00f3n doble utilizando la representaci\u00f3n de CPU nativa IEEE 754 . Es lo mismo que el tipo \"doble\" en el lenguaje de programaci\u00f3n C. 17 d\u00edgitos de precisi\u00f3n Exponente de -308 a 308 Tenga en cuenta que los n\u00fameros de punto flotante son inexactos cuando representan decimales. >>> a = 2.1 + 4.2 >>> a == 6.3 False >>> a 6.300000000000001 >>> Esto no es un problema de Python , sino el hardware de punto flotante subyacente en la CPU. Operaciones comunes: x + y Suma x - y Resta x * y Multiplicacion x / y Division x // y Division entera x % y Modulo x ** y Potencia abs(x) Valor absoluto Estos son los mismos operadores que los enteros, excepto los operadores bit a bit. Las funciones matem\u00e1ticas adicionales se encuentran en el m\u00f3dulo math . import math a = math.sqrt(x) b = math.sin(x) c = math.cos(x) d = math.tan(x) e = math.log(x) 1.3.5: Comparaciones Los siguientes operadores de comparaci\u00f3n / relacionales funcionan con n\u00fameros: x < y Menor x <= y Menor o igual x > y Mayor x >= y Mayor o igual x == y Igual x != y No es igual Puede formar expresiones booleanas m\u00e1s complejas usando and , or , not Aqu\u00ed est\u00e1n algunos ejemplos: if b >= a and b <= c: print('b est\u00e1 entre a y c') if not (b < a or b > c): print('b todav\u00eda est\u00e1 entre a y c') 1.3.6: Convirtiendo numeros El nombre del tipo se puede utilizar para convertir valores: a = int(x) # Convierte x a entero b = float(x) # Convierte x a coma flotante Try it out. >>> a = 3.14159 >>> int(a) 3 >>> b = '3.14159' # Tambi\u00e9n funciona con cadenas de numeros >>> float(b) 3.14159 >>> 1.3.7: Ejercicios Recordatorio: Estos ejercicios asumen que est\u00e1 trabajando en el directorio /Work . Busque el archivo hipoteca.py . Ejercicio 1.7: La hipoteca de Dave Dave ha decidido sacar una hipoteca de tasa fija a 30 a\u00f1os de $500,000 con el comercio de hipotecas, inversiones en acciones y Bitcoin de Guido corporaci\u00f3n. La tasa de inter\u00e9s es del 5% y el pago mensual es $2684,11 . Aqu\u00ed hay un programa que calcula la cantidad total que Dave tendr\u00e1 para pagar durante la vida de la hipoteca: # mortgage.py capital = 500000.0 tasa = 0.05 pago = 2684.11 total_pagado = 0.0 while capital > 0: capital = capital * (1 + tasa / 12) - pago total_pagado = total_pagado + pago print('Total pagado', total_pagado) Ingrese a este programa y ejec\u00fatelo. Deber\u00eda obtener una respuesta de \"966,279.6\". Ejercicio 1.8: Pagos adicionales Suponga que Dave paga $1000 adicionales al mes durante los primeros 12 meses de la hipoteca. Modifique el programa para incorporar este pago adicional y haga que imprima el monto total pagado junto con la cantidad de meses requeridos. Cuando ejecute el nuevo programa, deber\u00eda informar un pago total de 929,965.62 durante 342 meses. Ejercicio 1.9: Hacer una calculadora de pago adicional Modifique el programa para que la informaci\u00f3n de pago adicional pueda manejarse de manera m\u00e1s general. H\u00e1galo de modo que el usuario pueda configurar estas variables: extra_pago_inicio_mes = 61 extra_pago_fin_mes = 108 extra_pago = 1000 Haga que el programa mire estas variables y calcule el total pagado adecuadamente. \u00bfCu\u00e1nto pagar\u00e1 Dave si paga $1000 adicionales al mes durante 4 a\u00f1os a partir de la primera ya se han pagado cinco a\u00f1os? Ejercicio 1.10: Crear una tabla Modifique el programa para imprimir una tabla que muestre el mes, el total pagado hasta el momento y el capital restante. La salida deber\u00eda verse as\u00ed: 1 2684.11 499399.22 2 5368.22 498795.94 3 8052.33 498190.15 4 10736.44 497581.83 5 13420.55 496970.98 ... 308 874705.88 3478.83 309 877389,99 809,21 310 880074.1 -1871.53 Total pagado 880074,1 Meses 310 Ejercicio 1.11: Bono Mientras lo hace, corrija el programa para corregir el pago en exceso que se produjo en el \u00faltimo mes. Ejercicio 1.12: Un misterio int() y float() se pueden usar para convertir n\u00fameros. Por ejemplo: >>> int(\"123\") 123 >>> float(\"1.23\") 1.23 >>> Con eso en mente, \u00bfpuede explicar este comportamiento? >>> bool(\"False\") True >>> 1.4 Cadenas Esta secci\u00f3n presenta formas de trabajar con texto. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 1.4.1: Representando texto literal Los literales de cadena se escriben en programas con comillas. # Comillas simples a = 'S\u00ed, pero no, pero s\u00ed, pero ...' # Comillas dobles b = \"la computadora dice que no\" # Comillas triples c = ''' M\u00edrame a los ojos, m\u00edrame a los ojos, los ojos, los ojos, los ojos, no alrededor de los ojos, no mires alrededor de los ojos, m\u00edrame a los ojos, est\u00e1s debajo. ''' Normalmente, las cadenas solo pueden abarcar una sola l\u00ednea. Las comillas triples capturan todo el texto incluido en varias l\u00edneas incluido todo el formato. No hay diferencia entre usar simple (') versus doble (\") citas. Sin embargo, se debe utilizar el mismo tipo de cita que se utiliza para iniciar una cadena como para terminarla . 1.4.2: C\u00f3digo de escape de cadenas Los c\u00f3digos de escape se utilizan para representar caracteres de control y caracteres que no se pueden escribir f\u00e1cilmente directamente en el teclado. A continuaci\u00f3n, se muestran algunos c\u00f3digos de escape comunes: '\\n' salto de l\u00ednea '\\r' Retorno de carro '\\t' Pesta\u00f1a '\\'' Literal comilla simple '\\' Literal comillas dobles '\\\\' Barra invertida literal 1.4.3: Representaci\u00f3n de cadenas Cada car\u00e1cter de una cadena se almacena internamente como un denominado \"punto de c\u00f3digo\" Unicode, que es un entero. Puede especificar un valor de punto de c\u00f3digo exacto mediante las siguientes secuencias de escape: a = '\\xf1' # a = '\u00f1' b = '\\u2200' # b = '\u2200' c = '\\U0001D122' # c = '\ud834\udd22' d = '\\N{FOR ALL}' # d = '\u2200' La [Base de datos de caracteres Unicode] (https://unicode.org/charts) es una referencia para todos los c\u00f3digos de caracteres disponibles. 1.4.4: Indexaci\u00f3n de cadenas Las cadenas funcionan como una matriz para acceder a caracteres individuales. Utiliza un \u00edndice entero, comenzando en 0. Los \u00edndices negativos especifican una posici\u00f3n relativa al final de la cadena. a = 'Hello world' b = a[0] # 'H' c = a[4] # 'o' d = a[-1] # 'd' (final de la cadena) Tambi\u00e9n puede dividir o seleccionar subcadenas especificando un rango de \u00edndices con : . d = a[:5] # 'Hello' e = a[6:] # 'world' f = a[3:8] # 'lo wo' g = a[-5:] # 'world' El car\u00e1cter del \u00edndice final no est\u00e1 incluido. Los \u00edndices que faltan asumen el principio o el final de la cadena. 1.4.5: Operaciones de cadena Concatenaci\u00f3n, tama\u00f1o, pertenencia y replicaci\u00f3n. # concatenaci\u00f3n (+) a = 'Hello' + 'World' # 'HelloWorld' b = 'Say ' + a # 'Say HelloWorld' # tama\u00f1o (len) s = 'Hello' len(s) # 5 # prueba de pertenencia (`in`, `not in`) t = 'e' in s # True f = 'x' in s # False g = 'hi' not in s # True # replicaci\u00f3n (s * n) rep = s * 5 # 'HelloHelloHelloHelloHello' 1.4.6: Metodos de cadena Las cadenas tienen m\u00e9todos que realizan varias operaciones con los datos de la cadena. Ejemplo: eliminar cualquier espacio en blanco inicial / final. s = ' Hello ' t = s.strip() # 'Hello' Ejemplo: conversi\u00f3n de casos. s = 'Hello' l = s.lower() # 'hello' u = s.upper() # 'HELLO' Ejemplo: Reemplazo de texto. s = 'Hello world' t = s.replace('Hello' , 'Hallo') # 'Hallo world' Otros metodos de cadena Las cadenas tienen una amplia variedad de otros m\u00e9todos para probar y manipular los datos de texto. Esta es una peque\u00f1a muestra de m\u00e9todos: s.endswith(sufijo) # Compruebe si la cadena termina con sufijo s.find(t) # Primera aparici\u00f3n de t en s s.index(t) # Primera aparici\u00f3n de t en s s.isalpha() # Comprueba si los caracteres son alfab\u00e9ticos s.isdigit() # Comprueba si los caracteres son num\u00e9ricos s.islower() # Comprueba si los caracteres son min\u00fasculas s.isupper() # Comprueba si los caracteres est\u00e1n en may\u00fasculas s.join(slist) # \u00danase a una lista de cadenas usando s como delimitador s.lower() # Convertir a min\u00fasculas s.replace(antiguo, nuevo) # Reemplazar texto s.rfind(t) # Busca t desde el final de la cadena s.rindex(t) # Busca t desde el final de la cadena s.split([delim]) # Dividir cadena en lista de subcadenas s.startswith(prefix) # Compruebe si la cadena comienza con prefijo s.strip() # Franja el espacio inicial / final s.upper() # Convertir a may\u00fasculas 1.4.7: Mutabilidad de cadenas Las cadenas son \"inmutables\" o de solo lectura. Una vez creado, el valor no se puede cambiar. >>> s = 'Hello World' >>> s[1] = 'a' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>> Todas las operaciones y m\u00e9todos que manipulan datos de cadenas, siempre crean cadenas nuevas. 1.4.8: Conversiones de cadena Utilice str () para convertir cualquier valor en una cadena. El resultado es una cadena que sostiene el mismo texto que habr\u00eda sido producido por la declaraci\u00f3n print () . >>> x = 42 >>> str(x) '42' >>> 1.4.9: Cadenas byte Una cadena de bytes de 8 bits, que se encuentra com\u00fanmente con I/O de bajo nivel, se escribe de la siguiente manera: data = b'Hola Mundo\\r\\n' Al poner una b peque\u00f1a antes de la primera cita, especificas que es una cadena de bytes en lugar de una cadena de texto. La mayor\u00eda de las operaciones habituales con cadenas funcionan. len(data) # 13 data[0:5] # b'Hola' data.replace(b'Hello', b'Cruel') # b'Cruel Mundo\\r\\n' La indexaci\u00f3n es un poco diferente porque devuelve valores de bytes como n\u00fameros enteros. data[0] # 72 (ASCII code for 'H') Conversion to/from text strings. text = data.decode('utf-8') # bytes -> texto data = text.encode('utf-8') # texto -> bytes El argumento 'utf-8' especifica una codificaci\u00f3n de caracteres. Otros comunes los valores incluyen 'ascii' y ' latin1' . 1.4.10: Cadenas crudas Las cadenas sin formato son literales de cadena con una barra invertida no interpretada. Se especifican anteponiendo la cita inicial con una \"r\" min\u00fascula. >>> rs = r'c:\\newdata\\test' # Sin formato (barra invertida no interpretada) >>> rs 'c:\\\\newdata\\\\test' La cadena es el texto literal incluido adentro, exactamente como se escribe. Esto es \u00fatil en situaciones en las que la barra invertida tiene significado. Ejemplo: nombre de archivo, expresiones regulares, etc. 1.4.11: Cadenas f Una cadena con sustituci\u00f3n de expresi\u00f3n formateada. >>> nombre = 'IBM' >>> acciones = 100 >>> precio = 91.1 >>> a = f'{nombre:>10s} {acciones:10d} {precio:10.2f}' >>> a ' IBM 100 91.10' >>> b = f'Costo = ${acciones * precio:0.2f}' >>> b 'Costo = $9110.00' >>> Nota: Esto requiere Python 3.6 o m\u00e1s reciente. El significado de los c\u00f3digos de formato se explica m\u00e1s adelante. 1.4.12: Ejercicios En estos ejercicios, experimentar\u00e1 con operaciones en Python tipo de cadena. Debe hacer esto en el indicador interactivo de Python donde puede ver f\u00e1cilmente los resultados. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Nota IMPORTANTE: En los ejercicios en los que se supone que debe interactuar con el int\u00e9rprete, >>> es el indicador del int\u00e9rprete que obtienes cuando Python quiere que escriba una nueva declaraci\u00f3n. Algunas declaraciones en el per\u00edodo de ejercicios varias l\u00edneas: para que se ejecuten estas declaraciones, es posible que deba presionar 'volver' unas cuantas veces. Solo un recordatorio de que * NO * escribe el >>> al trabajar con estos ejemplos. Empiece por definir una cadena que contenga una serie de s\u00edmbolos de cotizaci\u00f3n burs\u00e1til como este: >>> symbols = 'AAPL,IBM,MSFT,YHOO,SCO' >>> Ejercicio 1.13: Extracci\u00f3n de caracteres individuales y subcadenas Las cadenas son matrices de caracteres. Intente extraer algunos caracteres: >>> symbols[0] ? >>> symbols[1] ? >>> symbols[2] ? >>> symbols[-1] # Ultimo caracter ? >>> symbols[-2] # Indices negativos son desde el final ? >>> En Python, las cadenas son de solo lectura. Verifique esto intentando cambiar el primer car\u00e1cter de symbols a una min\u00fascula 'a'. >>> symbols[0] = 'a' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>> Ejercicio 1.14: Concatenaci\u00f3n de caracteres Although string data is read-only, you can always reassign a variable to a newly created string. Try the following statement which concatenates a new symbol \"GOOG\" to the end of symbols : >>> symbols = symbols + 'GOOG' >>> symbols 'AAPL,IBM,MSFT,YHOO,SCOGOOG' >>> \u00a1Ups! Eso no es lo que quer\u00edas. Corr\u00edjelo para que la variable symbols contenga el valor 'AAPL, IBM, MSFT, YHOO, SCO, GOOG' . >>> symbols = ? >>> symbols 'AAPL,IBM,MSFT,YHOO,SCO,GOOG' >>> Agregue 'HPQ' al frente de la cuerda >>> symbols = ? >>> symbols 'HPQ,AAPL,IBM,MSFT,YHOO,SCO,GOOG' >>> En estos ejemplos, puede parecer que la cadena original est\u00e1 siendo modificado, en una aparente violaci\u00f3n de que las cadenas sean de solo lectura. No entonces. Las operaciones en cadenas crean una cadena completamente nueva cada una hora. Cuando se reasigna el nombre de la variable s\u00edmbolos , apunta al cadena reci\u00e9n creada. Posteriormente, la cuerda vieja se destruye ya que ya no se usa. Ejercicio 1.15: Pruebas de membres\u00eda Experimente con el operador \"in\" para buscar subcadenas. En el mensaje interactivo, pruebe estas operaciones: >>> 'IBM' in symbols ? >>> 'AA' in symbols True >>> 'CAT' in symbols ? >>> \u00bfPor qu\u00e9 la comprobaci\u00f3n de 'AA' devolvi\u00f3 True ? Ejercicio 1.16: M\u00e9todos de cadenas En el indicador interactivo de Python, intente experimentar con algunos de los m\u00e9todos de cadena. >>> symbols.lower() ? >>> symbols ? >>> Recuerde, las cadenas siempre son de solo lectura. Si desea guardar el resultado de una operaci\u00f3n, debe colocarlo en una variable: >>> lowersyms = symbols.lower() >>> Pruebe algunas operaciones m\u00e1s: >>> symbols.find('MSFT') ? >>> symbols[13:17] ? >>> symbols = symbols.replace('SCO','DOA') >>> symbols ? >>> name = ' IBM \\n' >>> name = name.strip() # Remove surrounding whitespace >>> name ? >>> Ejercicio 1.17: f-strings A veces desea crear una cadena e incrustar los valores de variables en \u00e9l. Para hacer eso, use una f-string. Por ejemplo: >>> nombre = 'IBM' >>> acciones = 100 >>> precio = 91.1 >>> f'{acciones} acciones de {nombre} a ${precio:0.2f}' '100 acciones de IBM a $91.10' >>> Modifique el programa de hipoteca Dave mortgage.py del Ejercicio 1.10 para crear su salida usando f-strings. Intente hacer que la salida est\u00e9 bien alineada. Ejercicio 1.18: Expresiones regulares Una limitaci\u00f3n de las operaciones b\u00e1sicas con cadenas es que no admite cualquier tipo de coincidencia de patrones avanzada. Por eso tu Necesito recurrir al m\u00f3dulo re y las expresiones regulares de Python. El manejo de expresiones regulares es un gran tema, pero aqu\u00ed hay un breve ejemplo: >>> text = 'Today is 3/27/2018. Tomorrow is 3/28/2018.' >>> # Find all occurrences of a date >>> import re >>> re.findall(r'\\d+/\\d+/\\d+', text) ['3/27/2018', '3/28/2018'] >>> # Replace all occurrences of a date with replacement text >>> re.sub(r'(\\d+)/(\\d+)/(\\d+)', r'\\3-\\1-\\2', text) 'Today is 2018-3-27. Tomorrow is 2018-3-28.' >>> Para obtener m\u00e1s informaci\u00f3n sobre el m\u00f3dulo re , consulte la documentaci\u00f3n oficial en https://docs.python.org/library/re.html . Algunos comentarios A medida que comienza a experimentar con el int\u00e9rprete, a menudo desea conocer m\u00e1s sobre las operaciones soportadas por diferentes objetos. Por ejemplo, \u00bfc\u00f3mo averigua qu\u00e9 operaciones est\u00e1n disponibles en un cadena? Dependiendo de su entorno de Python, es posible que pueda ver una lista de los m\u00e9todos disponibles mediante el completado con tabulaci\u00f3n. Por ejemplo, intente escribir esta: >>> s = 'hello world' >>> s.<tab key> >>> Si presionar tab no hace nada, puede volver al funci\u00f3n incorporada dir() . Por ejemplo: >>> s = 'hello' >>> dir(s) ['__add__', '__class__', '__contains__', ..., 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] >>> dir() produce una lista de todas las operaciones que pueden aparecer despu\u00e9s de (.) . Utilice el comando help() para obtener m\u00e1s informaci\u00f3n sobre una operaci\u00f3n espec\u00edfica: >>> help(s.upper) Help on built-in function upper: upper(...) S.upper() -> string Return a copy of the string S converted to uppercase. >>> 1.5 Listas Esta secci\u00f3n presenta listas, el tipo principal de Python para contener una colecci\u00f3n ordenada de valores. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 1.5.1: Creando una lista Utilice corchetes para definir un literal de lista: nombres = [ 'Elwood', 'Jake', 'Curtis' ] numeros = [39, 38, 42, 65, 111] En ocasiones las listas son creadas por otros metodos. Por ejemplo, una cadena puede ser dividida haciendo uso del m\u00e9todo split() . >>> linea = 'GOOG,100,490.10' >>> fila = line.split(',') >>> fila ['GOOG', '100', '490.10'] >>> 1.5.2: Operaciones de lista Las listas pueden contener elementos de cualquier tipo. Agregue un nuevo elemento usando append() : nombres.append('Murphy') # Agrega al final nombres.insert(2, 'Aretha') # Inserta en el medio Use + para concatenar listas: s = [1, 2, 3] t = ['a', 'b'] s + t # [1, 2, 3, 'a', 'b'] Las listas est\u00e1n indexadas por n\u00fameros enteros. A partir de 0. nombres = [ 'Elwood', 'Jake', 'Curtis' ] nombres[0] # 'Elwood' nombres[1] # 'Jake' nombres[2] # 'Curtis' Los \u00edndices negativos cuentan desde el final. nombres[-1] # 'Curtis' Puede cambiar cualquier elemento de una lista. nombres[1] = 'Joliet Jake' nombres # [ 'Elwood', 'Joliet Jake', 'Curtis' ] Length of the list. nombres = ['Elwood','Jake','Curtis'] len(nombres) # 3 Prueba de pertenencia ( in , not in ) 'Elwood' in nombres # True 'Britney' not in nombres # True Replicaci\u00f3n ( s * n ). s = [1, 2, 3] s * 3 # [1, 2, 3, 1, 2, 3, 1, 2, 3] 1.5.3: Iteracion de lista y b\u00fasqueda Utilice for para iterar sobre el contenido de la lista. for nombre in nombres: # use nombre # e.g. print(nombre) ... Esto es similar a una declaraci\u00f3n foreach de otros lenguajes de programaci\u00f3n. Para encontrar la posici\u00f3n de algo r\u00e1pidamente, use index() . nombres = ['Elwood','Jake','Curtis'] nombres.index('Curtis') # 2 Si el elemento est\u00e1 presente m\u00e1s de una vez, index() devolver\u00e1 el \u00edndice de la primera aparici\u00f3n. Si el elemento no se encuentra, generar\u00e1 una excepci\u00f3n \"ValueError\". 1.5.4: Remoci\u00f3n en lista Puede eliminar elementos por valor de elemento o por \u00edndice: # Using the value nombres.remove('Curtis') # Using the index del nombres[1] Eliminar un art\u00edculo no crea un agujero. Otros elementos se mover\u00e1n hacia abajo para llenar el espacio desocupado. Si hay m\u00e1s de una aparici\u00f3n del elemento, remove() eliminar\u00e1 solo la primera aparici\u00f3n. 1.5.5: Ordenar una lista Las listas se pueden ordenar \"in situ\". s = [10, 1, 7, 3] s.sort() # [1, 3, 7, 10] # Reverse order s = [10, 1, 7, 3] s.sort(reverse=True) # [10, 7, 3, 1] # It works with any ordered data s = ['foo', 'bar', 'spam'] s.sort() # ['bar', 'foo', 'spam'] Utilice sorted() si desea crear una nueva lista en su lugar: t = sorted(s) # s sin cambios, t tiene los valores ordenados 1.5.6: Listas y matem\u00e1ticas Caution: Lists were not designed for math operations. >>> nombres = [1, 2, 3, 4, 5] >>> nombres * 2 [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] >>> nombres + [10, 11, 12, 13, 14] [1, 2, 3, 4, 5, 10, 11, 12, 13, 14] Espec\u00edficamente, las listas no representan vectores/matrices como en MATLAB, Octave, R, etc. Sin embargo, existen algunos m\u00f3dulos/paquetes/librer\u00edas que le ayudan con eso (e.g. numpy ) 1.5.7: Ejercicios En este ejercicio, experimentaremos con listas. En la ultima secci\u00f3n trabajamos con cadenas conteniendo s\u00edmbolos de acciones de bolsa valores. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador >>> symbols = 'HPQ,AAPL,IBM,MSFT,YHOO,DOA,GOOG' Divida la cadena en una lista de nombres haciendo uso de la operacion split() de cadenas: >>> symlist = symbols.split(',') Ejercicio 1.19: Extracci\u00f3n y reasignaci\u00f3n de elementos Pruebe algunas busquedas: >>> symlist[0] 'HPQ' >>> symlist[1] 'AAPL' >>> symlist[-1] 'GOOG' >>> symlist[-2] 'DOA' >>> Intente reasignar un valor: >>> symlist[2] = 'AIG' >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'DOA', 'GOOG'] >>> Agarre unos pedazos: >>> symlist[0:3] ['HPQ', 'AAPL', 'AIG'] >>> symlist[-2:] ['DOA', 'GOOG'] Crea una lista vac\u00eda y agregue un elemento. >>> mysyms = [] >>> mysyms.append('GOOG') >>> mysyms ['GOOG'] Puede reasignar una porci\u00f3n de la lista a otra lista. Por ejemplo: >>> symlist[-2:] = mysyms >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG'] >>> Cuando hace esto, la lista en el lado izquierdo ( symlist ) ser\u00e1 reajustada apropiadamente para que el lado derecho ( mysyms ) ocupe un puesto en ella. Ejercicio 1.20: Ciclando sobre una lista El ciclo/bucle for funciona ciclando sobre data en una secuencia la lista. Pruebe lo siguiente: >>> for s in symlist: ... print('s =', s) Ejercicio 1.21: Pruebas de pertenencia Utilice el operador in o not in para comprobar si 'AIG' , 'AA' y 'CAT' est\u00e1n en la lista de s\u00edmbolos. >>> # Est\u00e1 'AIG' en `symlist`? True >>> # Est\u00e1 'AA' en `symlist`? False >>> # 'CAT' no esta en `symlist`? True >>> Ejercicio 1.22: A\u00f1adiendo, insertando y borrando elementos Utilice el m\u00e9todo append() para agregar el s\u00edmbolo 'RHT' al final de symlist . >>> # agregue 'RHT' >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT'] >>> Utilice el m\u00e9todo insert() para insertar el s\u00edmbolo 'AA' como el segundo elemento de la lista. >>> # Agregue 'AA' como segundo item en la lista >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT'] >>> Utilice el m\u00e9todo remove() para eliminar 'MSFT' de la lista. >>> # Remueva 'MSFT' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT'] >>> A\u00f1ada una entrada duplicada para 'YHOO' al final de la lista. Nota: est\u00e1 perfectamente bien si una lista tenga valores duplicados. >>> # Append 'YHOO' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT', 'YHOO'] >>> Utilice el m\u00e9todo index() para encontrar la primera posici\u00f3n de 'YHOO' en la lista. >>> # Encuentre el primer \u00edndice de 'YHOO' 4 >>> symlist[4] 'YHOO' >>> Cuente cu\u00e1ntas veces 'YHOO' est\u00e1 en la lista: >>> symlist.count('YHOO') 2 >>> Remueva la primera ocurrencia de 'YHOO' . >>> # Remueva primera ocurrencia de 'YHOO' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'GOOG', 'RHT', 'YHOO'] >>> Para su informaci\u00f3n, no existe ning\u00fan m\u00e9todo para buscar o eliminar todas las apariciones de un elemento Sin embargo, veremos una forma elegante de hacer esto en la secci\u00f3n 2. Ejercicio 1.23: Ordernando \u00bfQuieres ordenar una lista? Utilice el m\u00e9todo sort() . Pru\u00e9balo: >>> symlist.sort() >>> symlist ['AA', 'AAPL', 'AIG', 'GOOG', 'HPQ', 'RHT', 'YHOO'] >>> \u00bfQuiere ordenar al rev\u00e9s? Prueba esto: >>> symlist.sort(reverse=True) >>> symlist ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'] >>> Nota: ordenar una lista modifica su contenido \"en el lugar\". Es decir, los elementos de la lista se mezclan, pero no se crea una nueva lista como resultado. Ejercicio 1.24: Ajuntando todo nuevamente \u00bfQuiere tomar una lista de cadenas y unirlas en una sola cadena? Utilice el m\u00e9todo join () de cadenas como esta (nota: esto se ve gracioso al principio). >>> a = ','.join(symlist) >>> a 'YHOO,RHT,HPQ,GOOG,AIG,AAPL,AA' >>> b = ':'.join(symlist) >>> b 'YHOO:RHT:HPQ:GOOG:AIG:AAPL:AA' >>> c = ''.join(symlist) >>> c 'YHOORHTHPQGOOGAIGAAPLAA' >>> Ejercicio 1.25: Listas de cualquier cosa Las listas pueden contener cualquier tipo de objeto, incluidas otras listas (por ejemplo, listas anidadas). Probar esto: >>> nums = [101, 102, 103] >>> items = ['spam', symlist, nums] >>> items ['spam', ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'], [101, 102, 103]] Preste mucha atenci\u00f3n a la salida anterior. items es una lista con tres elementos. El primer elemento es una cadena, pero los otros dos elementos son listas. Puede acceder a los elementos de las listas anidadas mediante varias operaciones de indexaci\u00f3n. >>> items[0] 'spam' >>> items[0][0] 's' >>> items[1] ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'] >>> items[1][1] 'RHT' >>> items[1][1][2] 'T' >>> items[2] [101, 102, 103] >>> items[2][1] 102 >>> Aunque t\u00e9cnicamente es posible hacer estructuras muy complicadas compuestas por listas, como regla general, es preferible mantener las cosas simples. Por lo general, las listas contienen elementos que tienen el mismo tipo de valor. Por ejemplo, una lista que consta completamente de n\u00fameros o una lista de texto de cadena. Mezclar diferentes tipos de datos en la misma lista es a menudo un buen dolor de cabeza, por lo que es mejor evitarlo. 1.6 Archivos La mayor\u00eda de los programas necesitan leer la entrada de alg\u00fan lugar. Esta secci\u00f3n discute sobre el acceso a archivos. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 1.6.1: Entrada y Salida de un Archivo Abre un archivo. f = open('foo.txt', 'rt') # Open for reading (text) g = open('bar.txt', 'wt') # Open for writing (text) Lee toda la data. data = f.read() data = f.read([maxbytes]) # Read only up to 'maxbytes' bytes Escribe algo de texto. g.write('some text') Cierra cuando terminas. f.close() g.close() Files should be properly closed and it's an easy step to forget. Thus, the preferred approach is to use the with statement like this. with open(filename, 'rt') as file: # Haz uso del archivo \"file\" ... # No hay necesidad de cerrar expl\u00edcitamente ...statements Esto cierra autom\u00e1ticamente el archivo cuando el control abandona el bloque de c\u00f3digo con sangr\u00eda. 1.6.2: Patrones comunes de lectura de archivos Leer un archivo completo de una vez como una cadena. with open('foo.txt', 'rt') as file: data = file.read() # `data` is a string with all the text in `foo.txt` Leer un archivo l\u00ednea por l\u00ednea iterando. with open(filename, 'rt') as file: for line in file: # Process the line 1.6.3: Patrones comunes de escritura de archivos Escribe data en cadena. with open('outfile', 'wt') as out: out.write('Hello World\\n') ... Redireccionando la funci\u00f3n de impresi\u00f3n. with open('outfile', 'wt') as out: print('Hola Mundo', file=out) ... 1.6.4: Ejercicios Estos ejercicios dependen de un archivo Data/portfolio.csv . El archivo contiene una lista de l\u00edneas con informaci\u00f3n sobre una cartera de acciones. Se supone que est\u00e1 trabajando en el archivo ./Work/ directorio. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 1.26: Prerequisitos Primero, intente leer todo el archivo a la vez en una cadena grande: >>> with open('Data/portfolio.csv', 'rt') as f: data = f.read() >>> data 'name,shares,price\\n\"AA\",100,32.20\\n\"IBM\",50,91.10\\n\"CAT\",150,83.44\\n\"MSFT\",200,51.23\\n\"GE\",95,40.37\\n\"MSFT\",50,65.10\\n\"IBM\",100,70.44\\n' >>> print(data) name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 \"CAT\",150,83.44 \"MSFT\",200,51.23 \"GE\",95,40.37 \"MSFT\",50,65.10 \"IBM\",100,70.44 >>> En el ejemplo anterior, cabe se\u00f1alar que Python tiene dos modos de salida. En el primer modo, donde aparece \">>> data\" en el indicador, Python muestra la representaci\u00f3n de la cadena sin procesar, incluidas las comillas y c\u00f3digos de escape. Cuando escribe print(data) , obtiene el formato real de salida de la cadena. Para leer un archivo l\u00ednea por l\u00ednea, use un bucle for como \u00e9ste: >>> with open('Data/portfolio.csv', 'rt') as f: for line in f: print(line, end='') name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 ... >>> En determinadas ocasiones, es posible que desee leer u omitir manualmente una \u00fanica l\u00ednea de texto (por ejemplo, tal vez desee omitir la primera l\u00ednea de los encabezados de columna). >>> f = open('Data/portfolio.csv', 'rt') >>> headers = next(f) >>> headers 'name,shares,price\\n' >>> for line in f: print(line, end='') \"AA\",100,32.20 \"IBM\",50,91.10 ... >>> f.close() >>> next() devuelve la siguiente l\u00ednea de texto en el archivo. Si lo llamara repetidamente, obtendr\u00eda l\u00edneas sucesivas. Sin embargo, para que lo sepa, el ciclo for hace uso de next() para obtener sus datos. Por lo tanto, normalmente no lo llamar\u00eda directamente a menos que est\u00e9 tratando de omitir o leer expl\u00edcitamente una sola l\u00ednea como se muestra. Una vez que est\u00e9 leyendo las l\u00edneas de un archivo, puede comenzar a realizar m\u00e1s procesamiento, como dividir. Por ejemplo, intente esto: >>> f = open('Data/portfolio.csv', 'rt') >>> headers = next(f).split(',') >>> headers ['name', 'shares', 'price\\n'] >>> for line in f: row = line.split(',') print(row) ['\"AA\"', '100', '32.20\\n'] ['\"IBM\"', '50', '91.10\\n'] ... >>> f.close() Nota: En estos ejemplos, f.close() se llama expl\u00edcitamente porque no se utiliza la instrucci\u00f3n with . Ejercicio 1.27: Leyendo de un archivo Ahora que sabe c\u00f3mo leer un archivo, escribamos un programa para realizar un c\u00e1lculo. Las columnas de portfolio.csv corresponden al nombre de la acci\u00f3n, n\u00famero de acciones, y precio de compra de una sola participaci\u00f3n accionaria. Escribe un programa llamado pcost.py que abre este archivo, lee todas las l\u00edneas y calcula cu\u00e1nto cost\u00f3 comprar todas las acciones en la cartera (portfolio). Sugerencia: para convertir una cadena en un entero, use int(s) . Para convertir una cadena en punto flotante, use float(s) . Su programa deber\u00eda imprimir un resultado como el siguiente: Costo total 44671.15 Ejercicio 1.28: Otro tipo de \"archivos\" \u00bfY si quisiera leer un archivo que no es de texto, como un archivo comprimido gzip? La funci\u00f3n integrada open() no le ayudar\u00e1 aqu\u00ed, pero Python tiene un m\u00f3dulo gzip que puede leer archivos comprimidos gzip. >>> import gzip >>> with gzip.open('Data/portfolio.csv.gz', 'rt') as f: for line in f: print(line, end='') ... mira la salida ... >>> Nota: Incluir el modo de archivo de 'rt' es fundamental aqu\u00ed. Si olvidas eso obtendr\u00e1 cadenas de bytes en lugar de cadenas de texto normales. Algunos comentarios Los cient\u00edficos de datos se apresuran a se\u00f1alar que librerias como Pandas ya tienen una funci\u00f3n para leer archivos CSV. Esto es cierto y funciona bastante bien. Sin embargo, este no es un curso sobre c\u00f3mo aprender pandas. Leer archivos es un problema m\u00e1s general que las espec\u00edficaciones de archivos CSV. La raz\u00f3n principal por la que trabajamos con un archivo CSV es porque es un formato conocido para la mayor\u00eda de los programadores y es relativamente f\u00e1cil trabajarlo directamente - ilustrando muchas caracter\u00edsticas de Python en el proceso. Entonces, por supuesto, use Pandas cuando regrese al trabajo. Para el resto de este curso, sin embargo, vamos a seguir con la funcionalidad est\u00e1ndar de Python. 1.7 Funciones A medida que sus programas comiencen a crecer, va a querer organizarse. Esta secci\u00f3n presenta brevemente las funciones y los m\u00f3dulos de la biblioteca est\u00e1ndar. Tambi\u00e9n se introduce el manejo de errores con excepciones. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 1.7.1: Funciones personalizadas Utilice funciones para el c\u00f3digo que desea reutilizar. Aqu\u00ed hay una definici\u00f3n de funci\u00f3n: def sumcount(n): ''' Retorna la suma de los primeros n enteros ''' total = 0 while n > 0: total += n n -= 1 return total Para llamar una funci\u00f3n. a = sumcount(100) Una funci\u00f3n es una serie de declaraciones que realizan alguna tarea y devuelven un resultado. La palabra clave return es necesaria para especificar expl\u00edcitamente el valor de retorno de la funci\u00f3n. 1.7.2: Funciones de biblioteca Python viene con una gran biblioteca est\u00e1ndar. Se accede a los m\u00f3dulos de la biblioteca usando import . Por ejemplo: import math x = math.sqrt(10) import urllib.request u = urllib.request.urlopen('http://www.python.org/') data = u.read() Cubriremos bibliotecas y m\u00f3dulos con m\u00e1s detalle m\u00e1s adelante. 1.7.3: Errores y excepciones Las funciones informan sobre errores como las excepciones. Una excepci\u00f3n provoca la interrupci\u00f3n de una funci\u00f3n y puede hacer que todo el programa se detenga si no se maneja. Prueba esto en tu REPL (read/lee, evaluate/evalua, print/imprime, cicla/loop) de Python. >>> int('N/A') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: invalid literal for int() with base 10: 'N/A' >>> Para fines de depuraci\u00f3n, el mensaje describe lo que sucedi\u00f3, d\u00f3nde ocurri\u00f3 el error, y un rastreo que muestra las otras llamadas a funciones que provocaron la falla. 1.7.4: Atrapando y gestionando excepciones Las excepciones de pueden atrapar y gestionar. Para atrapar, use la declaraci\u00f3n try - except . for linea in f: campos = linea.split() try: acciones = int(campos[1]) except ValueError: print(\"No se pudo analizar\", linea) ... El nombre \"ValueError\" debe coincidir con el tipo de error que est\u00e1 intentando detectar. A menudo es dif\u00edcil saber exactamente qu\u00e9 tipo de errores pueden ocurrir de antemano dependiendo de la operaci\u00f3n que se est\u00e9 realizando. Para mejor o para peor, el manejo de excepciones a menudo se agrega despu\u00e9s de que un programa fall\u00f3 inesperadamente (es decir, \"oh, nos olvidamos de detectar ese error, deber\u00eda gestionar eso! \"). 1.7.5: Generando excepciones Para generar una excepci\u00f3n, use la instrucci\u00f3n raise . raise RuntimeError('Que desorden') Esto har\u00e1 que el programa se anule con un rastreo de excepci\u00f3n. A menos que sea atrapado por un bloque \"try-except\". $ python3 foo.py Traceback (most recent call last): File \"foo.py\", line 21, in <module> raise RuntimeError(\"Que desorden\") RuntimeError: What a kerfuffle 1.7.6: Ejercicios Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Ejercicio 1.29: Definiendo una funci\u00f3n Intente definir una funci\u00f3n simple: >>> def saludo(nombre): 'Genera un saludo' print('Hola', nombre) >>> saludo('Guido') Hola Guido >>> saludo('Paula') Hola Paula >>> Si la primera declaraci\u00f3n de una funci\u00f3n es una cadena, sirve como documentaci\u00f3n. Intente escribir un comando como help(saludo) para que se muestre. Ejercicio 1.30: Convirtiendo una secuencia de comandos en una funci\u00f3n Tome el c\u00f3digo que escribi\u00f3 para el programa pcost.py en el Ejercicio 1.27 y convi\u00e9rtalo en una funci\u00f3n cartera_costo(nombre_de_archivo) . La funci\u00f3n toma un nombre de archivo como entrada, lee los datos de la cartera en ese archivo y devuelve el costo total de la cartera como flotante. Para usar su funci\u00f3n, cambie su programa para que se vea algo as\u00ed: def cartera_costo(nombre_de_archivo): ... # Su c\u00f3digo aqu\u00ed ... costo = cartera_costo('Data/portfolio.csv') print('Total cost:', costo) Cuando ejecute su programa, deber\u00eda ver el mismo resultado que antes. Despu\u00e9s de ejecutar su programa, tambi\u00e9n puede llamar a su funci\u00f3n interactivamente escribiendo esto: $ python3 -i pcost.py Esto le permitir\u00e1 llamar a su funci\u00f3n desde el modo interactivo. >>> cartera_costo('Data/portfolio.csv') 44671.15 >>> Being able to experiment with your code interactively is useful for testing and debugging. Ejercicio 1.31: Administraci\u00f3n de errores \u00bfQu\u00e9 sucede si prueba su funci\u00f3n en un archivo al que le faltan algunos campos? >>> cartera_costo('Data/missing.csv') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"pcost.py\", line 11, in cartera_costo nshares = int(fields[1]) ValueError: invalid literal for int() with base 10: '' >>> En este momento, tiene que tomar una decisi\u00f3n. Para que el programa funcione puede depurar el archivo de entrada eliminando las l\u00edneas o puede modificar su c\u00f3digo para manejar las l\u00edneas defectuosas de alguna forma. Modifique el programa pcost.py para detectar la excepci\u00f3n, imprima una advertencia mensaje y contin\u00fae procesando el resto del archivo. Ejercicio 1.32: Usando una funci\u00f3n de biblioteca local Python viene con una biblioteca est\u00e1ndar de funciones \u00fatiles. Una biblioteca que podr\u00eda ser \u00fatil aqu\u00ed es el m\u00f3dulo csv . Debe usarlo siempre que tenga que trabajar con archivos de datos CSV. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo funciona: >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'shares', 'price'] >>> for row in rows: print(row) ['AA', '100', '32.20'] ['IBM', '50', '91.10'] ['CAT', '150', '83.44'] ['MSFT', '200', '51.23'] ['GE', '95', '40.37'] ['MSFT', '50', '65.10'] ['IBM', '100', '70.44'] >>> f.close() >>> Una cosa buena sobre el m\u00f3dulo csv es que se ocupa de una variedad de detalles de bajo nivel como las comillas y la divisi\u00f3n adecuada por comas. En la salida anterior, notar\u00e1 que ha eliminado las comillas dobles lejos de los nombres en la primera columna. Modifique su programa pcost.py para que use el m\u00f3dulo csv para analizar e intentar ejecutar ejemplos anteriores. Ejercicio 1.33: Leyendo desde la l\u00ednea de comando En el programa pcost.py , el nombre del archivo de entrada se ha integrado en el c\u00f3digo: # pcost.py def cartera_costo(filename): ... # Su c\u00f3digo aqu\u00ed ... costo = cartera_costo('Data/portfolio.csv') print('Total costo:', costo) Est\u00e1 bien para aprender y probar, pero en un programa real probablemente no har\u00eda eso. En su lugar, pudiera pasar el nombre del archivo como argumento a un archivo con una secuencia de comandos. Intente cambiar la parte inferior del programa de la siguiente manera: # pcost.py import sys def cartera_costo(filename): ... # Su c\u00f3digo aqu\u00ed ... if len(sys.argv) == 2: filename = sys.argv[1] else: filename = 'Data/portfolio.csv' costo = cartera_costo(filename) print('Total costo:', costo) sys.argv es una lista que contiene argumentos pasados en la l\u00ednea de comando (si los hay). Para ejecutar su programa, deber\u00e1 ejecutar Python desde la terminal. Por ejemplo, desde bash en Unix: bash % python3 pcost.py Data/portfolio.csv Total cost: 44671.15 bash %","title":"1 Intro a Python"},{"location":"1/#1-intro-a-python","text":"","title":"1. Intro a Python"},{"location":"1/#11-introduciendo-python","text":"El objetivo de este cap\u00edtulo es introducir las bases de Python. Iniciaremos desde cero y aprenderemos a editar, ejecutar, y depurar programas. Adem\u00e1s, escribiremos una secuencia de comandos que lee data en un archivo CSV y ejecuta un c\u00e1lculo.","title":"1.1 Introduciendo Python"},{"location":"1/#111-que-es-python","text":"Python es un lenguaje interpretado de programaci\u00f3n de alto nivel. A menudo se le clasifica como un lenguaje de secuencias de comandos y tambi\u00e9n se le considera similar a lenguajes como Perl, Tcl o Ruby. La sintaxis de Python est\u00e1 vagamente inspirada en elementos de la programaci\u00f3n C. Python fue creado por Guido van Rossum alrededor de 1990, quien lo nombr\u00f3 en honor a la comedia de origen brit\u00e1nico Monty Python .","title":"1.1.1: Qu\u00e9 es Python?"},{"location":"1/#112-donde-consigo-python","text":"Puedes obtener una versi\u00f3n de Python en Python.org . Para los prop\u00f3sitos de este curso, solo necesitas una instalaci\u00f3n b\u00e1sica. Recomiendo instalar Python 3.6 o una versi\u00f3n m\u00e1s reciente. Python 3.6 es el que se usa en las notas y en las soluciones, sin embargo puedes utilizar cualquier versi\u00f3n.","title":"1.1.2: Donde consigo Python?"},{"location":"1/#113-porque-fue-creado","text":"En palabras del creador de Python: Mi motivaci\u00f3n original para crear Python fue la necesidad percibida de un lenguaje de alto nivel en el proyecto Amoeba [Sistemas Operativos]. Me di cuenta de que el desarrollo de las utilidades de administraci\u00f3n del sistema en C estaban tardando demasiado. Adem\u00e1s, hacer estas cosas en el shell Bourne no iba a funcionar por una variedad de razones. ... Entonces, era necesario un lenguaje que cerrara la brecha entre C y el shell. Guido van Rossum","title":"1.1.3: Porqu\u00e9 fue creado?"},{"location":"1/#114-donde-esta-python-en-mi-maquina","text":"Aunque hay muchos entornos en los que puede ejecutar Python, Python normalmente se instala en su m\u00e1quina como un programa que se ejecuta desde la terminal o el shell de comandos. Desde la terminal, deber\u00eda poder escribir python as\u00ed: $ python Python 3.8.1 (default, Feb 20 2020, 09:29:22) [Clang 10.0.0 (clang-1000.10.44.4)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> print(\"hello world\") hello world >>> Aunque hay muchos entornos en donde puede programar en Python, ser\u00e1 un programador m\u00e1s fuerte si puede ejecutar, depurar e interactuar con Python en la terminal. Este es el entorno nativo de Python. Si puede usar Python aqu\u00ed, podr\u00e1 usarlo en cualquier otro lugar.","title":"1.1.4: D\u00f3nde est\u00e1 Python en mi Maquina?"},{"location":"1/#115-ejercicios","text":"Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.1.5: Ejercicios"},{"location":"1/#ejercicio-11-utilizando-python-como-calculadora","text":"En su m\u00e1quina, inicie Python y util\u00edcelo como calculador para resolver el siguiente problema. El suertudo de Juan compr\u00f3 75 acciones de Google a un precio de $235.14 USD por acci\u00f3n. Hoy, las acciones de Google tienen un precio de $711.25 USD. Usando el modo interactivo de Python como una calculadora, averig\u00fce cu\u00e1ntas ganancias obtendr\u00eda Juan si vendiera todas sus acciones. >>> (711.25 - 235.14) * 75 35708.25 >>> Consejo profesional: use la variable de subrayado ( _ ) para usar el resultado del \u00faltimo c\u00e1lculo. Por ejemplo, \u00bfcu\u00e1ntas ganancias obtiene Juan despu\u00e9s de que su malvado corredor se lleva su parte del 20%? >>> _ * 0.80 28566.600000000002 >>>","title":"Ejercicio 1.1: Utilizando Python como Calculadora"},{"location":"1/#ejercicio-12-consiguiendo-ayuda","text":"Utilice el comando help() para obtener ayuda sobre la funci\u00f3n abs() . Luego use help() para obtener ayuda sobre la funci\u00f3n round() . Escriba help() , asi sin valor alguno, para ingresar al visor de ayuda interactiva. Una advertencia con help() es que no funciona para declaraciones b\u00e1sicas de Python como for, if, while, etc. (es decir, si escribe help(for) obtendr\u00e1 un error de sintaxis). En su lugar, puede intentar poner el tema de la ayuda entre comillas: help('for') . Si eso no funciona, tendr\u00e1 que recurrir a una b\u00fasqueda en Internet. Seguimiento: vaya a http://docs.python.org y busque la documentaci\u00f3n de la funci\u00f3n abs() (pista: se encuentra en la referencia de la biblioteca relacionada con las funciones integradas).","title":"Ejercicio 1.2: Consiguiendo ayuda"},{"location":"1/#ejercicio-13-copiar-y-pegar","text":"Este curso est\u00e1 estructurado como una serie de p\u00e1ginas en las que se le anima a probar ejemplos interactivos de c\u00f3digo Python escribi\u00e9ndolos a mano. Si est\u00e1 aprendiendo Python por primera vez, se recomienda este \"enfoque lento\". Obtendr\u00e1 una mejor idea del idioma al reducir la velocidad, escribir cosas y pensar en lo que est\u00e1 haciendo. Si debe \"cortar y pegar\" ejemplos de c\u00f3digo, seleccione el c\u00f3digo comenzando despu\u00e9s del indicador >>> y subiendo hasta, pero no m\u00e1s all\u00e1 de la primera l\u00ednea en blanco o el siguiente mensaje >>> (lo que aparezca primero). Seleccione \"copiar\" en el navegador, vaya a la ventana de Python y seleccione \"pegar\" para copiarlo en el shell de Python. Para que el c\u00f3digo se ejecute, es posible que deba presionar \"Retorno\" una vez despu\u00e9s de haberlo pegado. Corte y pegue las siguientes declaraciones de Python: >>> 12 + 20 32 >>> (3 + 4 + 5 + 6) 18 >>> for i in range(5): print(i) 0 1 2 3 4 >>> Advertencia: No es posible pegar m\u00e1s de un comando de Python (declaraciones que aparecen despu\u00e9s de >>> ) en el shell b\u00e1sico de Python a la vez. Tienes que pegar cada comando de uno en uno. Ahora que ha hecho esto, recuerde que sacar\u00e1 m\u00e1s provecho de la clase escribiendo el c\u00f3digo lentamente y pensando en ello, no cortando y pegando.","title":"Ejercicio 1.3: Copiar y pegar"},{"location":"1/#ejercicio-14-donde-esta-mi-bus","text":"Pruebe algo m\u00e1s avanzado y escriba estas declaraciones para averiguar cu\u00e1nto tiempo tendr\u00e1n que esperar las personas que esperan en la esquina de la calle Clark y Balmoral en Chicago al pr\u00f3ximo autob\u00fas CTA n. \u00b0 22 en direcci\u00f3n norte: >>> import urllib.request >>> u = urllib.request.urlopen('http://ctabustracker.com/bustime/map/getStopPredictions.jsp?stop=14791&route=22') >>> from xml.etree.ElementTree import parse >>> doc = parse(u) >>> for pt in doc.findall('.//pt'): print(pt.text) 6 MIN 18 MIN 28 MIN >>> S\u00ed, acaba de descargar una p\u00e1gina web, analizar un documento XML y extraer informaci\u00f3n \u00fatil en aproximadamente 6 l\u00edneas de c\u00f3digo. Los datos a los que accedi\u00f3 en realidad alimentan el sitio web http://ctabustracker.com/bustime/home.jsp. Int\u00e9ntelo nuevamente y observe c\u00f3mo cambian las predicciones. Si falla la primera declaraci\u00f3n de importaci\u00f3n import urllib.request , probablemente est\u00e9 usando Python 2. Para este curso, debe asegurarse de que est\u00e1 usando Python 3.6 o m\u00e1s reciente. Vaya a https://www.python.org para descargarlo si lo necesita. Si su entorno de trabajo requiere el uso de un servidor proxy HTTP, es posible que deba configurar la variable de entorno HTTP_PROXY para que esta parte del ejercicio funcione. Por ejemplo: >>> import os >>> os.environ['HTTP_PROXY'] = 'http://suproxy.server.com' >>> Si no puede hacer que esto funcione, no se preocupe. El resto de este curso no tiene nada que ver con analizar XML.","title":"Ejercicio 1.4: Donde esta mi bus?"},{"location":"1/#12-un-primer-programa","text":"Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.2 Un primer programa"},{"location":"1/#121-ejecutando-python","text":"Los programas de Python siempre se ejecutan dentro de un int\u00e9rprete. El int\u00e9rprete es una aplicaci\u00f3n \"basada en consola\" que normalmente se ejecuta desde un shell de comandos. python3 Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Los programadores expertos generalmente no tienen problemas para usar el int\u00e9rprete de esta manera, pero no es tan f\u00e1cil de usar para los principiantes. Es posible que est\u00e9 utilizando un entorno que proporciona una interfaz diferente a Python. Eso est\u00e1 bien, pero aprender a ejecutar la terminal de Python sigue siendo una habilidad \u00fatil.","title":"1.2.1: Ejecutando Python"},{"location":"1/#122-modo-interactivo","text":"Cuando inicias Python, obtienes un modo interactivo donde puedes experimentar. Si comienza a escribir declaraciones, se ejecutar\u00e1n de inmediato. No hay ciclo de edici\u00f3n / compilaci\u00f3n / ejecuci\u00f3n / depuraci\u00f3n. >>> print('hello world') hello world >>> 37*42 1554 >>> for i in range(5): ... print(i) ... 0 1 2 3 4 >>> Este llamado ciclo de lectura-evaluaci\u00f3n-impresi\u00f3n (o REPL, por sus siglas en ingl\u00e9s) es muy \u00fatil para depurar y explorar. DETENTE : si no puedes descubrir c\u00f3mo interactuar con Python, detengase y descubra c\u00f3mo hacerlo. Si est\u00e1 utilizando un IDE, es posible que est\u00e9 oculto detr\u00e1s de una opci\u00f3n de men\u00fa u otra ventana. Muchas partes de este curso asumen que puede interactuar con el int\u00e9rprete. Let's take a closer look at the elements of the REPL: >>> es el indicador del int\u00e9rprete para iniciar una nueva declaraci\u00f3n. ... es la indicaci\u00f3n del int\u00e9rprete para continuar una declaraci\u00f3n. Ingrese una l\u00ednea en blanco para terminar de escribir y ejecutar lo que ingres\u00f3. El mensaje ... puede aparecer o no seg\u00fan el entorno. Para este curso, se muestra como espacios en blanco para que sea m\u00e1s f\u00e1cil cortar / pegar muestras de c\u00f3digo. El gui\u00f3n bajo _ contiene el \u00faltimo resultado. >>> 37 * 42 1554 >>> _ * 2 3108 >>> _ + 50 3158 >>> Esto solo es cierto en el modo interactivo. Nunca uses _ en un programa.","title":"1.2.2: Modo interactivo"},{"location":"1/#123-creando-programas","text":"Los programas se colocan en archivos .py . # hola.py print('hola mundo') Puede crear estos archivos con su editor de texto favorito.","title":"1.2.3: Creando programas"},{"location":"1/#124-ejecutando-programas","text":"Para ejecutar un programa, ejec\u00fatelo en la terminal con el comando python. Por ejemplo, en la l\u00ednea de comandos Unix: $ python hola.py hola mundo $ O desde el shell de Windows: C:\\AlgunDirectorio>hola.py hello world C:\\AlgunDirectorio>c:\\python36\\python hola.py hello world Nota: en Windows, es posible que deba especificar una ruta completa al int\u00e9rprete de Python, como c:\\python36\\python . Sin embargo, si Python se instala de la forma habitual, es posible que pueda simplemente escribir el nombre del programa, como hola.py.","title":"1.2.4: Ejecutando programas"},{"location":"1/#125-un-ejemplo","text":"Resolvamos el siguiente problema: Una ma\u00f1ana, sales y colocas un billete de un d\u00f3lar en la acera de la torre Sears en Chicago. Cada d\u00eda a partir de entonces, sales y colocas el doble de billetes. \u00bfCu\u00e1nto tiempo tarda la pila de billetes en superar la altura de la torre? Una posible soluci\u00f3n: # sears.py billete_grosor = 0.11 * 0.001 # Metros (0.11 mm) sears_altura = 442 # Altura (metros) num_billetes = 1 dia = 1 while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 num_billetes = num_billetes * 2 print('N\u00famero de d\u00edas', dia) print('N\u00famero de facturas', num_billetes) print('Altura final', num_billetes * billete_grosor) Cuando lo ejecuta, obtiene el siguiente resultado: $ python3 sears.py 1 1 0.00011 2 2 0.00022 3 4 0.00044 4 8 0.00088 5 16 0.00176 6 32 0.00352 7 64 0.00704 8 128 0.01408 9 256 0.02816 10 512 0.05632 11 1024 0.11264 12 2048 0.22528 13 4096 0.45056 14 8192 0.90112 15 16384 1.80224 16 32768 3.60448 17 65536 7.20896 18 131072 14.41792 19 262144 28.83584 20 524288 57.67168 21 1048576 115.34336 22 2097152 230.68672 N\u00famero de d\u00edas 23 N\u00famero de facturas 4194304 Altura final 461.37344 Usando este programa como gu\u00eda, puede aprender una serie de conceptos b\u00e1sicos importantes sobre Python.","title":"1.2.5: Un ejemplo"},{"location":"1/#126-declaraciones","text":"Un programa de Python es una secuencia de declaraciones: a = 3 + 4 b = a * 2 print(b) Cada declaraci\u00f3n termina con una nueva l\u00ednea. Las sentencias se ejecutan una tras otra hasta que el control llega al final del archivo.","title":"1.2.6: Declaraciones"},{"location":"1/#127-comentarios","text":"Los comentarios son texto que no se ejecutar\u00e1. a = 3 + 4 # Esto es un comentario b = a * 2 print(b) Los comentarios se indican con # y se extienden hasta el final de la l\u00ednea.","title":"1.2.7: Comentarios"},{"location":"1/#128-variables","text":"Una variable es el nombre de un valor. Puede utilizar letras (min\u00fasculas y may\u00fasculas) de la a a la z, adem\u00e1s del car\u00e1cter subrayado _ . Los n\u00fameros tambi\u00e9n pueden formar parte del nombre de una variable, excepto como primer car\u00e1cter. altura = 442 # v\u00e1lido _height = 442 # v\u00e1lido altura2 = 442 # v\u00e1lido 2height = 442 # inv\u00e1lido","title":"1.2.8: Variables"},{"location":"1/#129-tipos","text":"Las variables no necesitan declararse con el tipo de valor. El tipo est\u00e1 asociado con el valor del lado derecho, no con el nombre de la variable. altura = 442 # Un n\u00famero entero altura = 442.0 # Punto flotante height = 'Muy alto' # Una cadena Python se escribe din\u00e1micamente. El \"tipo\" percibido de una variable puede cambiar a medida que se ejecuta un programa en funci\u00f3n del valor actual que se le asigna.","title":"1.2.9: Tipos"},{"location":"1/#1210-casos-sensitivos","text":"Python distingue entre may\u00fasculas y min\u00fasculas. Las letras may\u00fasculas y min\u00fasculas se consideran letras diferentes. Todas estas son variables diferentes: nombre = 'Jake' Nombre = 'Elwood' NOMBRE = 'Guido' Las declaraciones de idioma son siempre en min\u00fasculas. while x < 0: # OK WHILE x < 0: # ERROR","title":"1.2.10: Casos Sensitivos"},{"location":"1/#1211-ciclar","text":"La instrucci\u00f3n while ejecuta un ciclo. while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 num_billetes = num_billetes * 2 print('Numero de dias', dia) Las declaraciones con sangr\u00eda debajo del while se ejecutar\u00e1n siempre que la expresi\u00f3n posterior al while sea verdadera / cierta.","title":"1.2.11: Ciclar"},{"location":"1/#1212-sangrias-las-de-texto","text":"La sangr\u00eda se usa para denotar grupos de declaraciones que van juntas. Considere el ejemplo anterior: while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 num_billetes = num_billetes * 2 print('Numero de dias', dia) La sangr\u00eda agrupa las siguientes declaraciones juntas como las operaciones que se repiten: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 num_billetes = num_billetes * 2 Debido a que la instrucci\u00f3n print() al final no tiene sangr\u00eda, no pertenece al ciclo. La l\u00ednea vac\u00eda es solo para facilitar la lectura. No afecta la ejecuci\u00f3n.","title":"1.2.12: Sangr\u00edas (las de texto)"},{"location":"1/#sangrias-mejores-practicas","text":"Utilice espacios en lugar de tabulaciones. Utilice 4 espacios por nivel. Utilice un editor compatible con Python. El \u00fanico requisito de Python es que la sangr\u00eda dentro del mismo bloque sea consistente. Por ejemplo, esto es un error: while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dia + 1 # error num_billetes = num_billetes * 2","title":"Sangr\u00edas - Mejores pr\u00e1cticas"},{"location":"1/#1213-condicionales","text":"La instrucci\u00f3n if se usa para ejecutar un condicional: if a > b: print('Computadora dice no') else: print('Computadora dice si') Puede verificar m\u00faltiples condiciones agregando verificaciones adicionales usando elif. if a > b: print('Computadora dice no') elif a == b: print('Computadora dice si') else: print('Computadora dice quizas')","title":"1.2.13: Condicionales"},{"location":"1/#1214-imprimiendo","text":"La funci\u00f3n de impresi\u00f3n produce una sola l\u00ednea de texto con los valores pasados. print('\u00a1Hola mundo!') # Imprime el texto '\u00a1Hola mundo!' Puede utilizar variables. El texto impreso ser\u00e1 el valor de la variable, no el nombre. x = 100 print(x) # Imprime el texto '100' Si pasa m\u00e1s de un valor para imprimir, est\u00e1n separados por espacios. nombre = 'Jake' print('Mi nombre es', nombre) # Imprime el texto 'Mi nombre es Jake' print() siempre pone una nueva l\u00ednea al final. print('Hola') print('Mi nombre es', 'Jake') Esto imprime: shell Hola Mi nombre es Jake La nueva l\u00ednea adicional se puede suprimir: print('Hola', end = '') print('Mi nombre es', 'Jake') Este c\u00f3digo ahora se imprimir\u00e1: Hola mi nombre es Jake","title":"1.2.14: Imprimiendo"},{"location":"1/#1215-input-dato-de-entrada-de-usuario","text":"Para leer una l\u00ednea de entrada de usuario escrita, use la funci\u00f3n input() : nombre = input('Ingrese su nombre:') print('Tu nombre es', nombre) input imprime un mensaje al usuario y devuelve su respuesta. Esto es \u00fatil para programas peque\u00f1os, ejercicios de aprendizaje o depuraci\u00f3n simple. No se usa mucho para programas reales.","title":"1.2.15: Input (dato de entrada) de usuario"},{"location":"1/#1216-la-declaracion-pass","text":"Sometimes you need to specify an empty code block. The keyword pass is used for it. if a > b: pass else: print('Computer says false') This is also called a \"no-op\" statement. It does nothing. It serves as a placeholder for statements, possibly to be added later.","title":"1.2.16: La declaraci\u00f3n \"pass\""},{"location":"1/#1217-ejercicios","text":"Este es el primer conjunto de ejercicios en los que necesita crear archivos Python y ejecutarlos. A partir de este punto, se asume que est\u00e1 editando archivos en el directorio ./Work/ . Para ayudarle a localizar el lugar adecuado, se han creado varios archivos de inicio vac\u00edos con los nombres de archivo adecuados. Busque el archivo ./Work/rebote.py que se utiliz\u00f3 en el primer ejercicio. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.2.17: Ejercicios"},{"location":"1/#ejercicio-15-el-rebote","text":"Una pelota de goma se deja caer desde una altura de 100 metros y cada vez que golpea el suelo, rebota hasta 3/5 de la altura a la que cay\u00f3. Escriba un programa bounce.py que imprima una tabla que muestre la altura de los primeros 10 rebotes. Su programa deber\u00eda crear una tabla que se parezca a esto: 1 60,0 2 36,0 3 21.599999999999998 4 12.959999999999999 5 7.775999999999999 6 4.6655999999999995 7 2.7993599999999996 8 1,6796159999999998 9 1,0077695999999998 10 0.6046617599999998 Nota: Puede limpiar un poco la salida si usa la funci\u00f3n round() . Intente usarlo para redondear la salida a 4 d\u00edgitos. 1 60,0 2 36,0 3 21,6 4 12,96 5 7.776 6 4.6656 7 2.7994 8 1,6796 9 1.0078 10 0.6047","title":"Ejercicio 1.5: El rebote"},{"location":"1/#ejercicio-16-depuracion","text":"El siguiente fragmento de c\u00f3digo contiene c\u00f3digo del problema de la torre Sears. Tambi\u00e9n tiene un error. billete_grosor = 0.11 * 0.001 # Metros (0.11 mm) sears_altura = 442 # Altura (metros) num_billetes = 1 dia = 1 while num_billetes * billete_grosor < sears_altura: print(dia, num_billetes, num_billetes * billete_grosor) dia = dias + 1 num_billetes = num_billetes * 2 print ('N\u00famero de d\u00edas', dia) print ('N\u00famero de facturas', num_billetes) print ('Altura final', num_billetes * billete_grosor) Copie y pegue el c\u00f3digo que aparece arriba en un nuevo programa llamado sears.py . Cuando ejecute el c\u00f3digo, obtendr\u00e1 un mensaje de error que hace que el programa se bloquee de esta manera: Traceback (most recent call last): File \"sears.py\", line 10, in <module> day = dias + 1 NameError: name 'dias' is not defined Leer los mensajes de error es una parte importante del c\u00f3digo Python. Si su programa falla, la \u00faltima l\u00ednea del mensaje de rastreo es la raz\u00f3n real por la cual el programa falla. Por encima de eso, deber\u00eda ver un fragmento de c\u00f3digo fuente y luego un nombre de archivo de identificaci\u00f3n y un n\u00famero de l\u00ednea. \u00bfQu\u00e9 l\u00ednea es el error? Cual es el error? Arreglar el error Ejecute el programa con \u00e9xito","title":"Ejercicio 1.6: Depuraci\u00f3n"},{"location":"1/#13-numeros","text":"Esta secci\u00f3n discute sobre c\u00e1lculos matem\u00e1ticos. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.3 N\u00fameros"},{"location":"1/#131-tipos-de-numeros","text":"Python tiene 4 tipos de n\u00fameros: Booleanos Enteros Punto flotante Complejo (n\u00fameros imaginarios)","title":"1.3.1: Tipos de numeros"},{"location":"1/#132-booleanos-bool","text":"Los booleanos tienen dos valores: True , False . a = True b = False Num\u00e9ricamente, se eval\u00faan como n\u00fameros enteros con valor \"1\", \"0\". c = 4 + True # 5 d = False if d == 0: print('d is False') Pero no escriba c\u00f3digo como ese. Ser\u00eda extra\u00f1o. *","title":"1.3.2: Booleanos (bool)"},{"location":"1/#133-enteros-int","text":"Valores firmados de tama\u00f1o y base arbitraria: a = 37 b = -299392993727716627377128481812241231 c = 0x7fa8 # Hexadecimal d = 0o253 # Octal e = 0b10001111 # Binario Operaciones comunes: x + y Suma x - y Resta x * y Multiplicacion x / y Divisi\u00f3n (produce un flotante) x // y Divisi\u00f3n entera (produce un entero) x % y Modulo (devuelve el resto de la divisi\u00f3n) x ** y Potencia x << n Bit desplazamiento izquierda x >> n Bit desplazamiento derecha x & y Bit-wise AND x | y Bit-wise OR x ^ y Bit-wise XOR ~x Bit-wise NOT abs(x) Valor absoluto","title":"1.3.3: Enteros (int)"},{"location":"1/#134-punto-flotante-float","text":"Utilice una notaci\u00f3n decimal o exponencial para especificar un valor de coma flotante: a = 37.45 b = 4e5 # 4 x 10**5 or 400,000 c = -1.345e-10 Los flotantes se representan con precisi\u00f3n doble utilizando la representaci\u00f3n de CPU nativa IEEE 754 . Es lo mismo que el tipo \"doble\" en el lenguaje de programaci\u00f3n C. 17 d\u00edgitos de precisi\u00f3n Exponente de -308 a 308 Tenga en cuenta que los n\u00fameros de punto flotante son inexactos cuando representan decimales. >>> a = 2.1 + 4.2 >>> a == 6.3 False >>> a 6.300000000000001 >>> Esto no es un problema de Python , sino el hardware de punto flotante subyacente en la CPU. Operaciones comunes: x + y Suma x - y Resta x * y Multiplicacion x / y Division x // y Division entera x % y Modulo x ** y Potencia abs(x) Valor absoluto Estos son los mismos operadores que los enteros, excepto los operadores bit a bit. Las funciones matem\u00e1ticas adicionales se encuentran en el m\u00f3dulo math . import math a = math.sqrt(x) b = math.sin(x) c = math.cos(x) d = math.tan(x) e = math.log(x)","title":"1.3.4: Punto flotante (float)"},{"location":"1/#135-comparaciones","text":"Los siguientes operadores de comparaci\u00f3n / relacionales funcionan con n\u00fameros: x < y Menor x <= y Menor o igual x > y Mayor x >= y Mayor o igual x == y Igual x != y No es igual Puede formar expresiones booleanas m\u00e1s complejas usando and , or , not Aqu\u00ed est\u00e1n algunos ejemplos: if b >= a and b <= c: print('b est\u00e1 entre a y c') if not (b < a or b > c): print('b todav\u00eda est\u00e1 entre a y c')","title":"1.3.5: Comparaciones"},{"location":"1/#136-convirtiendo-numeros","text":"El nombre del tipo se puede utilizar para convertir valores: a = int(x) # Convierte x a entero b = float(x) # Convierte x a coma flotante Try it out. >>> a = 3.14159 >>> int(a) 3 >>> b = '3.14159' # Tambi\u00e9n funciona con cadenas de numeros >>> float(b) 3.14159 >>>","title":"1.3.6: Convirtiendo numeros"},{"location":"1/#137-ejercicios","text":"Recordatorio: Estos ejercicios asumen que est\u00e1 trabajando en el directorio /Work . Busque el archivo hipoteca.py .","title":"1.3.7: Ejercicios"},{"location":"1/#ejercicio-17-la-hipoteca-de-dave","text":"Dave ha decidido sacar una hipoteca de tasa fija a 30 a\u00f1os de $500,000 con el comercio de hipotecas, inversiones en acciones y Bitcoin de Guido corporaci\u00f3n. La tasa de inter\u00e9s es del 5% y el pago mensual es $2684,11 . Aqu\u00ed hay un programa que calcula la cantidad total que Dave tendr\u00e1 para pagar durante la vida de la hipoteca: # mortgage.py capital = 500000.0 tasa = 0.05 pago = 2684.11 total_pagado = 0.0 while capital > 0: capital = capital * (1 + tasa / 12) - pago total_pagado = total_pagado + pago print('Total pagado', total_pagado) Ingrese a este programa y ejec\u00fatelo. Deber\u00eda obtener una respuesta de \"966,279.6\".","title":"Ejercicio 1.7: La hipoteca de Dave"},{"location":"1/#ejercicio-18-pagos-adicionales","text":"Suponga que Dave paga $1000 adicionales al mes durante los primeros 12 meses de la hipoteca. Modifique el programa para incorporar este pago adicional y haga que imprima el monto total pagado junto con la cantidad de meses requeridos. Cuando ejecute el nuevo programa, deber\u00eda informar un pago total de 929,965.62 durante 342 meses.","title":"Ejercicio 1.8: Pagos adicionales"},{"location":"1/#ejercicio-19-hacer-una-calculadora-de-pago-adicional","text":"Modifique el programa para que la informaci\u00f3n de pago adicional pueda manejarse de manera m\u00e1s general. H\u00e1galo de modo que el usuario pueda configurar estas variables: extra_pago_inicio_mes = 61 extra_pago_fin_mes = 108 extra_pago = 1000 Haga que el programa mire estas variables y calcule el total pagado adecuadamente. \u00bfCu\u00e1nto pagar\u00e1 Dave si paga $1000 adicionales al mes durante 4 a\u00f1os a partir de la primera ya se han pagado cinco a\u00f1os?","title":"Ejercicio 1.9: Hacer una calculadora de pago adicional"},{"location":"1/#ejercicio-110-crear-una-tabla","text":"Modifique el programa para imprimir una tabla que muestre el mes, el total pagado hasta el momento y el capital restante. La salida deber\u00eda verse as\u00ed: 1 2684.11 499399.22 2 5368.22 498795.94 3 8052.33 498190.15 4 10736.44 497581.83 5 13420.55 496970.98 ... 308 874705.88 3478.83 309 877389,99 809,21 310 880074.1 -1871.53 Total pagado 880074,1 Meses 310","title":"Ejercicio 1.10: Crear una tabla"},{"location":"1/#ejercicio-111-bono","text":"Mientras lo hace, corrija el programa para corregir el pago en exceso que se produjo en el \u00faltimo mes.","title":"Ejercicio 1.11: Bono"},{"location":"1/#ejercicio-112-un-misterio","text":"int() y float() se pueden usar para convertir n\u00fameros. Por ejemplo: >>> int(\"123\") 123 >>> float(\"1.23\") 1.23 >>> Con eso en mente, \u00bfpuede explicar este comportamiento? >>> bool(\"False\") True >>>","title":"Ejercicio 1.12: Un misterio"},{"location":"1/#14-cadenas","text":"Esta secci\u00f3n presenta formas de trabajar con texto. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.4 Cadenas"},{"location":"1/#141-representando-texto-literal","text":"Los literales de cadena se escriben en programas con comillas. # Comillas simples a = 'S\u00ed, pero no, pero s\u00ed, pero ...' # Comillas dobles b = \"la computadora dice que no\" # Comillas triples c = ''' M\u00edrame a los ojos, m\u00edrame a los ojos, los ojos, los ojos, los ojos, no alrededor de los ojos, no mires alrededor de los ojos, m\u00edrame a los ojos, est\u00e1s debajo. ''' Normalmente, las cadenas solo pueden abarcar una sola l\u00ednea. Las comillas triples capturan todo el texto incluido en varias l\u00edneas incluido todo el formato. No hay diferencia entre usar simple (') versus doble (\") citas. Sin embargo, se debe utilizar el mismo tipo de cita que se utiliza para iniciar una cadena como para terminarla .","title":"1.4.1: Representando texto literal"},{"location":"1/#142-codigo-de-escape-de-cadenas","text":"Los c\u00f3digos de escape se utilizan para representar caracteres de control y caracteres que no se pueden escribir f\u00e1cilmente directamente en el teclado. A continuaci\u00f3n, se muestran algunos c\u00f3digos de escape comunes: '\\n' salto de l\u00ednea '\\r' Retorno de carro '\\t' Pesta\u00f1a '\\'' Literal comilla simple '\\' Literal comillas dobles '\\\\' Barra invertida literal","title":"1.4.2: C\u00f3digo de escape de cadenas"},{"location":"1/#143-representacion-de-cadenas","text":"Cada car\u00e1cter de una cadena se almacena internamente como un denominado \"punto de c\u00f3digo\" Unicode, que es un entero. Puede especificar un valor de punto de c\u00f3digo exacto mediante las siguientes secuencias de escape: a = '\\xf1' # a = '\u00f1' b = '\\u2200' # b = '\u2200' c = '\\U0001D122' # c = '\ud834\udd22' d = '\\N{FOR ALL}' # d = '\u2200' La [Base de datos de caracteres Unicode] (https://unicode.org/charts) es una referencia para todos los c\u00f3digos de caracteres disponibles.","title":"1.4.3: Representaci\u00f3n de cadenas"},{"location":"1/#144-indexacion-de-cadenas","text":"Las cadenas funcionan como una matriz para acceder a caracteres individuales. Utiliza un \u00edndice entero, comenzando en 0. Los \u00edndices negativos especifican una posici\u00f3n relativa al final de la cadena. a = 'Hello world' b = a[0] # 'H' c = a[4] # 'o' d = a[-1] # 'd' (final de la cadena) Tambi\u00e9n puede dividir o seleccionar subcadenas especificando un rango de \u00edndices con : . d = a[:5] # 'Hello' e = a[6:] # 'world' f = a[3:8] # 'lo wo' g = a[-5:] # 'world' El car\u00e1cter del \u00edndice final no est\u00e1 incluido. Los \u00edndices que faltan asumen el principio o el final de la cadena.","title":"1.4.4: Indexaci\u00f3n de cadenas"},{"location":"1/#145-operaciones-de-cadena","text":"Concatenaci\u00f3n, tama\u00f1o, pertenencia y replicaci\u00f3n. # concatenaci\u00f3n (+) a = 'Hello' + 'World' # 'HelloWorld' b = 'Say ' + a # 'Say HelloWorld' # tama\u00f1o (len) s = 'Hello' len(s) # 5 # prueba de pertenencia (`in`, `not in`) t = 'e' in s # True f = 'x' in s # False g = 'hi' not in s # True # replicaci\u00f3n (s * n) rep = s * 5 # 'HelloHelloHelloHelloHello'","title":"1.4.5: Operaciones de cadena"},{"location":"1/#146-metodos-de-cadena","text":"Las cadenas tienen m\u00e9todos que realizan varias operaciones con los datos de la cadena. Ejemplo: eliminar cualquier espacio en blanco inicial / final. s = ' Hello ' t = s.strip() # 'Hello' Ejemplo: conversi\u00f3n de casos. s = 'Hello' l = s.lower() # 'hello' u = s.upper() # 'HELLO' Ejemplo: Reemplazo de texto. s = 'Hello world' t = s.replace('Hello' , 'Hallo') # 'Hallo world'","title":"1.4.6: Metodos de cadena"},{"location":"1/#otros-metodos-de-cadena","text":"Las cadenas tienen una amplia variedad de otros m\u00e9todos para probar y manipular los datos de texto. Esta es una peque\u00f1a muestra de m\u00e9todos: s.endswith(sufijo) # Compruebe si la cadena termina con sufijo s.find(t) # Primera aparici\u00f3n de t en s s.index(t) # Primera aparici\u00f3n de t en s s.isalpha() # Comprueba si los caracteres son alfab\u00e9ticos s.isdigit() # Comprueba si los caracteres son num\u00e9ricos s.islower() # Comprueba si los caracteres son min\u00fasculas s.isupper() # Comprueba si los caracteres est\u00e1n en may\u00fasculas s.join(slist) # \u00danase a una lista de cadenas usando s como delimitador s.lower() # Convertir a min\u00fasculas s.replace(antiguo, nuevo) # Reemplazar texto s.rfind(t) # Busca t desde el final de la cadena s.rindex(t) # Busca t desde el final de la cadena s.split([delim]) # Dividir cadena en lista de subcadenas s.startswith(prefix) # Compruebe si la cadena comienza con prefijo s.strip() # Franja el espacio inicial / final s.upper() # Convertir a may\u00fasculas","title":"Otros metodos de cadena"},{"location":"1/#147-mutabilidad-de-cadenas","text":"Las cadenas son \"inmutables\" o de solo lectura. Una vez creado, el valor no se puede cambiar. >>> s = 'Hello World' >>> s[1] = 'a' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>> Todas las operaciones y m\u00e9todos que manipulan datos de cadenas, siempre crean cadenas nuevas.","title":"1.4.7: Mutabilidad de cadenas"},{"location":"1/#148-conversiones-de-cadena","text":"Utilice str () para convertir cualquier valor en una cadena. El resultado es una cadena que sostiene el mismo texto que habr\u00eda sido producido por la declaraci\u00f3n print () . >>> x = 42 >>> str(x) '42' >>>","title":"1.4.8: Conversiones de cadena"},{"location":"1/#149-cadenas-byte","text":"Una cadena de bytes de 8 bits, que se encuentra com\u00fanmente con I/O de bajo nivel, se escribe de la siguiente manera: data = b'Hola Mundo\\r\\n' Al poner una b peque\u00f1a antes de la primera cita, especificas que es una cadena de bytes en lugar de una cadena de texto. La mayor\u00eda de las operaciones habituales con cadenas funcionan. len(data) # 13 data[0:5] # b'Hola' data.replace(b'Hello', b'Cruel') # b'Cruel Mundo\\r\\n' La indexaci\u00f3n es un poco diferente porque devuelve valores de bytes como n\u00fameros enteros. data[0] # 72 (ASCII code for 'H') Conversion to/from text strings. text = data.decode('utf-8') # bytes -> texto data = text.encode('utf-8') # texto -> bytes El argumento 'utf-8' especifica una codificaci\u00f3n de caracteres. Otros comunes los valores incluyen 'ascii' y ' latin1' .","title":"1.4.9: Cadenas byte"},{"location":"1/#1410-cadenas-crudas","text":"Las cadenas sin formato son literales de cadena con una barra invertida no interpretada. Se especifican anteponiendo la cita inicial con una \"r\" min\u00fascula. >>> rs = r'c:\\newdata\\test' # Sin formato (barra invertida no interpretada) >>> rs 'c:\\\\newdata\\\\test' La cadena es el texto literal incluido adentro, exactamente como se escribe. Esto es \u00fatil en situaciones en las que la barra invertida tiene significado. Ejemplo: nombre de archivo, expresiones regulares, etc.","title":"1.4.10: Cadenas crudas"},{"location":"1/#1411-cadenas-f","text":"Una cadena con sustituci\u00f3n de expresi\u00f3n formateada. >>> nombre = 'IBM' >>> acciones = 100 >>> precio = 91.1 >>> a = f'{nombre:>10s} {acciones:10d} {precio:10.2f}' >>> a ' IBM 100 91.10' >>> b = f'Costo = ${acciones * precio:0.2f}' >>> b 'Costo = $9110.00' >>> Nota: Esto requiere Python 3.6 o m\u00e1s reciente. El significado de los c\u00f3digos de formato se explica m\u00e1s adelante.","title":"1.4.11: Cadenas f"},{"location":"1/#1412-ejercicios","text":"En estos ejercicios, experimentar\u00e1 con operaciones en Python tipo de cadena. Debe hacer esto en el indicador interactivo de Python donde puede ver f\u00e1cilmente los resultados. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Nota IMPORTANTE: En los ejercicios en los que se supone que debe interactuar con el int\u00e9rprete, >>> es el indicador del int\u00e9rprete que obtienes cuando Python quiere que escriba una nueva declaraci\u00f3n. Algunas declaraciones en el per\u00edodo de ejercicios varias l\u00edneas: para que se ejecuten estas declaraciones, es posible que deba presionar 'volver' unas cuantas veces. Solo un recordatorio de que * NO * escribe el >>> al trabajar con estos ejemplos. Empiece por definir una cadena que contenga una serie de s\u00edmbolos de cotizaci\u00f3n burs\u00e1til como este: >>> symbols = 'AAPL,IBM,MSFT,YHOO,SCO' >>>","title":"1.4.12: Ejercicios"},{"location":"1/#ejercicio-113-extraccion-de-caracteres-individuales-y-subcadenas","text":"Las cadenas son matrices de caracteres. Intente extraer algunos caracteres: >>> symbols[0] ? >>> symbols[1] ? >>> symbols[2] ? >>> symbols[-1] # Ultimo caracter ? >>> symbols[-2] # Indices negativos son desde el final ? >>> En Python, las cadenas son de solo lectura. Verifique esto intentando cambiar el primer car\u00e1cter de symbols a una min\u00fascula 'a'. >>> symbols[0] = 'a' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>>","title":"Ejercicio 1.13: Extracci\u00f3n de caracteres individuales y subcadenas"},{"location":"1/#ejercicio-114-concatenacion-de-caracteres","text":"Although string data is read-only, you can always reassign a variable to a newly created string. Try the following statement which concatenates a new symbol \"GOOG\" to the end of symbols : >>> symbols = symbols + 'GOOG' >>> symbols 'AAPL,IBM,MSFT,YHOO,SCOGOOG' >>> \u00a1Ups! Eso no es lo que quer\u00edas. Corr\u00edjelo para que la variable symbols contenga el valor 'AAPL, IBM, MSFT, YHOO, SCO, GOOG' . >>> symbols = ? >>> symbols 'AAPL,IBM,MSFT,YHOO,SCO,GOOG' >>> Agregue 'HPQ' al frente de la cuerda >>> symbols = ? >>> symbols 'HPQ,AAPL,IBM,MSFT,YHOO,SCO,GOOG' >>> En estos ejemplos, puede parecer que la cadena original est\u00e1 siendo modificado, en una aparente violaci\u00f3n de que las cadenas sean de solo lectura. No entonces. Las operaciones en cadenas crean una cadena completamente nueva cada una hora. Cuando se reasigna el nombre de la variable s\u00edmbolos , apunta al cadena reci\u00e9n creada. Posteriormente, la cuerda vieja se destruye ya que ya no se usa.","title":"Ejercicio 1.14: Concatenaci\u00f3n de caracteres"},{"location":"1/#ejercicio-115-pruebas-de-membresia","text":"Experimente con el operador \"in\" para buscar subcadenas. En el mensaje interactivo, pruebe estas operaciones: >>> 'IBM' in symbols ? >>> 'AA' in symbols True >>> 'CAT' in symbols ? >>> \u00bfPor qu\u00e9 la comprobaci\u00f3n de 'AA' devolvi\u00f3 True ?","title":"Ejercicio 1.15: Pruebas de membres\u00eda"},{"location":"1/#ejercicio-116-metodos-de-cadenas","text":"En el indicador interactivo de Python, intente experimentar con algunos de los m\u00e9todos de cadena. >>> symbols.lower() ? >>> symbols ? >>> Recuerde, las cadenas siempre son de solo lectura. Si desea guardar el resultado de una operaci\u00f3n, debe colocarlo en una variable: >>> lowersyms = symbols.lower() >>> Pruebe algunas operaciones m\u00e1s: >>> symbols.find('MSFT') ? >>> symbols[13:17] ? >>> symbols = symbols.replace('SCO','DOA') >>> symbols ? >>> name = ' IBM \\n' >>> name = name.strip() # Remove surrounding whitespace >>> name ? >>>","title":"Ejercicio 1.16: M\u00e9todos de cadenas"},{"location":"1/#ejercicio-117-f-strings","text":"A veces desea crear una cadena e incrustar los valores de variables en \u00e9l. Para hacer eso, use una f-string. Por ejemplo: >>> nombre = 'IBM' >>> acciones = 100 >>> precio = 91.1 >>> f'{acciones} acciones de {nombre} a ${precio:0.2f}' '100 acciones de IBM a $91.10' >>> Modifique el programa de hipoteca Dave mortgage.py del Ejercicio 1.10 para crear su salida usando f-strings. Intente hacer que la salida est\u00e9 bien alineada.","title":"Ejercicio 1.17: f-strings"},{"location":"1/#ejercicio-118-expresiones-regulares","text":"Una limitaci\u00f3n de las operaciones b\u00e1sicas con cadenas es que no admite cualquier tipo de coincidencia de patrones avanzada. Por eso tu Necesito recurrir al m\u00f3dulo re y las expresiones regulares de Python. El manejo de expresiones regulares es un gran tema, pero aqu\u00ed hay un breve ejemplo: >>> text = 'Today is 3/27/2018. Tomorrow is 3/28/2018.' >>> # Find all occurrences of a date >>> import re >>> re.findall(r'\\d+/\\d+/\\d+', text) ['3/27/2018', '3/28/2018'] >>> # Replace all occurrences of a date with replacement text >>> re.sub(r'(\\d+)/(\\d+)/(\\d+)', r'\\3-\\1-\\2', text) 'Today is 2018-3-27. Tomorrow is 2018-3-28.' >>> Para obtener m\u00e1s informaci\u00f3n sobre el m\u00f3dulo re , consulte la documentaci\u00f3n oficial en https://docs.python.org/library/re.html .","title":"Ejercicio 1.18: Expresiones regulares"},{"location":"1/#algunos-comentarios","text":"A medida que comienza a experimentar con el int\u00e9rprete, a menudo desea conocer m\u00e1s sobre las operaciones soportadas por diferentes objetos. Por ejemplo, \u00bfc\u00f3mo averigua qu\u00e9 operaciones est\u00e1n disponibles en un cadena? Dependiendo de su entorno de Python, es posible que pueda ver una lista de los m\u00e9todos disponibles mediante el completado con tabulaci\u00f3n. Por ejemplo, intente escribir esta: >>> s = 'hello world' >>> s.<tab key> >>> Si presionar tab no hace nada, puede volver al funci\u00f3n incorporada dir() . Por ejemplo: >>> s = 'hello' >>> dir(s) ['__add__', '__class__', '__contains__', ..., 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] >>> dir() produce una lista de todas las operaciones que pueden aparecer despu\u00e9s de (.) . Utilice el comando help() para obtener m\u00e1s informaci\u00f3n sobre una operaci\u00f3n espec\u00edfica: >>> help(s.upper) Help on built-in function upper: upper(...) S.upper() -> string Return a copy of the string S converted to uppercase. >>>","title":"Algunos comentarios"},{"location":"1/#15-listas","text":"Esta secci\u00f3n presenta listas, el tipo principal de Python para contener una colecci\u00f3n ordenada de valores. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.5 Listas"},{"location":"1/#151-creando-una-lista","text":"Utilice corchetes para definir un literal de lista: nombres = [ 'Elwood', 'Jake', 'Curtis' ] numeros = [39, 38, 42, 65, 111] En ocasiones las listas son creadas por otros metodos. Por ejemplo, una cadena puede ser dividida haciendo uso del m\u00e9todo split() . >>> linea = 'GOOG,100,490.10' >>> fila = line.split(',') >>> fila ['GOOG', '100', '490.10'] >>>","title":"1.5.1: Creando una lista"},{"location":"1/#152-operaciones-de-lista","text":"Las listas pueden contener elementos de cualquier tipo. Agregue un nuevo elemento usando append() : nombres.append('Murphy') # Agrega al final nombres.insert(2, 'Aretha') # Inserta en el medio Use + para concatenar listas: s = [1, 2, 3] t = ['a', 'b'] s + t # [1, 2, 3, 'a', 'b'] Las listas est\u00e1n indexadas por n\u00fameros enteros. A partir de 0. nombres = [ 'Elwood', 'Jake', 'Curtis' ] nombres[0] # 'Elwood' nombres[1] # 'Jake' nombres[2] # 'Curtis' Los \u00edndices negativos cuentan desde el final. nombres[-1] # 'Curtis' Puede cambiar cualquier elemento de una lista. nombres[1] = 'Joliet Jake' nombres # [ 'Elwood', 'Joliet Jake', 'Curtis' ] Length of the list. nombres = ['Elwood','Jake','Curtis'] len(nombres) # 3 Prueba de pertenencia ( in , not in ) 'Elwood' in nombres # True 'Britney' not in nombres # True Replicaci\u00f3n ( s * n ). s = [1, 2, 3] s * 3 # [1, 2, 3, 1, 2, 3, 1, 2, 3]","title":"1.5.2: Operaciones de lista"},{"location":"1/#153-iteracion-de-lista-y-busqueda","text":"Utilice for para iterar sobre el contenido de la lista. for nombre in nombres: # use nombre # e.g. print(nombre) ... Esto es similar a una declaraci\u00f3n foreach de otros lenguajes de programaci\u00f3n. Para encontrar la posici\u00f3n de algo r\u00e1pidamente, use index() . nombres = ['Elwood','Jake','Curtis'] nombres.index('Curtis') # 2 Si el elemento est\u00e1 presente m\u00e1s de una vez, index() devolver\u00e1 el \u00edndice de la primera aparici\u00f3n. Si el elemento no se encuentra, generar\u00e1 una excepci\u00f3n \"ValueError\".","title":"1.5.3: Iteracion de lista y b\u00fasqueda"},{"location":"1/#154-remocion-en-lista","text":"Puede eliminar elementos por valor de elemento o por \u00edndice: # Using the value nombres.remove('Curtis') # Using the index del nombres[1] Eliminar un art\u00edculo no crea un agujero. Otros elementos se mover\u00e1n hacia abajo para llenar el espacio desocupado. Si hay m\u00e1s de una aparici\u00f3n del elemento, remove() eliminar\u00e1 solo la primera aparici\u00f3n.","title":"1.5.4: Remoci\u00f3n en lista"},{"location":"1/#155-ordenar-una-lista","text":"Las listas se pueden ordenar \"in situ\". s = [10, 1, 7, 3] s.sort() # [1, 3, 7, 10] # Reverse order s = [10, 1, 7, 3] s.sort(reverse=True) # [10, 7, 3, 1] # It works with any ordered data s = ['foo', 'bar', 'spam'] s.sort() # ['bar', 'foo', 'spam'] Utilice sorted() si desea crear una nueva lista en su lugar: t = sorted(s) # s sin cambios, t tiene los valores ordenados","title":"1.5.5: Ordenar una lista"},{"location":"1/#156-listas-y-matematicas","text":"Caution: Lists were not designed for math operations. >>> nombres = [1, 2, 3, 4, 5] >>> nombres * 2 [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] >>> nombres + [10, 11, 12, 13, 14] [1, 2, 3, 4, 5, 10, 11, 12, 13, 14] Espec\u00edficamente, las listas no representan vectores/matrices como en MATLAB, Octave, R, etc. Sin embargo, existen algunos m\u00f3dulos/paquetes/librer\u00edas que le ayudan con eso (e.g. numpy )","title":"1.5.6: Listas y matem\u00e1ticas"},{"location":"1/#157-ejercicios","text":"En este ejercicio, experimentaremos con listas. En la ultima secci\u00f3n trabajamos con cadenas conteniendo s\u00edmbolos de acciones de bolsa valores. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador >>> symbols = 'HPQ,AAPL,IBM,MSFT,YHOO,DOA,GOOG' Divida la cadena en una lista de nombres haciendo uso de la operacion split() de cadenas: >>> symlist = symbols.split(',')","title":"1.5.7: Ejercicios"},{"location":"1/#ejercicio-119-extraccion-y-reasignacion-de-elementos","text":"Pruebe algunas busquedas: >>> symlist[0] 'HPQ' >>> symlist[1] 'AAPL' >>> symlist[-1] 'GOOG' >>> symlist[-2] 'DOA' >>> Intente reasignar un valor: >>> symlist[2] = 'AIG' >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'DOA', 'GOOG'] >>> Agarre unos pedazos: >>> symlist[0:3] ['HPQ', 'AAPL', 'AIG'] >>> symlist[-2:] ['DOA', 'GOOG'] Crea una lista vac\u00eda y agregue un elemento. >>> mysyms = [] >>> mysyms.append('GOOG') >>> mysyms ['GOOG'] Puede reasignar una porci\u00f3n de la lista a otra lista. Por ejemplo: >>> symlist[-2:] = mysyms >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG'] >>> Cuando hace esto, la lista en el lado izquierdo ( symlist ) ser\u00e1 reajustada apropiadamente para que el lado derecho ( mysyms ) ocupe un puesto en ella.","title":"Ejercicio 1.19: Extracci\u00f3n y reasignaci\u00f3n de elementos"},{"location":"1/#ejercicio-120-ciclando-sobre-una-lista","text":"El ciclo/bucle for funciona ciclando sobre data en una secuencia la lista. Pruebe lo siguiente: >>> for s in symlist: ... print('s =', s)","title":"Ejercicio 1.20: Ciclando sobre una lista"},{"location":"1/#ejercicio-121-pruebas-de-pertenencia","text":"Utilice el operador in o not in para comprobar si 'AIG' , 'AA' y 'CAT' est\u00e1n en la lista de s\u00edmbolos. >>> # Est\u00e1 'AIG' en `symlist`? True >>> # Est\u00e1 'AA' en `symlist`? False >>> # 'CAT' no esta en `symlist`? True >>>","title":"Ejercicio 1.21: Pruebas de pertenencia"},{"location":"1/#ejercicio-122-anadiendo-insertando-y-borrando-elementos","text":"Utilice el m\u00e9todo append() para agregar el s\u00edmbolo 'RHT' al final de symlist . >>> # agregue 'RHT' >>> symlist ['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT'] >>> Utilice el m\u00e9todo insert() para insertar el s\u00edmbolo 'AA' como el segundo elemento de la lista. >>> # Agregue 'AA' como segundo item en la lista >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT'] >>> Utilice el m\u00e9todo remove() para eliminar 'MSFT' de la lista. >>> # Remueva 'MSFT' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT'] >>> A\u00f1ada una entrada duplicada para 'YHOO' al final de la lista. Nota: est\u00e1 perfectamente bien si una lista tenga valores duplicados. >>> # Append 'YHOO' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT', 'YHOO'] >>> Utilice el m\u00e9todo index() para encontrar la primera posici\u00f3n de 'YHOO' en la lista. >>> # Encuentre el primer \u00edndice de 'YHOO' 4 >>> symlist[4] 'YHOO' >>> Cuente cu\u00e1ntas veces 'YHOO' est\u00e1 en la lista: >>> symlist.count('YHOO') 2 >>> Remueva la primera ocurrencia de 'YHOO' . >>> # Remueva primera ocurrencia de 'YHOO' >>> symlist ['HPQ', 'AA', 'AAPL', 'AIG', 'GOOG', 'RHT', 'YHOO'] >>> Para su informaci\u00f3n, no existe ning\u00fan m\u00e9todo para buscar o eliminar todas las apariciones de un elemento Sin embargo, veremos una forma elegante de hacer esto en la secci\u00f3n 2.","title":"Ejercicio 1.22: A\u00f1adiendo, insertando y borrando elementos"},{"location":"1/#ejercicio-123-ordernando","text":"\u00bfQuieres ordenar una lista? Utilice el m\u00e9todo sort() . Pru\u00e9balo: >>> symlist.sort() >>> symlist ['AA', 'AAPL', 'AIG', 'GOOG', 'HPQ', 'RHT', 'YHOO'] >>> \u00bfQuiere ordenar al rev\u00e9s? Prueba esto: >>> symlist.sort(reverse=True) >>> symlist ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'] >>> Nota: ordenar una lista modifica su contenido \"en el lugar\". Es decir, los elementos de la lista se mezclan, pero no se crea una nueva lista como resultado.","title":"Ejercicio 1.23: Ordernando"},{"location":"1/#ejercicio-124-ajuntando-todo-nuevamente","text":"\u00bfQuiere tomar una lista de cadenas y unirlas en una sola cadena? Utilice el m\u00e9todo join () de cadenas como esta (nota: esto se ve gracioso al principio). >>> a = ','.join(symlist) >>> a 'YHOO,RHT,HPQ,GOOG,AIG,AAPL,AA' >>> b = ':'.join(symlist) >>> b 'YHOO:RHT:HPQ:GOOG:AIG:AAPL:AA' >>> c = ''.join(symlist) >>> c 'YHOORHTHPQGOOGAIGAAPLAA' >>>","title":"Ejercicio 1.24: Ajuntando todo nuevamente"},{"location":"1/#ejercicio-125-listas-de-cualquier-cosa","text":"Las listas pueden contener cualquier tipo de objeto, incluidas otras listas (por ejemplo, listas anidadas). Probar esto: >>> nums = [101, 102, 103] >>> items = ['spam', symlist, nums] >>> items ['spam', ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'], [101, 102, 103]] Preste mucha atenci\u00f3n a la salida anterior. items es una lista con tres elementos. El primer elemento es una cadena, pero los otros dos elementos son listas. Puede acceder a los elementos de las listas anidadas mediante varias operaciones de indexaci\u00f3n. >>> items[0] 'spam' >>> items[0][0] 's' >>> items[1] ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'] >>> items[1][1] 'RHT' >>> items[1][1][2] 'T' >>> items[2] [101, 102, 103] >>> items[2][1] 102 >>> Aunque t\u00e9cnicamente es posible hacer estructuras muy complicadas compuestas por listas, como regla general, es preferible mantener las cosas simples. Por lo general, las listas contienen elementos que tienen el mismo tipo de valor. Por ejemplo, una lista que consta completamente de n\u00fameros o una lista de texto de cadena. Mezclar diferentes tipos de datos en la misma lista es a menudo un buen dolor de cabeza, por lo que es mejor evitarlo.","title":"Ejercicio 1.25: Listas de cualquier cosa"},{"location":"1/#16-archivos","text":"La mayor\u00eda de los programas necesitan leer la entrada de alg\u00fan lugar. Esta secci\u00f3n discute sobre el acceso a archivos. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.6 Archivos"},{"location":"1/#161-entrada-y-salida-de-un-archivo","text":"Abre un archivo. f = open('foo.txt', 'rt') # Open for reading (text) g = open('bar.txt', 'wt') # Open for writing (text) Lee toda la data. data = f.read() data = f.read([maxbytes]) # Read only up to 'maxbytes' bytes Escribe algo de texto. g.write('some text') Cierra cuando terminas. f.close() g.close() Files should be properly closed and it's an easy step to forget. Thus, the preferred approach is to use the with statement like this. with open(filename, 'rt') as file: # Haz uso del archivo \"file\" ... # No hay necesidad de cerrar expl\u00edcitamente ...statements Esto cierra autom\u00e1ticamente el archivo cuando el control abandona el bloque de c\u00f3digo con sangr\u00eda.","title":"1.6.1: Entrada y Salida de un Archivo"},{"location":"1/#162-patrones-comunes-de-lectura-de-archivos","text":"Leer un archivo completo de una vez como una cadena. with open('foo.txt', 'rt') as file: data = file.read() # `data` is a string with all the text in `foo.txt` Leer un archivo l\u00ednea por l\u00ednea iterando. with open(filename, 'rt') as file: for line in file: # Process the line","title":"1.6.2: Patrones comunes de lectura de archivos"},{"location":"1/#163-patrones-comunes-de-escritura-de-archivos","text":"Escribe data en cadena. with open('outfile', 'wt') as out: out.write('Hello World\\n') ... Redireccionando la funci\u00f3n de impresi\u00f3n. with open('outfile', 'wt') as out: print('Hola Mundo', file=out) ...","title":"1.6.3: Patrones comunes de escritura de archivos"},{"location":"1/#164-ejercicios","text":"Estos ejercicios dependen de un archivo Data/portfolio.csv . El archivo contiene una lista de l\u00edneas con informaci\u00f3n sobre una cartera de acciones. Se supone que est\u00e1 trabajando en el archivo ./Work/ directorio. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.6.4: Ejercicios"},{"location":"1/#126-prerequisitos","text":"Primero, intente leer todo el archivo a la vez en una cadena grande: >>> with open('Data/portfolio.csv', 'rt') as f: data = f.read() >>> data 'name,shares,price\\n\"AA\",100,32.20\\n\"IBM\",50,91.10\\n\"CAT\",150,83.44\\n\"MSFT\",200,51.23\\n\"GE\",95,40.37\\n\"MSFT\",50,65.10\\n\"IBM\",100,70.44\\n' >>> print(data) name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 \"CAT\",150,83.44 \"MSFT\",200,51.23 \"GE\",95,40.37 \"MSFT\",50,65.10 \"IBM\",100,70.44 >>> En el ejemplo anterior, cabe se\u00f1alar que Python tiene dos modos de salida. En el primer modo, donde aparece \">>> data\" en el indicador, Python muestra la representaci\u00f3n de la cadena sin procesar, incluidas las comillas y c\u00f3digos de escape. Cuando escribe print(data) , obtiene el formato real de salida de la cadena. Para leer un archivo l\u00ednea por l\u00ednea, use un bucle for como \u00e9ste: >>> with open('Data/portfolio.csv', 'rt') as f: for line in f: print(line, end='') name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 ... >>> En determinadas ocasiones, es posible que desee leer u omitir manualmente una \u00fanica l\u00ednea de texto (por ejemplo, tal vez desee omitir la primera l\u00ednea de los encabezados de columna). >>> f = open('Data/portfolio.csv', 'rt') >>> headers = next(f) >>> headers 'name,shares,price\\n' >>> for line in f: print(line, end='') \"AA\",100,32.20 \"IBM\",50,91.10 ... >>> f.close() >>> next() devuelve la siguiente l\u00ednea de texto en el archivo. Si lo llamara repetidamente, obtendr\u00eda l\u00edneas sucesivas. Sin embargo, para que lo sepa, el ciclo for hace uso de next() para obtener sus datos. Por lo tanto, normalmente no lo llamar\u00eda directamente a menos que est\u00e9 tratando de omitir o leer expl\u00edcitamente una sola l\u00ednea como se muestra. Una vez que est\u00e9 leyendo las l\u00edneas de un archivo, puede comenzar a realizar m\u00e1s procesamiento, como dividir. Por ejemplo, intente esto: >>> f = open('Data/portfolio.csv', 'rt') >>> headers = next(f).split(',') >>> headers ['name', 'shares', 'price\\n'] >>> for line in f: row = line.split(',') print(row) ['\"AA\"', '100', '32.20\\n'] ['\"IBM\"', '50', '91.10\\n'] ... >>> f.close() Nota: En estos ejemplos, f.close() se llama expl\u00edcitamente porque no se utiliza la instrucci\u00f3n with .","title":"1.26: Prerequisitos"},{"location":"1/#ejercicio-127-leyendo-de-un-archivo","text":"Ahora que sabe c\u00f3mo leer un archivo, escribamos un programa para realizar un c\u00e1lculo. Las columnas de portfolio.csv corresponden al nombre de la acci\u00f3n, n\u00famero de acciones, y precio de compra de una sola participaci\u00f3n accionaria. Escribe un programa llamado pcost.py que abre este archivo, lee todas las l\u00edneas y calcula cu\u00e1nto cost\u00f3 comprar todas las acciones en la cartera (portfolio). Sugerencia: para convertir una cadena en un entero, use int(s) . Para convertir una cadena en punto flotante, use float(s) . Su programa deber\u00eda imprimir un resultado como el siguiente: Costo total 44671.15","title":"Ejercicio 1.27: Leyendo de un archivo"},{"location":"1/#ejercicio-128-otro-tipo-de-archivos","text":"\u00bfY si quisiera leer un archivo que no es de texto, como un archivo comprimido gzip? La funci\u00f3n integrada open() no le ayudar\u00e1 aqu\u00ed, pero Python tiene un m\u00f3dulo gzip que puede leer archivos comprimidos gzip. >>> import gzip >>> with gzip.open('Data/portfolio.csv.gz', 'rt') as f: for line in f: print(line, end='') ... mira la salida ... >>> Nota: Incluir el modo de archivo de 'rt' es fundamental aqu\u00ed. Si olvidas eso obtendr\u00e1 cadenas de bytes en lugar de cadenas de texto normales.","title":"Ejercicio 1.28: Otro tipo de \"archivos\""},{"location":"1/#algunos-comentarios_1","text":"Los cient\u00edficos de datos se apresuran a se\u00f1alar que librerias como Pandas ya tienen una funci\u00f3n para leer archivos CSV. Esto es cierto y funciona bastante bien. Sin embargo, este no es un curso sobre c\u00f3mo aprender pandas. Leer archivos es un problema m\u00e1s general que las espec\u00edficaciones de archivos CSV. La raz\u00f3n principal por la que trabajamos con un archivo CSV es porque es un formato conocido para la mayor\u00eda de los programadores y es relativamente f\u00e1cil trabajarlo directamente - ilustrando muchas caracter\u00edsticas de Python en el proceso. Entonces, por supuesto, use Pandas cuando regrese al trabajo. Para el resto de este curso, sin embargo, vamos a seguir con la funcionalidad est\u00e1ndar de Python.","title":"Algunos comentarios"},{"location":"1/#17-funciones","text":"A medida que sus programas comiencen a crecer, va a querer organizarse. Esta secci\u00f3n presenta brevemente las funciones y los m\u00f3dulos de la biblioteca est\u00e1ndar. Tambi\u00e9n se introduce el manejo de errores con excepciones. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.7 Funciones"},{"location":"1/#171-funciones-personalizadas","text":"Utilice funciones para el c\u00f3digo que desea reutilizar. Aqu\u00ed hay una definici\u00f3n de funci\u00f3n: def sumcount(n): ''' Retorna la suma de los primeros n enteros ''' total = 0 while n > 0: total += n n -= 1 return total Para llamar una funci\u00f3n. a = sumcount(100) Una funci\u00f3n es una serie de declaraciones que realizan alguna tarea y devuelven un resultado. La palabra clave return es necesaria para especificar expl\u00edcitamente el valor de retorno de la funci\u00f3n.","title":"1.7.1: Funciones personalizadas"},{"location":"1/#172-funciones-de-biblioteca","text":"Python viene con una gran biblioteca est\u00e1ndar. Se accede a los m\u00f3dulos de la biblioteca usando import . Por ejemplo: import math x = math.sqrt(10) import urllib.request u = urllib.request.urlopen('http://www.python.org/') data = u.read() Cubriremos bibliotecas y m\u00f3dulos con m\u00e1s detalle m\u00e1s adelante.","title":"1.7.2: Funciones de biblioteca"},{"location":"1/#173-errores-y-excepciones","text":"Las funciones informan sobre errores como las excepciones. Una excepci\u00f3n provoca la interrupci\u00f3n de una funci\u00f3n y puede hacer que todo el programa se detenga si no se maneja. Prueba esto en tu REPL (read/lee, evaluate/evalua, print/imprime, cicla/loop) de Python. >>> int('N/A') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: invalid literal for int() with base 10: 'N/A' >>> Para fines de depuraci\u00f3n, el mensaje describe lo que sucedi\u00f3, d\u00f3nde ocurri\u00f3 el error, y un rastreo que muestra las otras llamadas a funciones que provocaron la falla.","title":"1.7.3: Errores y excepciones"},{"location":"1/#174-atrapando-y-gestionando-excepciones","text":"Las excepciones de pueden atrapar y gestionar. Para atrapar, use la declaraci\u00f3n try - except . for linea in f: campos = linea.split() try: acciones = int(campos[1]) except ValueError: print(\"No se pudo analizar\", linea) ... El nombre \"ValueError\" debe coincidir con el tipo de error que est\u00e1 intentando detectar. A menudo es dif\u00edcil saber exactamente qu\u00e9 tipo de errores pueden ocurrir de antemano dependiendo de la operaci\u00f3n que se est\u00e9 realizando. Para mejor o para peor, el manejo de excepciones a menudo se agrega despu\u00e9s de que un programa fall\u00f3 inesperadamente (es decir, \"oh, nos olvidamos de detectar ese error, deber\u00eda gestionar eso! \").","title":"1.7.4: Atrapando y gestionando excepciones"},{"location":"1/#175-generando-excepciones","text":"Para generar una excepci\u00f3n, use la instrucci\u00f3n raise . raise RuntimeError('Que desorden') Esto har\u00e1 que el programa se anule con un rastreo de excepci\u00f3n. A menos que sea atrapado por un bloque \"try-except\". $ python3 foo.py Traceback (most recent call last): File \"foo.py\", line 21, in <module> raise RuntimeError(\"Que desorden\") RuntimeError: What a kerfuffle","title":"1.7.5: Generando excepciones"},{"location":"1/#176-ejercicios","text":"Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"1.7.6: Ejercicios"},{"location":"1/#ejercicio-129-definiendo-una-funcion","text":"Intente definir una funci\u00f3n simple: >>> def saludo(nombre): 'Genera un saludo' print('Hola', nombre) >>> saludo('Guido') Hola Guido >>> saludo('Paula') Hola Paula >>> Si la primera declaraci\u00f3n de una funci\u00f3n es una cadena, sirve como documentaci\u00f3n. Intente escribir un comando como help(saludo) para que se muestre.","title":"Ejercicio 1.29: Definiendo una funci\u00f3n"},{"location":"1/#ejercicio-130-convirtiendo-una-secuencia-de-comandos-en-una-funcion","text":"Tome el c\u00f3digo que escribi\u00f3 para el programa pcost.py en el Ejercicio 1.27 y convi\u00e9rtalo en una funci\u00f3n cartera_costo(nombre_de_archivo) . La funci\u00f3n toma un nombre de archivo como entrada, lee los datos de la cartera en ese archivo y devuelve el costo total de la cartera como flotante. Para usar su funci\u00f3n, cambie su programa para que se vea algo as\u00ed: def cartera_costo(nombre_de_archivo): ... # Su c\u00f3digo aqu\u00ed ... costo = cartera_costo('Data/portfolio.csv') print('Total cost:', costo) Cuando ejecute su programa, deber\u00eda ver el mismo resultado que antes. Despu\u00e9s de ejecutar su programa, tambi\u00e9n puede llamar a su funci\u00f3n interactivamente escribiendo esto: $ python3 -i pcost.py Esto le permitir\u00e1 llamar a su funci\u00f3n desde el modo interactivo. >>> cartera_costo('Data/portfolio.csv') 44671.15 >>> Being able to experiment with your code interactively is useful for testing and debugging.","title":"Ejercicio 1.30: Convirtiendo una secuencia de comandos en una funci\u00f3n"},{"location":"1/#ejercicio-131-administracion-de-errores","text":"\u00bfQu\u00e9 sucede si prueba su funci\u00f3n en un archivo al que le faltan algunos campos? >>> cartera_costo('Data/missing.csv') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"pcost.py\", line 11, in cartera_costo nshares = int(fields[1]) ValueError: invalid literal for int() with base 10: '' >>> En este momento, tiene que tomar una decisi\u00f3n. Para que el programa funcione puede depurar el archivo de entrada eliminando las l\u00edneas o puede modificar su c\u00f3digo para manejar las l\u00edneas defectuosas de alguna forma. Modifique el programa pcost.py para detectar la excepci\u00f3n, imprima una advertencia mensaje y contin\u00fae procesando el resto del archivo.","title":"Ejercicio 1.31: Administraci\u00f3n de errores"},{"location":"1/#ejercicio-132-usando-una-funcion-de-biblioteca-local","text":"Python viene con una biblioteca est\u00e1ndar de funciones \u00fatiles. Una biblioteca que podr\u00eda ser \u00fatil aqu\u00ed es el m\u00f3dulo csv . Debe usarlo siempre que tenga que trabajar con archivos de datos CSV. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo funciona: >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'shares', 'price'] >>> for row in rows: print(row) ['AA', '100', '32.20'] ['IBM', '50', '91.10'] ['CAT', '150', '83.44'] ['MSFT', '200', '51.23'] ['GE', '95', '40.37'] ['MSFT', '50', '65.10'] ['IBM', '100', '70.44'] >>> f.close() >>> Una cosa buena sobre el m\u00f3dulo csv es que se ocupa de una variedad de detalles de bajo nivel como las comillas y la divisi\u00f3n adecuada por comas. En la salida anterior, notar\u00e1 que ha eliminado las comillas dobles lejos de los nombres en la primera columna. Modifique su programa pcost.py para que use el m\u00f3dulo csv para analizar e intentar ejecutar ejemplos anteriores.","title":"Ejercicio 1.32: Usando una funci\u00f3n de biblioteca local"},{"location":"1/#ejercicio-133-leyendo-desde-la-linea-de-comando","text":"En el programa pcost.py , el nombre del archivo de entrada se ha integrado en el c\u00f3digo: # pcost.py def cartera_costo(filename): ... # Su c\u00f3digo aqu\u00ed ... costo = cartera_costo('Data/portfolio.csv') print('Total costo:', costo) Est\u00e1 bien para aprender y probar, pero en un programa real probablemente no har\u00eda eso. En su lugar, pudiera pasar el nombre del archivo como argumento a un archivo con una secuencia de comandos. Intente cambiar la parte inferior del programa de la siguiente manera: # pcost.py import sys def cartera_costo(filename): ... # Su c\u00f3digo aqu\u00ed ... if len(sys.argv) == 2: filename = sys.argv[1] else: filename = 'Data/portfolio.csv' costo = cartera_costo(filename) print('Total costo:', costo) sys.argv es una lista que contiene argumentos pasados en la l\u00ednea de comando (si los hay). Para ejecutar su programa, deber\u00e1 ejecutar Python desde la terminal. Por ejemplo, desde bash en Unix: bash % python3 pcost.py Data/portfolio.csv Total cost: 44671.15 bash %","title":"Ejercicio 1.33: Leyendo desde la l\u00ednea de comando"},{"location":"2/","text":"2. Trabajando con data Conoceremos las estructuras de datos de fundamental importancia en Python: tuples, lists, sets y dictionaries. Presentaremos algunos patrones comunes para el manejo de datos y discutiremos el modelo de objetos en Python. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 2.1 Tipos y estructuras de data Esta secci\u00f3n presenta estructuras de datos en forma de tuplas y diccionarios. 2.1.1 Tipos primitivos Python tiene algunos tipos primitivos de datos: Enteros N\u00fameros de punto flotante Cadenas (texto) Aprendimos sobre esto en la introducci\u00f3n. 2.1.2 Tipo None email_address = None None se utiliza a menudo como marcador de posici\u00f3n para un valor opcional o faltante. Eso se eval\u00faa como \"Falso\" en condicionales. if email_address: send_email(email_address, msg) 2.1.3: Estructuras de data Los programas reales tienen datos m\u00e1s complejos. Por ejemplo, informaci\u00f3n sobre una participaci\u00f3n en acciones: 100 acciones de GOOG a $490.10 Este es un \"objeto\" con tres partes: Nombre o s\u00edmbolo de la acci\u00f3n (\"GOOG\", una cadena) N\u00famero de acciones (100, un n\u00famero entero) Precio (490,10 un punto flotante) 2.1.4: Tuplas Una tupla es una colecci\u00f3n de valores agrupados. Ejemplo: s = ('GOOG', 100, 490.1) A veces el () es omitido. s = 'GOOG', 100, 490.1' Casos especiales (0-tupla, 1-tupla). t = () # Una tupla vac\u00eda w = ('GOOG', ) # Una tupla de 1-item Las tuplas se utilizan a menudo para representar registros o estructuras simples . Normalmente, es un \u00fanico objeto de varias partes. Una buena analog\u00eda: Una tupla es como una sola fila en una tabla de base de datos. El contenido de la tupla est\u00e1 ordenado (como una matriz). s = ('GOOG', 100, 490.1) name = s[0] # 'GOOG' shares = s[1] # 100 price = s[2] # 490.1 Sin embargo, el contenido no se puede modificar. >>> s[1] = 75 TypeError: object does not support item assignment Sin embargo, puede crear una nueva tupla basada en una tupla actual. s = (s[0], 75, s[2]) Las tuplas tienen m\u00e1s que ver con empaquetar elementos relacionados en una sola entidad , que con cualquier otra cosa. s = ('GOOG', 100, 490.1) Por tanto, la tupla es f\u00e1cil de pasar a otras partes de un programa como un solo objeto. 2.1.5: Desempaque de Tuplas Para usar la tupla en otro lugar, puede desempaquetar sus partes en variables. name, shares, price = s print('Cost', shares * price) The number of variables on the left must match the tuple structure. name, shares = s # ERROR Traceback (most recent call last): ... ValueError: too many values to unpack 2.1.6 Tuplas vs Listas Tuples look like read-only lists. However, tuples are most often used for a single item consisting of multiple parts. Lists are usually a collection of distinct items, usually all of the same type. record = ('GOOG', 100, 490.1) # Una tupla que representa un registro en una cartera symbols = [ 'GOOG', 'AAPL', 'IBM' ] # Una lista que representa tres s\u00edmbolos de acciones 2.1.7 Diccionarios Un diccionario es la asignaci\u00f3n de claves a valores. A veces tambi\u00e9n se le llama una tabla hash o matriz asociativa. Las claves sirven como \u00edndices para acceder a los valores. s = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } 2.1.8 Operaciones comunes To get values from a dictionary use the key names. >>> print(s['name'], s['shares']) GOOG 100 >>> s['price'] 490.10 >>> Para agregar o modificar valores, asigne usando los nombres de las claves. >>> s['shares'] = 75 >>> s['date'] = '6/6/2007' >>> Para eliminar un valor, use la instrucci\u00f3n del . >>> del s['date'] >>> 2.1.9 \u00bfPorqu\u00e9 diccionarios? Los diccionarios son \u00fatiles cuando hay * muchos * valores diferentes y esos valores puede ser modificado o manipulado. Los diccionarios hacen que su c\u00f3digo sea m\u00e1s legible. s['price'] # vs s[2] 2.1.10 Ejercicios En los \u00faltimos ejercicios, escribi\u00f3 un programa que lee un archivo de datos Data/portfolio.csv . Usando el m\u00f3dulo csv , es f\u00e1cil leer el archivo fila por fila. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> next(rows) ['name', 'shares', 'price'] >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> Aunque leer el archivo es f\u00e1cil, a menudo querr\u00e1 hacer m\u00e1s con el datos que leerlos. Por ejemplo, tal vez desee almacenarlo y comience a realizar algunos c\u00e1lculos sobre \u00e9l. Desafortunadamente, una \"fila\" sin procesar de datos no le da suficiente para trabajar. Por ejemplo, incluso un el c\u00e1lculo matem\u00e1tico simple no funciona: >>> row = ['AA', '100', '32.20'] >>> cost = row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiply sequence by non-int of type 'str' >>> Para hacer m\u00e1s, normalmente desea interpretar los datos sin procesar de alguna manera y convertirlo en un tipo de objeto m\u00e1s \u00fatil para que pueda trabajar con \u00e9l m\u00e1s tarde. Dos opciones simples son tuplas o diccionarios. Ejercicio 2.1: Tuplas En el indicador interactivo, cree la siguiente tupla que represente la fila anterior, pero con las columnas num\u00e9ricas convertidas a los n\u00fameros adecuados: >>> t = (row[0], int(row[1]), float(row[2])) >>> t ('AA', 100, 32.2) >>> Con esto, ahora puede calcular el costo total multiplicando las acciones y el precio: >>> cost = t[1] * t[2] >>> cost 3220.0000000000005 >>> \u00bfLas matem\u00e1ticas est\u00e1n rotas en Python? \u00bfCu\u00e1l es el problema con la respuesta de 3220.0000000000005? Este es un artefacto del hardware de punto flotante en su computadora que solo puede representar decimales con precisi\u00f3n en Base-2, no en Base-10. Incluso para c\u00e1lculos simples que involucran decimales en base 10, se introducen peque\u00f1os errores. Esto es normal, aunque quiz\u00e1s un poco sorprendente si no lo ha visto antes. Esto sucede en todos los lenguajes de programaci\u00f3n que utilizan decimales de punto flotante, pero a menudo se oculta al imprimir. Por ejemplo: >>> print(f'{cost:0.2f}') 3220.00 >>> Las tuplas son de solo lectura. Verifique esto intentando cambiar el n\u00famero de acciones a 75. >>> t[1] = 75 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> Aunque no puede cambiar el contenido de la tupla, siempre puede crear una tupla completamente nueva que reemplace a la anterior. >>> t = (t[0], 75, t[2]) >>> t ('AA', 75, 32.2) >>> Siempre que reasigne un nombre de variable existente como este, el valor anterior se descarta. Aunque la asignaci\u00f3n anterior puede parecer que est\u00e1 modificando la tupla, en realidad est\u00e1 creando una nueva tupla y desechando la anterior. Las tuplas se utilizan a menudo para empaquetar y descomprimir valores en variables. Intente lo siguiente: >>> name, shares, price = t >>> name 'AA' >>> shares 75 >>> price 32.2 >>> Tome las variables anteriores y vuelva a empaquetarlas en una tupla >>> t = (name, 2*shares, price) >>> t ('AA', 150, 32.2) >>> Ejercicio 2.2: Diccionarios como estructura de datos Una alternativa a una tupla es crear un diccionario. >>> d = { 'name' : row[0], 'shares' : int(row[1]), 'price' : float(row[2]) } >>> d {'name': 'AA', 'shares': 100, 'price': 32.2 } >>> Calcule el costo total de esta participaci\u00f3n: >>> cost = d['shares'] * d['price'] >>> cost 3220.0000000000005 >>> Compare este ejemplo con el mismo c\u00e1lculo que involucra tuplas anterior. Cambie el n\u00famero de acciones a 75. >>> d['shares'] = 75 >>> d {'name': 'AA', 'shares': 75, 'price': 32.2 } >>> A diferencia de las tuplas, los diccionarios se pueden modificar libremente. Agrega algunos atributos: >>> d['date'] = (6, 11, 2007) >>> d['account'] = 12345 >>> d {'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007), 'account': 12345} >>> Ejercicio 2.3: Otras operaciones adicionales Si convierte un diccionario en una lista, obtendr\u00e1 todas sus claves: >>> list(d) ['name', 'shares', 'price', 'date', 'account'] >>> De manera similar, si usa la fordeclaraci\u00f3n para iterar en un diccionario, obtendr\u00e1 las claves: >>> for k in d: print('k =', k) k = name k = shares k = price k = date k = account >>> Pruebe esta variante que realiza una b\u00fasqueda al mismo tiempo: >>> for k in d: print(k, '=', d[k]) name = AA shares = 75 price = 32.2 date = (6, 11, 2007) account = 12345 >>> Tambi\u00e9n puede obtener todas las claves utilizando el m\u00e9todo keys() : >>> keys = d.keys() >>> keys dict_keys(['name', 'shares', 'price', 'date', 'account']) >>> keys()es un poco inusual porque devuelve un dict_keysobjeto especial . Se trata de una superposici\u00f3n del diccionario original que siempre le proporciona las claves actuales, incluso si el diccionario cambia. Por ejemplo, intente esto: >>> del d['account'] >>> keys dict_keys(['name', 'shares', 'price', 'date']) >>> Observe cuidadosamente que 'account'desapareci\u00f3 keysaunque no volvi\u00f3 a llamar d.keys(). Una forma m\u00e1s elegante de trabajar con claves y valores juntos es utilizar el items()m\u00e9todo. Esto te da (key, value)tuplas: >>> items = d.items() >>> items dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))]) >>> for k, v in d.items(): print(k, '=', v) name = AA shares = 75 price = 32.2 date = (6, 11, 2007) >>> Si tiene tuplas como items, puede crear un diccionario usando la dict()funci\u00f3n. Intentalo: >>> items dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))]) >>> d = dict(items) >>> d {'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007)} >>> 2.2 Contenedores 2.2.1: Visi\u00f3n General Los programas a menudo tienen que trabajar con muchos objetos. Una cartera de acciones Una tabla de precios de acciones Hay tres opciones principales para usar. Listas. Datos ordenados. Diccionarios. Datos desordenados. Conjuntos. Colecci\u00f3n desordenada de art\u00edculos \u00fanicos.* 2.2.2: Listas como un Contenedor Utilice una lista cuando sea importante el orden de los datos. Recuerde que las listas pueden contener cualquier tipo de objeto. Por ejemplo, una lista de tuplas. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.3), ('CAT', 150, 83.44) ] portfolio[0] # ('GOOG', 100, 490.1) portfolio[2] # ('CAT', 150, 83.44) 2.2.3: Construcci\u00f3n de una lista Construyendo una lista desde cero. records = [] # lista inicial # Use .append() para agregar mas items records.append(('GOOG', 100, 490.10)) records.append(('IBM', 50, 91.3)) ... Un ejemplo al leer registros de un archivo. records = [] # lista inicial with open('Data/portfolio.csv', 'rt') as f: next(f) # Nos saltamos el encabezado for line in f: row = line.split(',') records.append((row[0], int(row[1]), float(row[2]))) 2.2.4: Diccionarios como contenedores Los diccionarios son \u00fatiles si desea b\u00fasquedas aleatorias r\u00e1pidas (por nombre de clave). Por ejemplo, un diccionario de precios de acciones: prices = { 'GOOG': 513.25, 'CAT': 87.22, 'IBM': 93.37, 'MSFT': 44.12 } Aqu\u00ed hay algunas b\u00fasquedas simples: >>> prices['IBM'] 93.37 >>> prices['GOOG'] 513.25 >>> 2.2.5: Construcci\u00f3n de un diccionario Ejemplo de construcci\u00f3n de un dictado desde cero. prices = {} # Initial empty dict # Insert new items prices['GOOG'] = 513.25 prices['CAT'] = 87.22 prices['IBM'] = 93.37 Un ejemplo que completa el dict a partir del contenido de un archivo. prices = {} # Initial empty dict with open('Data/prices.csv', 'rt') as f: for line in f: row = line.split(',') prices[row[0]] = float(row[1]) Nota: Si prueba esto en el Data/prices.csvarchivo, encontrar\u00e1 que casi funciona; hay una l\u00ednea en blanco al final que hace que se bloquee. Necesitar\u00e1 encontrar alguna forma de modificar el c\u00f3digo para tener en cuenta eso (vea el ejercicio 2.6). 2.2.6: B\u00fasquedas de diccionario Puede probar la existencia de una clave. if key in d: # YES else: # NO Puede buscar un valor que podr\u00eda no existir y proporcionar un valor predeterminado en caso de que no exista. name = d.get(key, default) Un ejemplo: >>> prices.get('IBM', 0.0) 93.37 >>> prices.get('SCOX', 0.0) 0.0 >>> 2.2.7: Claves compuestas Casi cualquier tipo de valor se puede utilizar como clave de diccionario en Python. Una clave de diccionario debe ser de un tipo que sea inmutable. Por ejemplo, tuplas: holidays = { (1, 1) : 'New Years', (3, 14) : 'Pi day', (9, 13) : \"Programmer's day\", } Luego para acceder: >>> holidays[3, 14] 'Pi day' >>> Ni una lista, un conjunto ni otro diccionario pueden servir como clave de diccionario, porque las listas y los diccionarios son mutables. 2.2.8: Conjuntos (Sets) Los conjuntos son una colecci\u00f3n de elementos \u00fanicos desordenados. tech_stocks = { 'IBM','AAPL','MSFT' } # alternativamente: tech_stocks = set(['IBM', 'AAPL', 'MSFT']) Los conjuntos son \u00fatiles para las pruebas de pertenencia. >>> tech_stocks set(['AAPL', 'IBM', 'MSFT']) >>> 'IBM' in tech_stocks True >>> 'FB' in tech_stocks False >>> Los conjuntos tambi\u00e9n son \u00fatiles para la eliminaci\u00f3n de duplicados. names = ['IBM', 'AAPL', 'GOOG', 'IBM', 'GOOG', 'YHOO'] unique = set(names) # unique = set(['IBM', 'AAPL','GOOG','YHOO']) Operaciones de conjuntos adicionales: names.add('CAT') # Add an item names.remove('YHOO') # Remove an item s1 | s2 # Set union s1 & s2 # Set intersection s1 - s2 # Set difference 2.2.9: Ejercicios En estos ejercicios, comenzar\u00e1 a crear uno de los programas principales que se utilizar\u00e1n durante el resto de este curso. Haga su trabajo en el archivo Work/report.py . Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Ejercicio 2.4: Una lista de tuplas El archivo Data/portfolio.csv contiene una lista de acciones en una cartera. En el ejercicio 1.30 , escribi\u00f3 una funci\u00f3n portfolio_cost(filename) que ley\u00f3 este archivo y realiz\u00f3 un c\u00e1lculo simple. Tu c\u00f3digo deber\u00eda haberse visto as\u00ed: # pcost.py import csv def portfolio_cost(filename): '''Computa el costo total (shares*price) de un archivo del portfolio''' total_cost = 0.0 with open(filename, 'rt') as f: rows = csv.reader(f) headers = next(rows) for row in rows: nshares = int(row[1]) price = float(row[2]) total_cost += nshares * price return total_cost Usando este c\u00f3digo como una gu\u00eda aproximada, cree un nuevo archivo report.py. En ese archivo, defina una funci\u00f3n read_portfolio(filename) que abra un archivo de cartera determinado y lo lea en una lista de tuplas. Para hacer esto, va a realizar algunas modificaciones menores al c\u00f3digo anterior. Primero, en lugar de definir total_cost = 0, crear\u00e1 una variable que inicialmente se establece en una lista vac\u00eda. Por ejemplo: portfolio = [] A continuaci\u00f3n, en lugar de sumar el costo total, convertir\u00e1 cada fila en una tupla exactamente como lo hizo en el \u00faltimo ejercicio y la agregar\u00e1 a esta lista. Por ejemplo: for row in rows: holding = (row[0], int(row[1]), float(row[2])) portfolio.append(holding) Finalmente, devolver\u00e1 el portfolio en una lista. Experimente con su funci\u00f3n de forma interactiva (solo un recordatorio de que para hacer esto, primero debe ejecutar el report.pyprograma en el int\u00e9rprete): Sugerencia: Haga uso de -i al ejecutar el archivo en la terminal, e.g. $ python -i archivo.py >>> portfolio = read_portfolio('Data/portfolio.csv') >>> portfolio [('AA', 100, 32.2), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('MSFT', 200, 51.23), ('GE', 95, 40.37), ('MSFT', 50, 65.1), ('IBM', 100, 70.44)] >>> >>> portfolio[0] ('AA', 100, 32.2) >>> portfolio[1] ('IBM', 50, 91.1) >>> portfolio[1][1] 50 >>> total = 0.0 >>> for s in portfolio: total += s[1] * s[2] >>> print(total) 44671.15 >>> Esta lista de tuplas que ha creado es muy similar a una matriz 2-D. Por ejemplo, puede acceder a una columna y una fila espec\u00edficas mediante una b\u00fasqueda como portfolio[row][column] d\u00f3nde row y column son n\u00fameros enteros. Dicho esto, tambi\u00e9n puede escribir el \u00faltimo ciclo for usando una declaraci\u00f3n como esta: >>> total = 0.0 >>> for name, shares, price in portfolio: total += shares*price >>> print(total) 44671.15 >>> Ejercicio 2.5: Lista de diccionarios Tome la funci\u00f3n que escribi\u00f3 en el ejercicio 2.4 y modif\u00edquela para representar cada acci\u00f3n de la cartera con un diccionario en lugar de una tupla. En este diccionario, use los nombres de campo de \"nombre\", \"acciones\" y \"precio\" para representar las diferentes columnas en el archivo de entrada. Experimente con esta nueva funci\u00f3n de la misma manera que lo hizo en el ejercicio 2.4. >>> portfolio = read_portfolio('Data/portfolio.csv') >>> portfolio [{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1}, {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23}, {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1}, {'name': 'IBM', 'shares': 100, 'price': 70.44}] >>> portfolio[0] {'name': 'AA', 'shares': 100, 'price': 32.2} >>> portfolio[1] {'name': 'IBM', 'shares': 50, 'price': 91.1} >>> portfolio[1]['shares'] 50 >>> total = 0.0 >>> for s in portfolio: total += s['shares']*s['price'] >>> print(total) 44671.15 >>> Aqu\u00ed, notar\u00e1 que se accede a los diferentes campos para cada entrada mediante nombres de clave en lugar de n\u00fameros de columna num\u00e9ricos. Esto se prefiere a menudo porque el c\u00f3digo resultante es m\u00e1s f\u00e1cil de leer m\u00e1s tarde. Ver diccionarios y listas de gran tama\u00f1o puede resultar complicado. Para limpiar la salida para la depuraci\u00f3n, considere usar la funci\u00f3n pprint . >>> from pprint import pprint >>> pprint(portfolio) [{'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'MSFT', 'price': 65.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}] >>> Ejercicio 2.6: Diccionarios como contenedor Un diccionario es una forma \u00fatil de realizar un seguimiento de los elementos en los que desea buscar elementos utilizando un \u00edndice que no sea un n\u00famero entero. En el shell de Python, intente jugar con un diccionario: >>> prices = { } >>> prices['IBM'] = 92.45 >>> prices['MSFT'] = 45.12 >>> prices ... look at the result ... >>> prices['IBM'] 92.45 >>> prices['AAPL'] ... look at the result ... >>> 'AAPL' in prices False >>> El archivo Data/prices.csv contiene una serie de l\u00edneas con precios de acciones. El archivo se parece a esto: \"AA\",9.22 \"AXP\",24.85 \"BA\",44.85 \"BAC\",11.27 \"C\",3.72 ... Escriba una funci\u00f3n read_prices(filename)que lea un conjunto de precios como este en un diccionario donde las claves del diccionario son los nombres de las acciones y los valores en el diccionario son los precios de las acciones. Para hacer esto, comience con un diccionario vac\u00edo y comience a insertar valores en \u00e9l tal como lo hizo anteriormente. Sin embargo, ahora est\u00e1 leyendo los valores de un archivo. Usaremos esta estructura de datos para buscar r\u00e1pidamente el precio de un nombre de acci\u00f3n determinado. Algunos peque\u00f1os consejos que necesitar\u00e1 para esta parte. Primero, aseg\u00farese de usar el csvm\u00f3dulo tal como lo hizo antes, no es necesario reinventar la rueda aqu\u00ed. >>> import csv >>> f = open('Data/prices.csv', 'r') >>> rows = csv.reader(f) >>> for row in rows: print(row) ['AA', '9.22'] ['AXP', '24.85'] ... [] >>> La otra peque\u00f1a complicaci\u00f3n es que el Data/prices.csvarchivo puede tener algunas l\u00edneas en blanco. Observe c\u00f3mo la \u00faltima fila de datos de arriba es una lista vac\u00eda, lo que significa que no hab\u00eda datos presentes en esa l\u00ednea. Existe la posibilidad de que esto provoque la muerte de su programa con una excepci\u00f3n. Utilice las declaraciones tryy exceptpara detectar esto seg\u00fan corresponda. Pensamiento: \u00bfser\u00eda mejor protegerse contra datos incorrectos con una ifdeclaraci\u00f3n -en su lugar? Una vez que haya escrito su funci\u00f3n read_prices(), pru\u00e9bela de forma interactiva para asegurarse de que funcione: >>> prices = read_prices('Data/prices.csv') >>> prices['IBM'] 106.28 >>> prices['MSFT'] 20.89 >>> La otra peque\u00f1a complicaci\u00f3n es que el archivo Data/prices.csv puede tener algunas l\u00edneas en blanco. Observe c\u00f3mo la \u00faltima fila de datos de arriba es una lista vac\u00eda, lo que significa que no hab\u00eda datos presentes en esa l\u00ednea. Existe la posibilidad de que esto provoque la muerte de su programa con una excepci\u00f3n. Utilice las declaraciones tryy exceptpara detectar esto seg\u00fan corresponda. Pensamiento: \u00bfser\u00eda mejor protegerse contra datos incorrectos con una ifdeclaraci\u00f3n -en su lugar? Una vez que haya escrito su funci\u00f3n read_prices() , pru\u00e9bela de forma interactiva para asegurarse de que funcione: >>> prices = read_prices('Data/prices.csv') >>> prices['IBM'] 106.28 >>> prices['MSFT'] 20.89 >>> Ejercicio 2.7: Descubra se puede jubilar Complete este trabajo agregando algunas declaraciones adicionales a su programa report.py que calculen ganancias / p\u00e9rdidas. Estas declaraciones deben tomar la lista de acciones del ejercicio 2.5 y el diccionario de precios del ejercicio 2.6 y calcular el valor actual de la cartera junto con la ganancia / p\u00e9rdida. 2.3 Salida formateada Esta secci\u00f3n es una peque\u00f1a digresi\u00f3n, pero cuando trabaja con datos, a menudo desea producir resultados estructurados (tablas, etc.). Por ejemplo: Name Shares Price ---------- ---------- ----------- AA 100 32.20 IBM 50 91.10 CAT 150 83.44 MSFT 200 51.23 GE 95 40.37 MSFT 50 65.10 IBM 100 70.44 Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 2.3.1: Formateo de cadena Una forma de formatear cadenas en Python 3.6+ es con f-strings. >>> name = 'IBM' >>> shares = 100 >>> price = 91.1 >>> f'{name:>10s} {shares:>10d} {price:>10.2f}' ' IBM 100 91.10' >>> La pieza {expression:format} se reemplaza. Se usa com\u00fanmente con print. print(f'{name:>10s} {shares:>10d} {price:>10.2f}') 2.3.2: C\u00f3digos de formato C\u00f3digos de formato (despu\u00e9s de que el : interior de la {} ) son similares a C printf(). Los c\u00f3digos comunes incluyen: d Decimal integer b Binary integer x Hexadecimal integer f Float as [-]m.dddddd e Float as [-]m.dddddde+-xx g Float, but selective use of E notation s String c Character (from integer) Los modificadores comunes ajustan el ancho del campo y la precisi\u00f3n decimal. Esta es una lista parcial: :>10d Integer right aligned in 10-character field :<10d Integer left aligned in 10-character field :^10d Integer centered in 10-character field :0.2f Float with 2 digit precision 2.3.3: Formateo de diccionarios Puede utilizar el format_map()m\u00e9todo para aplicar formato de cadena a un diccionario de valores: >>> s = { 'name': 'IBM', 'shares': 100, 'price': 91.1 } >>> '{name:>10s} {shares:10d} {price:10.2f}'.format_map(s) ' IBM 100 91.10' >>> Utiliza los mismos c\u00f3digos que f-stringspero toma los valores del diccionario suministrado. 2.3.4: El m\u00e9todo format() Existe un m\u00e9todo format()que puede aplicar formato a argumentos o argumentos de palabras clave. >>> '{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1) ' IBM 100 91.10' >>> '{:10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1) ' IBM 100 91.10' >>> Francamente, format()es un poco prolijo. Prefiero las cuerdas f. 2.3.5: Formateo al estilo C Tambi\u00e9n puede utilizar el operador de formato % . >>> 'The value is %d' % 3 'The value is 3' >>> '%5d %-5d %10d' % (3,4,5) ' 3 4 5' >>> '%0.2f' % (3.1415926,) '3.14' Esto requiere un solo elemento o una tupla a la derecha. C\u00f3digos de formato son el modelo de la C printf() tambi\u00e9n. Nota: Este es el \u00fanico formato disponible en cadenas de bytes. >>> b'%s has %n messages' % (b'Dave', 37) b'Dave has 37 messages' >>> 2.3.6: Ejercicios Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Ejercicio 2.8: Como formatear numeros Un problema com\u00fan al imprimir n\u00fameros es especificar el n\u00famero de decimales. Una forma de solucionar este problema es usar f-strings. Prueba estos ejemplos: >>> value = 42863.1 >>> print(value) 42863.1 >>> print(f'{value:0.4f}') 42863.1000 >>> print(f'{value:>16.2f}') 42863.10 >>> print(f'{value:<16.2f}') 42863.10 >>> print(f'{value:*>16,.2f}') *******42,863.10 >>> La documentaci\u00f3n completa sobre los c\u00f3digos de formato utilizados para las cadenas f se puede encontrar aqu\u00ed . El formateo tambi\u00e9n se realiza a veces utilizando el operador % de cadenas. >>> print('%0.4f' % value) 42863.1000 >>> print('%16.2f' % value) 42863.10 >>> La documentaci\u00f3n sobre varios c\u00f3digos utilizados con %se puede encontrar aqu\u00ed. Aunque se usa com\u00fanmente con print, el formato de cadena no est\u00e1 ligado a la impresi\u00f3n. Si desea guardar una cadena formateada. Simplemente as\u00edgnelo a una variable. >>> f = '%0.4f' % value >>> f '42863.1000' >>> Ejercicio 2.9: Coleccionando data En el ejercicio 2.7, escribi\u00f3 un programa llamado report.pyque calcul\u00f3 la ganancia / p\u00e9rdida de una cartera de acciones. En este ejercicio, comenzar\u00e1 a modificarlo para producir una tabla como esta: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 En este informe, \"Precio\" es el precio actual de la acci\u00f3n de la acci\u00f3n y \"Cambio\" es el cambio en el precio de la acci\u00f3n desde el precio de compra inicial. Para generar el informe anterior, primero querr\u00e1 recopilar todos los datos que se muestran en la tabla. Escriba una funci\u00f3n make_report() que tome una lista de existencias y un diccionario de precios como entrada y devuelva una lista de tuplas que contenga las filas de la tabla anterior. Agregue esta funci\u00f3n a su archivo report.py . As\u00ed es como deber\u00eda funcionar si lo prueba de forma interactiva: >>> portfolio = read_portfolio('Data/portfolio.csv') >>> prices = read_prices('Data/prices.csv') >>> report = make_report(portfolio, prices) >>> for r in report: print(r) ('AA', 100, 9.22, -22.980000000000004) ('IBM', 50, 106.28, 15.180000000000007) ('CAT', 150, 35.46, -47.98) ('MSFT', 200, 20.89, -30.339999999999996) ('GE', 95, 13.48, -26.889999999999997) ... >>> Ejercicio 2.10: Imprimiendo una tabla formateada Rehaga el bucle for del ejercicio 2.9, pero cambie la instrucci\u00f3n print para formatear las tuplas. >>> for r in report: print('%10s %10d %10.2f %10.2f' % r) AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 ... >>> Tambi\u00e9n puede expandir los valores y usar f-strings. Por ejemplo: >>> for name, shares, price, change in report: print(f'{name:>10s} {shares:>10d} {price:>10.2f} {change:>10.2f}') AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 ... >>> Tome las declaraciones anteriores y agr\u00e9guelas a su report.pyprograma. Haga que su programa tome la salida de la funci\u00f3n make_report() e imprima una tabla bien formateada como se muestra. Ejercicio 2.11: Agregando algunos encabezados Suponga que tiene una tupla de nombres de encabezado como este: headers = ('Name', 'Shares', 'Price', 'Change') Agregue c\u00f3digo a su programa que toma la tupla de encabezados anterior y crea una cadena donde cada nombre de encabezado est\u00e1 alineado a la derecha en un campo de 10 caracteres de ancho y cada campo est\u00e1 separado por un solo espacio. ' Name Shares Price Change' Escriba c\u00f3digo que tome los encabezados y cree la cadena de separaci\u00f3n entre los encabezados y los datos que siguen. Esta cadena es solo un grupo de caracteres \"-\" debajo de cada nombre de campo. Por ejemplo: '---------- ---------- ---------- -----------' Cuando haya terminado, su programa deber\u00eda producir la tabla que se muestra en la parte superior de este ejercicio. Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 Ejercicio 2.12: Un reto \u00bfC\u00f3mo modificar\u00eda su c\u00f3digo para que el precio incluya el s\u00edmbolo de moneda ($) y la salida se vea as\u00ed: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 $9.22 -22.98 IBM 50 $106.28 15.18 CAT 150 $35.46 -47.98 MSFT 200 $20.89 -30.34 GE 95 $13.48 -26.89 MSFT 50 $20.89 -44.21 IBM 100 $106.28 35.84 2.4 Secuencias Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 2.4.1: Tipos de secuencias Python tiene tres tipos de datos de secuencia . Cuerda: 'Hello' . Una cadena es una secuencia de caracteres. Lista: [1, 4, 5] . Tupla: ('GOOG', 100, 490.1) . Todas las secuencias est\u00e1n ordenadas, indexadas por n\u00fameros enteros y tienen una longitud. a = 'Hello' # String b = [1, 4, 5] # List c = ('GOOG', 100, 490.1) # Tuple # Indexed order a[0] # 'H' b[-1] # 5 c[1] # 100 # Length of sequence len(a) # 5 len(b) # 3 len(c) # 3 Las secuencias pueden ser replicados: s * n . >>> a = 'Hello' >>> a * 3 'HelloHelloHello' >>> b = [1, 2, 3] >>> b * 2 [1, 2, 3, 1, 2, 3] >>> Secuencias del mismo tipo pueden ser concatenados: s + t . >>> a = (1, 2, 3) >>> b = (4, 5) >>> a + b (1, 2, 3, 4, 5) >>> >>> c = [1, 5] >>> a + c Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only concatenate tuple (not \"list\") to tuple 2.4.2: Cortar Cortar significa tomar una subsecuencia de una secuencia. La sintaxis es s[start:end] . Donde start y end son los \u00edndices de la subsecuencia que desea. a = [0,1,2,3,4,5,6,7,8] a[2:5] # [2,3,4] a[-5:] # [4,5,6,7,8] a[:3] # [0,1,2] \u00cdndices start y end deben ser n\u00fameros enteros. Las rebanadas no incluyen el valor final. Es como un intervalo medio abierto de matem\u00e1ticas. Si se omiten los \u00edndices, por defecto van al principio o al final de la lista. 2.4.3: Reasignaci\u00f3n de cortes En las listas, los sectores se pueden reasignar y eliminar. # Reasginaci\u00f3n a = [0,1,2,3,4,5,6,7,8] a[2:4] = [10,11,12] # [0,1,10,11,12,4,5,6,7,8] Nota: No es necesario que el segmento reasignado tenga la misma longitud. # Remoci\u00f3n a = [0,1,2,3,4,5,6,7,8] del a[2:4] # [0,1,4,5,6,7,8] 2.4.4: Secuencia de reducciones Existen algunas funciones comunes para reducir una secuencia a un solo valor. >>> s = [1, 2, 3, 4] >>> sum(s) 10 >>> min(s) 1 >>> max(s) 4 >>> t = ['Hello', 'World'] >>> max(t) 'World' >>> 2.4.5: Iteracion sobre una secuencia El bucle for itera sobre los elementos en una secuencia. >>> s = [1, 4, 9, 16] >>> for i in s: ... print(i) ... 1 4 9 16 >>> En cada iteraci\u00f3n del ciclo, obtienes un nuevo elemento con el que trabajar. Este nuevo valor se coloca en la variable de iteraci\u00f3n. En este ejemplo, la variable de iteraci\u00f3n es x : for x in s: # `x` es una variable de iteraci\u00f3n ...declaraciones En cada iteraci\u00f3n, el valor anterior de la variable de iteraci\u00f3n se sobrescribe (si lo hubiera). Una vez finalizado el ciclo, la variable retiene el \u00faltimo valor. 2.4.6: La declaraci\u00f3n break Puede usar la break declaraci\u00f3n para salir de un ciclo antes de tiempo. for name in namelist: if name == 'Jake': break ... ... declaraciones Cuando la break instrucci\u00f3n se ejecuta, sale del ciclo y pasa al siguiente statements . La declaraci\u00f3n break solo se aplica al bucle m\u00e1s interno. Si este bucle est\u00e1 dentro de otro bucle, no romper\u00e1 el bucle exterior. 2.4.7: La declaraci\u00f3n continue Para omitir un elemento y pasar al siguiente, use la continue declaraci\u00f3n. for line in lines: if line == '\\n': # Skip blank lines continue # More statements ... Esto es \u00fatil cuando el elemento actual no es de inter\u00e9s o debe ignorarse en el procesamiento. 2.4.8: Ciclando sobre enteros Si necesita contar, use range() . for i in range(100): # i = 0,1,...,99 La sintaxis es range([start,] end [,step]) for i in range(100): # i = 0,1,...,99 for j in range(10,20): # j = 10,11,..., 19 for k in range(10,50,2): # k = 10,12,...,48 # Note como cuenta en pasos de 2, no 1. El valor final nunca se incluye. Refleja el comportamiento de los cortes. start es opcional. Por defecto 0 . step es opcional. Por defecto 1 . range() calcula los valores seg\u00fan sea necesario. En realidad, no almacena una gran variedad de n\u00fameros. 2.4.9: La funci\u00f3n enumerate() La enumerate funci\u00f3n agrega un valor de contador adicional a la iteraci\u00f3n. names = ['Elwood', 'Jake', 'Curtis'] for i, name in enumerate(names): # Cicla con i = 0, name = 'Elwood' # i = 1, name = 'Jake' # i = 2, name = 'Curtis' La forma general es enumerate(sequence [, start = 0]) . start es opcional. Un buen ejemplo de uso enumerate() es el seguimiento de los n\u00fameros de l\u00ednea mientras se lee un archivo: with open(filename) as f: for lineno, line in enumerate(f, start=1): ... Al final, enumerate es solo un buen atajo para: i = 0 for x in s: statements i += 1 Usar enumerate es escribir menos y se ejecuta un poco m\u00e1s r\u00e1pido. 2.4.10: for y tuplas Puede iterar con m\u00faltiples variables de iteraci\u00f3n. points = [ (1, 4),(10, 40),(23, 14),(5, 6),(7, 8) ] for x, y in points: # Cicla con x = 1, y = 4 # x = 10, y = 40 # x = 23, y = 14 # ... Cuando se utilizan varias variables, cada tupla se descompone en un conjunto de variables de iteraci\u00f3n. El n\u00famero de variables debe coincidir con el n\u00famero de elementos de cada tupla. 2.4.11: La funci\u00f3n zip() La zip funci\u00f3n toma m\u00faltiples secuencias y crea un iterador que las combina. columns = ['name', 'shares', 'price'] values = ['GOOG', 100, 490.1 ] pairs = zip(columns, values) # ('name','GOOG'), ('shares',100), ('price',490.1) Para obtener el resultado, debes iterar. Puede utilizar varias variables para descomprimir las tuplas como se mostr\u00f3 anteriormente. for column, value in pairs: ... Un uso com\u00fan de zip es crear pares clave / valor para construir diccionarios. d = dict(zip(columns, values)) 2.4.12: Ejercicios Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Ejercicio 2.13: Contar Pruebe algunos ejemplos b\u00e1sicos de conteo: >>> for n in range(10): # Cuenta 0 ... 9 print(n, end=' ') 0 1 2 3 4 5 6 7 8 9 >>> for n in range(10,0,-1): # Cuenta 10 ... 1 print(n, end=' ') 10 9 8 7 6 5 4 3 2 1 >>> for n in range(0,10,2): # Cuenta 0, 2, ... 8 print(n, end=' ') 0 2 4 6 8 >>> Ejercicio 2.14: Mas operaciones sobre secuencias Experimente interactivamente con algunas de las operaciones de reducci\u00f3n de secuencia. >>> data = [4, 9, 1, 25, 16, 100, 49] >>> min(data) 1 >>> max(data) 100 >>> sum(data) 204 >>> Intente recorrer los datos. >>> for x in data: print(x) 4 9 ... >>> for n, x in enumerate(data): print(n, x) 0 4 1 9 2 1 ... >> A veces, los principiantes usan la for instrucci\u00f3n, len() y range() en alg\u00fan tipo de fragmento de c\u00f3digo horrible que parece surgido de las profundidades de un programa C oxidado. >>> for n in range(len(data)): print(data[n]) 4 9 1 ... >>> \u00a1No hagas eso! Leerlo no solo hace sangrar los ojos de todos, es ineficiente con la memoria y funciona mucho m\u00e1s lento. Simplemente use un for bucle normal si desea iterar sobre los datos. \u00daselo enumerate() si necesita el \u00edndice por alguna raz\u00f3n. Ejercicio 2.15: Un ejemplo pr\u00e1ctico de enumerate() Recuerde que el archivo Data/missing.csv contiene datos para una cartera de acciones, pero tiene algunas filas con datos faltantes. Usando enumerate() , modifique su pcost.py programa para que imprima un n\u00famero de l\u00ednea con el mensaje de advertencia cuando encuentre una entrada incorrecta. >>> cost = portfolio_cost('Data/missing.csv') Row 4: Couldn't convert: ['MSFT', '', '51.23'] Row 7: Couldn't convert: ['IBM', '', '70.44'] >>> Para hacer esto, necesitar\u00e1 cambiar algunas partes de su c\u00f3digo. ... for rowno, row in enumerate(rows, start=1): try: ... except ValueError: print(f'Fila {rowno}: Mala fila: {row}') Ejercicio 2.16: Usando la funci\u00f3n zip() En el archivo Data/portfolio.csv , la primera l\u00ednea contiene encabezados de columna. En todo el c\u00f3digo anterior, los hemos estado descartando. >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'shares', 'price'] >>> Sin embargo, \u00bfqu\u00e9 pasar\u00eda si pudieras usar los encabezados para algo \u00fatil? Aqu\u00ed es donde la zip() funci\u00f3n entra en escena. Primero intente esto para emparejar los encabezados del archivo con una fila de datos: >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> list(zip(headers, row)) [ ('name', 'AA'), ('shares', '100'), ('price', '32.20') ] >>> Observe c\u00f3mo se zip() emparejaron los encabezados de columna con los valores de columna. Hemos utilizado list() aqu\u00ed para convertir el resultado en una lista para que pueda verlo. Normalmente, zip() crea un iterador que debe consumir un bucle for. Este emparejamiento es un paso intermedio para crear un diccionario. Ahora prueba esto: >>> record = dict(zip(headers, row)) >>> record {'price': '32.20', 'name': 'AA', 'shares': '100'} >>> Esta transformaci\u00f3n es uno de los trucos m\u00e1s \u00fatiles que debe conocer al procesar muchos archivos de datos. Por ejemplo, suponga que desea que el pcost.py programa funcione con varios archivos de entrada, pero sin tener en cuenta el n\u00famero de columna real donde aparecen el nombre, las acciones y el precio. Modifique la portfolio_cost() funci\u00f3n pcost.py para que se vea as\u00ed: # pcost.py def portfolio_cost(filename): ... for rowno, row in enumerate(rows, start=1): record = dict(zip(headers, row)) try: nshares = int(record['shares']) price = float(record['price']) total_cost += nshares * price except ValueError: # Esto atrapa errores de conversi\u00f3n a int() y float() print(f'Fila {rowno}: Mala fila: {row}') ... Ahora, pruebe su funci\u00f3n en un archivo de datos completamente diferente Data/portfoliodate.csv que se ve as\u00ed: name,date,time,shares,price \"AA\",\"6/11/2007\",\"9:50am\",100,32.20 \"IBM\",\"5/13/2007\",\"4:20pm\",50,91.10 \"CAT\",\"9/23/2006\",\"1:30pm\",150,83.44 \"MSFT\",\"5/17/2007\",\"10:30am\",200,51.23 \"GE\",\"2/1/2006\",\"10:45am\",95,40.37 \"MSFT\",\"10/31/2006\",\"12:05pm\",50,65.10 \"IBM\",\"7/9/2006\",\"3:15pm\",100,70.44 >>> portfolio_cost('Data/portfoliodate.csv') 44671.15 >>> Si lo hizo bien, ver\u00e1 que su programa a\u00fan funciona a pesar de que el archivo de datos tiene un formato de columna completamente diferente al anterior. \u00a1Eso es genial! El cambio realizado aqu\u00ed es sutil, pero significativo. En lugar de portfolio_cost() estar codificado para leer un solo formato de archivo fijo, la nueva versi\u00f3n lee cualquier archivo CSV y selecciona los valores de inter\u00e9s. Siempre que el archivo tenga las columnas requeridas, el c\u00f3digo funcionar\u00e1. Modifique el report.py programa que escribi\u00f3 en la Secci\u00f3n 2.3 para que utilice la misma t\u00e9cnica para seleccionar encabezados de columna. Intente ejecutar el report.py programa en el Data/portfoliodate.csv archivo y vea que produce la misma respuesta que antes. Ejercicio 2.17: Invirtiendo un diccionario Un diccionario asigna claves a valores. Por ejemplo, un diccionario de precios de acciones. >>> prices = { 'GOOG': 490.1, 'AA': 23.45, 'IBM': 91.1, 'MSFT': 34.23 } >>> Si usa el m\u00e9todo items() , puede obtener pares (key,value) : >>> prices.items() dict_items([('GOOG', 490.1), ('AA', 23.45), ('IBM', 91.1), ('MSFT', 34.23)]) >>> Sin embargo, \u00bfqu\u00e9 pasar\u00eda si quisiera obtener una lista de pares (value, key) ? Sugerencia: use zip() . >>> pricelist = list(zip(prices.values(),prices.keys())) >>> pricelist [(490.1, 'GOOG'), (23.45, 'AA'), (91.1, 'IBM'), (34.23, 'MSFT')] >>> \u00bfPor qu\u00e9 har\u00edas esto? Por un lado, le permite realizar ciertos tipos de procesamiento de datos en los datos del diccionario. >>> min(pricelist) (23.45, 'AA') >>> max(pricelist) (490.1, 'GOOG') >>> sorted(pricelist) [(23.45, 'AA'), (34.23, 'MSFT'), (91.1, 'IBM'), (490.1, 'GOOG')] >>> Esto tambi\u00e9n ilustra una caracter\u00edstica importante de las tuplas. Cuando se usan en comparaciones, las tuplas se comparan elemento por elemento comenzando con el primer elemento. Similar a c\u00f3mo se comparan las cadenas car\u00e1cter por car\u00e1cter. zip() se utiliza a menudo en situaciones como esta en las que necesita emparejar datos de diferentes lugares. Por ejemplo, emparejar los nombres de las columnas con los valores de las columnas para crear un diccionario de valores con nombre. Tenga en cuenta que zip() no se limita a pares. Por ejemplo, puede usarlo con cualquier n\u00famero de listas de entrada: >>> a = [1, 2, 3, 4] >>> b = ['w', 'x', 'y', 'z'] >>> c = [0.2, 0.4, 0.6, 0.8] >>> list(zip(a, b, c)) [(1, 'w', 0.2), (2, 'x', 0.4), (3, 'y', 0.6), (4, 'z', 0.8))] >>> Adem\u00e1s, tenga en cuenta que zip() se detiene una vez que se agota la secuencia de entrada m\u00e1s corta. >>> a = [1, 2, 3, 4, 5, 6] >>> b = ['x', 'y', 'z'] >>> list(zip(a,b)) [(1, 'x'), (2, 'y'), (3, 'z')] >>> 2.5 El modulo collections El collections m\u00f3dulo proporciona una serie de objetos \u00fatiles para el manejo de datos. Esta parte presenta brevemente algunas de estas caracter\u00edsticas. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 2.5.1: Ejemplo: contando cosas Digamos que desea tabular el total de acciones de cada acci\u00f3n. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('IBM', 100, 45.23), ('GOOG', 75, 572.45), ('AA', 50, 23.15) ] Hay dos IBM entradas y dos GOOG entradas en esta lista. Las acciones deben combinarse de alguna manera. 2.5.2: Contadores Soluci\u00f3n: utilice un Counter . from collections import Counter total_shares = Counter() for name, shares, price in portfolio: total_shares[name] += shares total_shares['IBM'] # 150 2.5.3: Ejemplo: asignaciones uno-muchos Problema: desea asignar una clave a varios valores. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('IBM', 100, 45.23), ('GOOG', 75, 572.45), ('AA', 50, 23.15) ] Como en el ejemplo anterior, la clave IBM deber\u00eda tener dos tuplas diferentes en su lugar. Soluci\u00f3n: utilice un defaultdict . from collections import defaultdict holdings = defaultdict(list) for name, shares, price in portfolio: holdings[name].append((shares, price)) holdings['IBM'] # [ (50, 91.1), (100, 45.23) ] El defaultdict asegura que cada vez que acceda a una clave obtenga un valor predeterminado. 2.5.4: Ejemplo: un historial Problema: queremos un historial de las \u00faltimas N cosas. Soluci\u00f3n: utilice un deque . from collections import deque history = deque(maxlen=N) with open(filename) as f: for line in f: history.append(line) ... 2.5.5: Ejercicios El collections m\u00f3dulo puede ser uno de los m\u00f3dulos de biblioteca m\u00e1s \u00fatiles para tratar tipos de problemas de manejo de datos con fines especiales, como la tabulaci\u00f3n y la indexaci\u00f3n. En este ejercicio, veremos algunos ejemplos simples. Comience ejecutando su report.py programa para que tenga la cartera de acciones cargada en el modo interactivo. bash % python3 -i report.py Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 2.18: Tabulaci\u00f3n con contadores Suponga que desea tabular el n\u00famero total de acciones de cada acci\u00f3n. Esto es f\u00e1cil de usar Counter objetos. Intentalo: >>> portfolio = read_portfolio('Data/portfolio.csv') >>> from collections import Counter >>> holdings = Counter() >>> for s in portfolio: holdings[s['name']] += s['shares'] >>> holdings Counter({'MSFT': 250, 'IBM': 150, 'CAT': 150, 'AA': 100, 'GE': 95}) >>> Observe cuidadosamente c\u00f3mo las m\u00faltiples entradas para MSFT y IBM en portfolio se combinan en una sola entrada aqu\u00ed. Puede usar un contador como un diccionario para recuperar valores individuales: >>> holdings['IBM'] 150 >>> holdings['MSFT'] 250 >>> Si desea clasificar los valores, haga esto: >>> # Get three most held stocks >>> holdings.most_common(3) [('MSFT', 250), ('IBM', 150), ('CAT', 150)] >>> Tomemos otra cartera de acciones y creemos un nuevo contador: >>> portfolio2 = read_portfolio('Data/portfolio2.csv') >>> holdings2 = Counter() >>> for s in portfolio2: holdings2[s['name']] += s['shares'] >>> holdings2 Counter({'HPQ': 250, 'GE': 125, 'AA': 50, 'MSFT': 25}) >>> Finalmente, combinemos todas las existencias haciendo una operaci\u00f3n simple: >>> holdings Counter({'MSFT': 250, 'IBM': 150, 'CAT': 150, 'AA': 100, 'GE': 95}) >>> holdings2 Counter({'HPQ': 250, 'GE': 125, 'AA': 50, 'MSFT': 25}) >>> combined = holdings + holdings2 >>> combined Counter({'MSFT': 275, 'HPQ': 250, 'GE': 220, 'AA': 150, 'IBM': 150, 'CAT': 150}) >>> Esto es solo una peque\u00f1a muestra de lo que ofrecen los contadores. Sin embargo, si alguna vez necesita tabular valores, deber\u00eda considerar usar uno. 2.5.6: Comentario: el modulo collections El m\u00f3dulo collections es uno de los m\u00f3dulos de biblioteca m\u00e1s \u00fatiles de todo Python. De hecho, podr\u00edamos hacer un tutorial extenso sobre eso. Sin embargo, hacerlo ahora tambi\u00e9n ser\u00eda una distracci\u00f3n. Por ahora, ponga collections su lista de lecturas a la hora de dormir para m\u00e1s tarde. 2.6 Comprensi\u00f3n de Listas Una tarea com\u00fan es procesar elementos en una lista. Esta secci\u00f3n presenta listas por comprensi\u00f3n, una poderosa herramienta para hacer precisamente eso. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 2.6.1: Creando nuevas listas Una lista de comprensi\u00f3n crea una nueva lista aplicando una operaci\u00f3n a cada elemento de una secuencia. >>> a = [1, 2, 3, 4, 5] >>> b = [2*x for x in a ] >>> b [2, 4, 6, 8, 10] >>> Otro ejemplo: >>> names = ['Elwood', 'Jake'] >>> a = [name.lower() for name in names] >>> a ['elwood', 'jake'] >>> La sintaxis general es: [ <expresi\u00f3n> for <variable_nombre> in <secuencia> ] . 2.6.2: Filtrar Tambi\u00e9n puede filtrar durante la comprensi\u00f3n de la lista. >>> a = [1, -5, 4, 2, -2, 10] >>> b = [2*x for x in a if x > 0 ] >>> b [2, 8, 4, 20] >>> 2.6.3: Casos de uso Las listas por comprensi\u00f3n son muy \u00fatiles. Por ejemplo, puede recopilar valores de campos de un diccionario espec\u00edfico: stocknames = [s['name'] for s in stocks] Puede realizar consultas similares a bases de datos en secuencias. a = [s for s in stocks if s['price'] > 100 and s['shares'] > 50 ] Tambi\u00e9n puede combinar una comprensi\u00f3n de lista con una reducci\u00f3n de secuencia: cost = sum([s['shares']*s['price'] for s in stocks]) 2.6.4: Sintaxis general [ <expresi\u00f3n> for <variable_nombre> in <secuencia> si <condici\u00f3n>] Que significa: result = [] for variable_name in sequence: if condition: result.append(expression) 2.6.5: Digresi\u00f3n hist\u00f3rica Las listas por comprensi\u00f3n provienen de las matem\u00e1ticas (notaci\u00f3n del generador de conjuntos). a = [ x * x for x in s if x > 0 ] # Python a = { x^2 | x \u2208 s, x > 0 } # Math Tambi\u00e9n se implementa en varios otros idiomas. Sin embargo, la mayor\u00eda de los programadores probablemente no est\u00e9n pensando en su clase de matem\u00e1ticas. Entonces, est\u00e1 bien verlo como un atajo de lista genial. 2.6.6: Ejercicios Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Comience ejecutando su report.py programa para que tenga la cartera de acciones cargada en el modo interactivo. bash % python3 -i report.py Ejercicio 2.19: Comprension de listas Pruebe algunas comprensiones de listas simples solo para familiarizarse con la sintaxis. >>> nums = [1,2,3,4] >>> squares = [ x * x for x in nums ] >>> squares [1, 4, 9, 16] >>> twice = [ 2 * x for x in nums if x > 2 ] >>> twice [6, 8] >>> Observe c\u00f3mo las listas por comprensi\u00f3n est\u00e1n creando una nueva lista con los datos adecuadamente transformados o filtrados. Ejercicio 2.20: Reducciones de secuencia Calcule el costo total de la cartera con una sola declaraci\u00f3n de Python. >>> portfolio = read_portfolio('Data/portfolio.csv') >>> cost = sum([ s['shares'] * s['price'] for s in portfolio ]) >>> cost 44671.15 >>> Despu\u00e9s de haber hecho eso, muestre c\u00f3mo puede calcular el valor actual de la cartera con un solo extracto. >>> value = sum([ s['shares'] * prices[s['name']] for s in portfolio ]) >>> value 28686.1 >>> Ambas operaciones anteriores son un ejemplo de reducci\u00f3n de mapa. La comprensi\u00f3n de la lista est\u00e1 mapeando una operaci\u00f3n a lo largo de la lista. >>> [ s['shares'] * s['price'] for s in portfolio ] [3220.0000000000005, 4555.0, 12516.0, 10246.0, 3835.1499999999996, 3254.9999999999995, 7044.0] >>> La sum() funci\u00f3n est\u00e1 realizando despu\u00e9s una reducci\u00f3n en todo el resultado: >>> sum(_) 44671.15 >>> Con este conocimiento, ahora est\u00e1 listo para lanzar una nueva empresa de big data. Ejercicio 2.21: Consulta de datos Pruebe los siguientes ejemplos de varias consultas de datos. Primero, una lista de todas las posiciones de la cartera con m\u00e1s de 100 acciones. >>> more100 = [ s for s in portfolio if s['shares'] > 100 ] >>> more100 [{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}] >>> Todas las posiciones en cartera de acciones de MSFT e IBM. >>> msftibm = [ s for s in portfolio if s['name'] in {'MSFT','IBM'} ] >>> msftibm [{'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}] >>> Una lista de todas las tenencias de la cartera que cuestan m\u00e1s de $10000 . >>> cost10k = [ s for s in portfolio if s['shares'] * s['price'] > 10000 ] >>> cost10k [{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}] >>> Ejercicio 2.22: Extracci\u00f3n de datos Mostrar c\u00f3mo se podr\u00eda construir una lista de tuplas (name, shares) , donde name y shares son tomados de portfolio . >>> name_shares =[ (s['name'], s['shares']) for s in portfolio ] >>> name_shares [('AA', 100), ('IBM', 50), ('CAT', 150), ('MSFT', 200), ('GE', 95), ('MSFT', 50), ('IBM', 100)] >>> Si cambia los corchetes ( [ , ] ) por llaves ( { , } ), obtendr\u00e1 algo conocido como comprensi\u00f3n de conjuntos. Esto le brinda valores \u00fanicos o distintos. Por ejemplo, esto determina el conjunto de nombres de acciones \u00fanicos que aparecen en portfolio : >>> names = { s['name'] for s in portfolio } >>> names { 'AA', 'GE', 'IBM', 'MSFT', 'CAT'] } >>> Si especifica key:value pares, puede crear un diccionario. Por ejemplo, cree un diccionario que asigne el nombre de una acci\u00f3n al n\u00famero total de acciones que posee. >>> holdings = { name: 0 for name in names } >>> holdings {'AA': 0, 'GE': 0, 'IBM': 0, 'MSFT': 0, 'CAT': 0} >>> Esta \u00faltima caracter\u00edstica se conoce como comprensi\u00f3n de diccionario . Vamos a tabular: >>> for s in portfolio: holdings[s['name']] += s['shares'] >>> holdings { 'AA': 100, 'GE': 95, 'IBM': 150, 'MSFT':250, 'CAT': 150 } >>> Pruebe este ejemplo que filtra el diccionario prices solo a los nombres que aparecen en la cartera: >>> portfolio_prices = { name: prices[name] for name in names } >>> portfolio_prices {'AA': 9.22, 'GE': 13.48, 'IBM': 106.28, 'MSFT': 20.89, 'CAT': 35.46} >>> Ejercicio 2.23: Extracci\u00f3n de datos desde archivos CSV Saber c\u00f3mo utilizar varias combinaciones de comprensiones de listas, conjuntos y diccionarios puede resultar \u00fatil en diversas formas de procesamiento de datos. A continuaci\u00f3n, se muestra un ejemplo que muestra c\u00f3mo extraer columnas seleccionadas de un archivo CSV. Primero, lea una fila de informaci\u00f3n de encabezado de un archivo CSV: >>> import csv >>> f = open('Data/portfoliodate.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'date', 'time', 'shares', 'price'] >>> A continuaci\u00f3n, defina una variable que enumere las columnas que realmente le interesan: >>> select = ['name', 'shares', 'price'] >>> Ahora, ubique los \u00edndices de las columnas anteriores en el archivo CSV de origen: >>> indices = [ headers.index(colname) for colname in select ] >>> indices [0, 3, 4] >>> Finalmente, lea una fila de datos y convi\u00e9rtala en un diccionario usando una comprensi\u00f3n de diccionario: >>> row = next(rows) >>> record = { colname: row[index] for colname, index in zip(select, indices) } # dict-comprehension >>> record {'price': '32.20', 'name': 'AA', 'shares': '100'} >>> Si se siente c\u00f3modo con lo que acaba de suceder, lea el resto del archivo: >>> portfolio = [ { colname: row[index] for colname, index in zip(select, indices) } for row in rows ] >>> portfolio [{'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> Vaya, acabas de reducir gran parte de la read_portfolio() funci\u00f3n a una sola declaraci\u00f3n. Comentario Las listas por comprensi\u00f3n se utilizan com\u00fanmente en Python como un medio eficaz para transformar, filtrar o recopilar datos. Debido a la sintaxis, no querr\u00e1 exagerar; intente que la comprensi\u00f3n de cada lista sea lo m\u00e1s simple posible. Est\u00e1 bien dividir las cosas en varios pasos. Por ejemplo, no est\u00e1 claro si le gustar\u00eda dar ese \u00faltimo ejemplo a sus compa\u00f1eros de trabajo desprevenidos. Dicho esto, saber c\u00f3mo manipular datos r\u00e1pidamente es una habilidad incre\u00edblemente \u00fatil. Existen numerosas situaciones en las que es posible que deba resolver alg\u00fan tipo de problema \u00fanico que involucre la importaci\u00f3n, exportaci\u00f3n, extracci\u00f3n de datos, etc. Convertirse en un maestro gur\u00fa de la comprensi\u00f3n de listas puede reducir sustancialmente el tiempo dedicado a idear una soluci\u00f3n. Adem\u00e1s, no se olvide del collections m\u00f3dulo. 2.7 Objetos Esta secci\u00f3n presenta m\u00e1s detalles sobre el modelo de objetos internos de Python y analiza algunos asuntos relacionados con la administraci\u00f3n de memoria, la copia y la verificaci\u00f3n de tipos. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador 2.7.1: Asignacion Muchas operaciones en Python est\u00e1n relacionadas con la asignaci\u00f3n o el almacenamiento de valores. a = value # Asignaci\u00f3n a una variable s[n] = value # Asignaci\u00f3n a una lista s.append(value) # Agregando a una lista d['key'] = value # Agregando a un diccionario Una advertencia: las operaciones de asignaci\u00f3n nunca hacen una copia del valor asignado. Todas las asignaciones son simplemente copias de referencia (o copias de puntero si lo prefiere). 2.7.2: Ejemplo de asignacion Considere este fragmento de c\u00f3digo. a = [1,2,3] b = a c = [a,b] Una imagen de las operaciones de memoria subyacentes. En este ejemplo, solo hay un objeto de lista [1,2,3] , pero hay cuatro referencias diferentes a \u00e9l. Esto significa que la modificaci\u00f3n de un valor afecta a todas las referencias. >>> a.append(999) >>> a [1,2,3,999] >>> b [1,2,3,999] >>> c [[1,2,3,999], [1,2,3,999]] >>> Observe c\u00f3mo un cambio en la lista original aparece en todas partes (\u00a1ay!). Esto se debe a que nunca se hicieron copias. Todo apunta a lo mismo. 2.7.3: Reasignacion de valores La reasignaci\u00f3n de un valor nunca sobrescribe la memoria utilizada por el valor anterior. a = [1,2,3] b = a a = [4,5,6] print(a) # [4, 5, 6] print(b) # [1, 2, 3] Tiene el valor original Recuerde: las variables son nombres, no ubicaciones de memoria. 2.7.4: Algunos peligros Si no sabe acerca de este intercambio, se disparar\u00e1 en el pie en alg\u00fan momento. Escenario t\u00edpico. Modifica algunos datos pensando que es su propia copia privada y accidentalmente corrompe algunos datos en alguna otra parte del programa. Comentario: Esta es una de las razones por las que los tipos de datos primitivos (int, float, string) son inmutables (solo lectura). 2.7.5: Identidad y referencia Utilice el operador is para comprobar si dos valores son exactamente el mismo objeto. >>> a = [1,2,3] >>> b = a >>> a is b True >>> is compara la identidad del objeto (un n\u00famero entero). La identidad se puede obtener utilizando id() . >>> id(a) 3588944 >>> id(b) 3588944 >>> Nota: Casi siempre es mejor utilizar == para comparar objetos. El comportamiento de is suele ser inesperado: >>> a = [1,2,3] >>> b = a >>> c = [1,2,3] >>> a is b True >>> a is c False >>> a == c # hmm... \u00bfpor qu\u00e9? True >>> 2.7.6: Copias superficiales Las listas y los dictados tienen m\u00e9todos para copiar. >>> a = [2,3,[100,101],4] >>> b = list(a) # Make a copy >>> a is b False Es una lista nueva, pero los elementos de la lista se comparten. >>> a[2].append(102) >>> b[2] [100,101,102] >>> >>> a[2] is b[2] True >>> Por ejemplo, [100, 101, 102] se comparte la lista interna . Esto se conoce como copia superficial. Aqu\u00ed tienes una foto. 2.7.8: Copias profundas A veces es necesario hacer una copia de un objeto y todos los objetos que contiene. Puede utilizar el m\u00f3dulo copy para esto: >>> a = [2,3,[100,101],4] >>> import copy >>> b = copy.deepcopy(a) >>> a[2].append(102) >>> b[2] [100,101] >>> a[2] is b[2] False >>> 2.7.9: Nombres, valores, tipos Los nombres de las variables no tienen tipo . Es solo un nombre. Sin embargo, los valores no tienen un tipo subyacente. >>> a = 42 >>> b = 'Hello World' >>> type(a) <type 'int'> >>> type(b) <type 'str'> type() te dir\u00e1 qu\u00e9 es. El nombre del tipo se usa generalmente como una funci\u00f3n que crea o convierte un valor a ese tipo. 2.7.10: Verificaci\u00f3n de tipo C\u00f3mo saber si un objeto es de un tipo espec\u00edfico. if isinstance(a, list): print('a is a list') Comprobando uno de los muchos tipos posibles. if isinstance(a, (list,tuple)): print('a is a list or tuple') Precauci\u00f3n: No se exceda con la verificaci\u00f3n de tipos. Puede conducir a una complejidad de c\u00f3digo excesiva. Por lo general, solo lo har\u00eda si al hacerlo evitar\u00eda errores comunes cometidos por otros que usan su c\u00f3digo. 2.7.11: Todo es un objeto Los n\u00fameros, cadenas, listas, funciones, excepciones, clases, instancias, etc. son todos objetos. Significa que todos los objetos que se pueden nombrar pueden pasarse como datos, colocarse en contenedores, etc., sin ninguna restricci\u00f3n. No hay tipos especiales de objetos. A veces se dice que todos los objetos son de \"primera clase\". Un simple ejemplo: >>> import math >>> items = [abs, math, ValueError ] >>> items [<built-in function abs>, <module 'math' (builtin)>, <type 'exceptions.ValueError'>] >>> items[0](-45) 45 >>> items[1].sqrt(2) 1.4142135623730951 >>> try: x = int('not a number') except items[2]: print('Failed!') Failed! >>> Aqu\u00ed items hay una lista que contiene una funci\u00f3n, un m\u00f3dulo y una excepci\u00f3n. Puede utilizar directamente los elementos de la lista en lugar de los nombres originales: items[0](-45) # abs items[1].sqrt(2) # math except items[2]: # ValueError Un gran poder conlleva responsabilidad. El hecho de que pueda hacer eso no significa que deba hacerlo. 2.33: Ejercicios En este conjunto de ejercicios, analizamos parte del poder que proviene de los objetos de primera clase. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Ejercicio 2.24: Data de primera-clase En el archivo Data/portfolio.csv , leemos datos organizados como columnas que se ven as\u00ed: name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 ... En el c\u00f3digo anterior, us\u00e1bamos el csv m\u00f3dulo para leer el archivo, pero a\u00fan ten\u00edamos que realizar conversiones de tipo manuales. Por ejemplo: for row in rows: name = row[0] shares = int(row[1]) price = float(row[2]) Este tipo de conversi\u00f3n tambi\u00e9n se puede realizar de una manera m\u00e1s inteligente utilizando algunas operaciones b\u00e1sicas de lista. Haga una lista de Python que contenga los nombres de las funciones de conversi\u00f3n que usar\u00eda para convertir cada columna en el tipo apropiado: >>> types = [str, int, float] >>> La raz\u00f3n por la que incluso puede crear esta lista es que todo en Python es de primera clase . Entonces, si desea tener una lista de funciones, est\u00e1 bien. Los elementos de la lista que ha creado son funciones para convertir un valor x en un tipo determinado (por ejemplo, str(x) , int(x) , float(x) ). Ahora, lea una fila de datos del archivo anterior: >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> Como se se\u00f1al\u00f3, esta fila no es suficiente para hacer c\u00e1lculos porque los tipos son incorrectos. Por ejemplo: >>> row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiply sequence by non-int of type 'str' >>> Sin embargo, tal vez los datos se puedan emparejar con los tipos que especific\u00f3 en types . Por ejemplo: >>> types[1] <type 'int'> >>> row[1] '100' >>> Intente convertir uno de los valores: >>> types[1](row[1]) # Same as int(row[1]) 100 >>> Intente convertir un valor diferente: >>> types[2](row[2]) # Same as float(row[2]) 32.2 >>> Pruebe el c\u00e1lculo con valores convertidos: >>> types[1](row[1])*types[2](row[2]) 3220.0000000000005 >>> Comprima los tipos de columna con los campos y observe el resultado: >>> r = list(zip(types, row)) >>> r [(<type 'str'>, 'AA'), (<type 'int'>, '100'), (<type 'float'>,'32.20')] >>> Notar\u00e1 que esto ha emparejado una conversi\u00f3n de tipo con un valor. Por ejemplo, int se empareja con el valor '100' . La lista comprimida es \u00fatil si desea realizar conversiones en todos los valores, uno tras otro. Prueba esto: >>> converted = [] >>> for func, val in zip(types, row): converted.append(func(val)) ... >>> converted ['AA', 100, 32.2] >>> converted[1] * converted[2] 3220.0000000000005 >>> Aseg\u00farese de comprender lo que sucede en el c\u00f3digo anterior. En el bucle, la func variable es una de las funciones de conversi\u00f3n de tipo (por ejemplo, str , int , etc.) y la val variable es uno de los valores como 'AA' , '100' . La expresi\u00f3n func(val) est\u00e1 convirtiendo un valor (algo as\u00ed como un tipo de conversi\u00f3n). El c\u00f3digo anterior se puede comprimir en una sola lista comprensiva. >>> converted = [func(val) for func, val in zip(types, row)] >>> converted ['AA', 100, 32.2] >>> Ejercicio 2.25: Creando diccionarios \u00bfRecuerda c\u00f3mo la funci\u00f3n dict() puede hacer f\u00e1cilmente un diccionario si tiene una secuencia de nombres y valores clave? Hagamos un diccionario a partir de los encabezados de las columnas: >>> headers ['name', 'shares', 'price'] >>> converted ['AA', 100, 32.2] >>> dict(zip(headers, converted)) {'price': 32.2, 'name': 'AA', 'shares': 100} >>> Por supuesto, si est\u00e1 en su lista de comprensi\u00f3n fu, puede hacer toda la conversi\u00f3n en un solo paso usando un dict-comprehension: >>> { name: func(val) for name, func, val in zip(headers, types, row) } {'price': 32.2, 'name': 'AA', 'shares': 100} >>> Ejercicio 2.26: El horizonte Con las t\u00e9cnicas de este ejercicio, podr\u00eda escribir declaraciones que conviertan f\u00e1cilmente campos de casi cualquier archivo de datos orientado a columnas en un diccionario de Python. Solo para ilustrar, suponga que lee datos de un archivo de datos diferente como este: >>> f = open('Data/dowstocks.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> headers ['name', 'price', 'date', 'time', 'change', 'open', 'high', 'low', 'volume'] >>> row ['AA', '39.48', '6/11/2007', '9:36am', '-0.18', '39.67', '39.69', '39.45', '181800'] >>> Convirtamos los campos usando un truco similar: >>> types = [str, float, str, str, float, float, float, float, int] >>> converted = [func(val) for func, val in zip(types, row)] >>> record = dict(zip(headers, converted)) >>> record {'volume': 181800, 'name': 'AA', 'price': 39.48, 'high': 39.69, 'low': 39.45, 'time': '9:36am', 'date': '6/11/2007', 'open': 39.67, 'change': -0.18} >>> record['name'] 'AA' >>> record['price'] 39.48 >>> Extra: \u00bfC\u00f3mo modificar\u00eda este ejemplo para analizar adicionalmente la entrada date en una tupla como (6, 11, 2007) ? Dedique alg\u00fan tiempo a reflexionar sobre lo que ha hecho en este ejercicio. Revisaremos estas ideas un poco m\u00e1s tarde.","title":"2 Trabajando con Data"},{"location":"2/#2-trabajando-con-data","text":"Conoceremos las estructuras de datos de fundamental importancia en Python: tuples, lists, sets y dictionaries. Presentaremos algunos patrones comunes para el manejo de datos y discutiremos el modelo de objetos en Python. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2. Trabajando con data"},{"location":"2/#21-tipos-y-estructuras-de-data","text":"Esta secci\u00f3n presenta estructuras de datos en forma de tuplas y diccionarios.","title":"2.1 Tipos y estructuras de data"},{"location":"2/#211-tipos-primitivos","text":"Python tiene algunos tipos primitivos de datos: Enteros N\u00fameros de punto flotante Cadenas (texto) Aprendimos sobre esto en la introducci\u00f3n.","title":"2.1.1 Tipos primitivos"},{"location":"2/#212-tipo-none","text":"email_address = None None se utiliza a menudo como marcador de posici\u00f3n para un valor opcional o faltante. Eso se eval\u00faa como \"Falso\" en condicionales. if email_address: send_email(email_address, msg)","title":"2.1.2 Tipo None"},{"location":"2/#213-estructuras-de-data","text":"Los programas reales tienen datos m\u00e1s complejos. Por ejemplo, informaci\u00f3n sobre una participaci\u00f3n en acciones: 100 acciones de GOOG a $490.10 Este es un \"objeto\" con tres partes: Nombre o s\u00edmbolo de la acci\u00f3n (\"GOOG\", una cadena) N\u00famero de acciones (100, un n\u00famero entero) Precio (490,10 un punto flotante)","title":"2.1.3: Estructuras de data"},{"location":"2/#214-tuplas","text":"Una tupla es una colecci\u00f3n de valores agrupados. Ejemplo: s = ('GOOG', 100, 490.1) A veces el () es omitido. s = 'GOOG', 100, 490.1' Casos especiales (0-tupla, 1-tupla). t = () # Una tupla vac\u00eda w = ('GOOG', ) # Una tupla de 1-item Las tuplas se utilizan a menudo para representar registros o estructuras simples . Normalmente, es un \u00fanico objeto de varias partes. Una buena analog\u00eda: Una tupla es como una sola fila en una tabla de base de datos. El contenido de la tupla est\u00e1 ordenado (como una matriz). s = ('GOOG', 100, 490.1) name = s[0] # 'GOOG' shares = s[1] # 100 price = s[2] # 490.1 Sin embargo, el contenido no se puede modificar. >>> s[1] = 75 TypeError: object does not support item assignment Sin embargo, puede crear una nueva tupla basada en una tupla actual. s = (s[0], 75, s[2]) Las tuplas tienen m\u00e1s que ver con empaquetar elementos relacionados en una sola entidad , que con cualquier otra cosa. s = ('GOOG', 100, 490.1) Por tanto, la tupla es f\u00e1cil de pasar a otras partes de un programa como un solo objeto.","title":"2.1.4: Tuplas"},{"location":"2/#215-desempaque-de-tuplas","text":"Para usar la tupla en otro lugar, puede desempaquetar sus partes en variables. name, shares, price = s print('Cost', shares * price) The number of variables on the left must match the tuple structure. name, shares = s # ERROR Traceback (most recent call last): ... ValueError: too many values to unpack","title":"2.1.5: Desempaque de Tuplas"},{"location":"2/#216-tuplas-vs-listas","text":"Tuples look like read-only lists. However, tuples are most often used for a single item consisting of multiple parts. Lists are usually a collection of distinct items, usually all of the same type. record = ('GOOG', 100, 490.1) # Una tupla que representa un registro en una cartera symbols = [ 'GOOG', 'AAPL', 'IBM' ] # Una lista que representa tres s\u00edmbolos de acciones","title":"2.1.6 Tuplas vs Listas"},{"location":"2/#217-diccionarios","text":"Un diccionario es la asignaci\u00f3n de claves a valores. A veces tambi\u00e9n se le llama una tabla hash o matriz asociativa. Las claves sirven como \u00edndices para acceder a los valores. s = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 }","title":"2.1.7 Diccionarios"},{"location":"2/#218-operaciones-comunes","text":"To get values from a dictionary use the key names. >>> print(s['name'], s['shares']) GOOG 100 >>> s['price'] 490.10 >>> Para agregar o modificar valores, asigne usando los nombres de las claves. >>> s['shares'] = 75 >>> s['date'] = '6/6/2007' >>> Para eliminar un valor, use la instrucci\u00f3n del . >>> del s['date'] >>>","title":"2.1.8 Operaciones comunes"},{"location":"2/#219-porque-diccionarios","text":"Los diccionarios son \u00fatiles cuando hay * muchos * valores diferentes y esos valores puede ser modificado o manipulado. Los diccionarios hacen que su c\u00f3digo sea m\u00e1s legible. s['price'] # vs s[2]","title":"2.1.9 \u00bfPorqu\u00e9 diccionarios?"},{"location":"2/#2110-ejercicios","text":"En los \u00faltimos ejercicios, escribi\u00f3 un programa que lee un archivo de datos Data/portfolio.csv . Usando el m\u00f3dulo csv , es f\u00e1cil leer el archivo fila por fila. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> next(rows) ['name', 'shares', 'price'] >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> Aunque leer el archivo es f\u00e1cil, a menudo querr\u00e1 hacer m\u00e1s con el datos que leerlos. Por ejemplo, tal vez desee almacenarlo y comience a realizar algunos c\u00e1lculos sobre \u00e9l. Desafortunadamente, una \"fila\" sin procesar de datos no le da suficiente para trabajar. Por ejemplo, incluso un el c\u00e1lculo matem\u00e1tico simple no funciona: >>> row = ['AA', '100', '32.20'] >>> cost = row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiply sequence by non-int of type 'str' >>> Para hacer m\u00e1s, normalmente desea interpretar los datos sin procesar de alguna manera y convertirlo en un tipo de objeto m\u00e1s \u00fatil para que pueda trabajar con \u00e9l m\u00e1s tarde. Dos opciones simples son tuplas o diccionarios.","title":"2.1.10 Ejercicios"},{"location":"2/#ejercicio-21-tuplas","text":"En el indicador interactivo, cree la siguiente tupla que represente la fila anterior, pero con las columnas num\u00e9ricas convertidas a los n\u00fameros adecuados: >>> t = (row[0], int(row[1]), float(row[2])) >>> t ('AA', 100, 32.2) >>> Con esto, ahora puede calcular el costo total multiplicando las acciones y el precio: >>> cost = t[1] * t[2] >>> cost 3220.0000000000005 >>> \u00bfLas matem\u00e1ticas est\u00e1n rotas en Python? \u00bfCu\u00e1l es el problema con la respuesta de 3220.0000000000005? Este es un artefacto del hardware de punto flotante en su computadora que solo puede representar decimales con precisi\u00f3n en Base-2, no en Base-10. Incluso para c\u00e1lculos simples que involucran decimales en base 10, se introducen peque\u00f1os errores. Esto es normal, aunque quiz\u00e1s un poco sorprendente si no lo ha visto antes. Esto sucede en todos los lenguajes de programaci\u00f3n que utilizan decimales de punto flotante, pero a menudo se oculta al imprimir. Por ejemplo: >>> print(f'{cost:0.2f}') 3220.00 >>> Las tuplas son de solo lectura. Verifique esto intentando cambiar el n\u00famero de acciones a 75. >>> t[1] = 75 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> Aunque no puede cambiar el contenido de la tupla, siempre puede crear una tupla completamente nueva que reemplace a la anterior. >>> t = (t[0], 75, t[2]) >>> t ('AA', 75, 32.2) >>> Siempre que reasigne un nombre de variable existente como este, el valor anterior se descarta. Aunque la asignaci\u00f3n anterior puede parecer que est\u00e1 modificando la tupla, en realidad est\u00e1 creando una nueva tupla y desechando la anterior. Las tuplas se utilizan a menudo para empaquetar y descomprimir valores en variables. Intente lo siguiente: >>> name, shares, price = t >>> name 'AA' >>> shares 75 >>> price 32.2 >>> Tome las variables anteriores y vuelva a empaquetarlas en una tupla >>> t = (name, 2*shares, price) >>> t ('AA', 150, 32.2) >>>","title":"Ejercicio 2.1: Tuplas"},{"location":"2/#ejercicio-22-diccionarios-como-estructura-de-datos","text":"Una alternativa a una tupla es crear un diccionario. >>> d = { 'name' : row[0], 'shares' : int(row[1]), 'price' : float(row[2]) } >>> d {'name': 'AA', 'shares': 100, 'price': 32.2 } >>> Calcule el costo total de esta participaci\u00f3n: >>> cost = d['shares'] * d['price'] >>> cost 3220.0000000000005 >>> Compare este ejemplo con el mismo c\u00e1lculo que involucra tuplas anterior. Cambie el n\u00famero de acciones a 75. >>> d['shares'] = 75 >>> d {'name': 'AA', 'shares': 75, 'price': 32.2 } >>> A diferencia de las tuplas, los diccionarios se pueden modificar libremente. Agrega algunos atributos: >>> d['date'] = (6, 11, 2007) >>> d['account'] = 12345 >>> d {'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007), 'account': 12345} >>>","title":"Ejercicio 2.2: Diccionarios como estructura de datos"},{"location":"2/#ejercicio-23-otras-operaciones-adicionales","text":"Si convierte un diccionario en una lista, obtendr\u00e1 todas sus claves: >>> list(d) ['name', 'shares', 'price', 'date', 'account'] >>> De manera similar, si usa la fordeclaraci\u00f3n para iterar en un diccionario, obtendr\u00e1 las claves: >>> for k in d: print('k =', k) k = name k = shares k = price k = date k = account >>> Pruebe esta variante que realiza una b\u00fasqueda al mismo tiempo: >>> for k in d: print(k, '=', d[k]) name = AA shares = 75 price = 32.2 date = (6, 11, 2007) account = 12345 >>> Tambi\u00e9n puede obtener todas las claves utilizando el m\u00e9todo keys() : >>> keys = d.keys() >>> keys dict_keys(['name', 'shares', 'price', 'date', 'account']) >>> keys()es un poco inusual porque devuelve un dict_keysobjeto especial . Se trata de una superposici\u00f3n del diccionario original que siempre le proporciona las claves actuales, incluso si el diccionario cambia. Por ejemplo, intente esto: >>> del d['account'] >>> keys dict_keys(['name', 'shares', 'price', 'date']) >>> Observe cuidadosamente que 'account'desapareci\u00f3 keysaunque no volvi\u00f3 a llamar d.keys(). Una forma m\u00e1s elegante de trabajar con claves y valores juntos es utilizar el items()m\u00e9todo. Esto te da (key, value)tuplas: >>> items = d.items() >>> items dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))]) >>> for k, v in d.items(): print(k, '=', v) name = AA shares = 75 price = 32.2 date = (6, 11, 2007) >>> Si tiene tuplas como items, puede crear un diccionario usando la dict()funci\u00f3n. Intentalo: >>> items dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))]) >>> d = dict(items) >>> d {'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007)} >>>","title":"Ejercicio 2.3: Otras operaciones adicionales"},{"location":"2/#22-contenedores","text":"","title":"2.2 Contenedores"},{"location":"2/#221-vision-general","text":"Los programas a menudo tienen que trabajar con muchos objetos. Una cartera de acciones Una tabla de precios de acciones Hay tres opciones principales para usar. Listas. Datos ordenados. Diccionarios. Datos desordenados. Conjuntos. Colecci\u00f3n desordenada de art\u00edculos \u00fanicos.*","title":"2.2.1: Visi\u00f3n General"},{"location":"2/#222-listas-como-un-contenedor","text":"Utilice una lista cuando sea importante el orden de los datos. Recuerde que las listas pueden contener cualquier tipo de objeto. Por ejemplo, una lista de tuplas. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.3), ('CAT', 150, 83.44) ] portfolio[0] # ('GOOG', 100, 490.1) portfolio[2] # ('CAT', 150, 83.44)","title":"2.2.2: Listas como un Contenedor"},{"location":"2/#223-construccion-de-una-lista","text":"Construyendo una lista desde cero. records = [] # lista inicial # Use .append() para agregar mas items records.append(('GOOG', 100, 490.10)) records.append(('IBM', 50, 91.3)) ... Un ejemplo al leer registros de un archivo. records = [] # lista inicial with open('Data/portfolio.csv', 'rt') as f: next(f) # Nos saltamos el encabezado for line in f: row = line.split(',') records.append((row[0], int(row[1]), float(row[2])))","title":"2.2.3: Construcci\u00f3n de una lista"},{"location":"2/#224-diccionarios-como-contenedores","text":"Los diccionarios son \u00fatiles si desea b\u00fasquedas aleatorias r\u00e1pidas (por nombre de clave). Por ejemplo, un diccionario de precios de acciones: prices = { 'GOOG': 513.25, 'CAT': 87.22, 'IBM': 93.37, 'MSFT': 44.12 } Aqu\u00ed hay algunas b\u00fasquedas simples: >>> prices['IBM'] 93.37 >>> prices['GOOG'] 513.25 >>>","title":"2.2.4: Diccionarios como contenedores"},{"location":"2/#225-construccion-de-un-diccionario","text":"Ejemplo de construcci\u00f3n de un dictado desde cero. prices = {} # Initial empty dict # Insert new items prices['GOOG'] = 513.25 prices['CAT'] = 87.22 prices['IBM'] = 93.37 Un ejemplo que completa el dict a partir del contenido de un archivo. prices = {} # Initial empty dict with open('Data/prices.csv', 'rt') as f: for line in f: row = line.split(',') prices[row[0]] = float(row[1]) Nota: Si prueba esto en el Data/prices.csvarchivo, encontrar\u00e1 que casi funciona; hay una l\u00ednea en blanco al final que hace que se bloquee. Necesitar\u00e1 encontrar alguna forma de modificar el c\u00f3digo para tener en cuenta eso (vea el ejercicio 2.6).","title":"2.2.5: Construcci\u00f3n de un diccionario"},{"location":"2/#226-busquedas-de-diccionario","text":"Puede probar la existencia de una clave. if key in d: # YES else: # NO Puede buscar un valor que podr\u00eda no existir y proporcionar un valor predeterminado en caso de que no exista. name = d.get(key, default) Un ejemplo: >>> prices.get('IBM', 0.0) 93.37 >>> prices.get('SCOX', 0.0) 0.0 >>>","title":"2.2.6: B\u00fasquedas de diccionario"},{"location":"2/#227-claves-compuestas","text":"Casi cualquier tipo de valor se puede utilizar como clave de diccionario en Python. Una clave de diccionario debe ser de un tipo que sea inmutable. Por ejemplo, tuplas: holidays = { (1, 1) : 'New Years', (3, 14) : 'Pi day', (9, 13) : \"Programmer's day\", } Luego para acceder: >>> holidays[3, 14] 'Pi day' >>> Ni una lista, un conjunto ni otro diccionario pueden servir como clave de diccionario, porque las listas y los diccionarios son mutables.","title":"2.2.7: Claves compuestas"},{"location":"2/#228-conjuntos-sets","text":"Los conjuntos son una colecci\u00f3n de elementos \u00fanicos desordenados. tech_stocks = { 'IBM','AAPL','MSFT' } # alternativamente: tech_stocks = set(['IBM', 'AAPL', 'MSFT']) Los conjuntos son \u00fatiles para las pruebas de pertenencia. >>> tech_stocks set(['AAPL', 'IBM', 'MSFT']) >>> 'IBM' in tech_stocks True >>> 'FB' in tech_stocks False >>> Los conjuntos tambi\u00e9n son \u00fatiles para la eliminaci\u00f3n de duplicados. names = ['IBM', 'AAPL', 'GOOG', 'IBM', 'GOOG', 'YHOO'] unique = set(names) # unique = set(['IBM', 'AAPL','GOOG','YHOO']) Operaciones de conjuntos adicionales: names.add('CAT') # Add an item names.remove('YHOO') # Remove an item s1 | s2 # Set union s1 & s2 # Set intersection s1 - s2 # Set difference","title":"2.2.8: Conjuntos (Sets)"},{"location":"2/#229-ejercicios","text":"En estos ejercicios, comenzar\u00e1 a crear uno de los programas principales que se utilizar\u00e1n durante el resto de este curso. Haga su trabajo en el archivo Work/report.py . Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.2.9: Ejercicios"},{"location":"2/#ejercicio-24-una-lista-de-tuplas","text":"El archivo Data/portfolio.csv contiene una lista de acciones en una cartera. En el ejercicio 1.30 , escribi\u00f3 una funci\u00f3n portfolio_cost(filename) que ley\u00f3 este archivo y realiz\u00f3 un c\u00e1lculo simple. Tu c\u00f3digo deber\u00eda haberse visto as\u00ed: # pcost.py import csv def portfolio_cost(filename): '''Computa el costo total (shares*price) de un archivo del portfolio''' total_cost = 0.0 with open(filename, 'rt') as f: rows = csv.reader(f) headers = next(rows) for row in rows: nshares = int(row[1]) price = float(row[2]) total_cost += nshares * price return total_cost Usando este c\u00f3digo como una gu\u00eda aproximada, cree un nuevo archivo report.py. En ese archivo, defina una funci\u00f3n read_portfolio(filename) que abra un archivo de cartera determinado y lo lea en una lista de tuplas. Para hacer esto, va a realizar algunas modificaciones menores al c\u00f3digo anterior. Primero, en lugar de definir total_cost = 0, crear\u00e1 una variable que inicialmente se establece en una lista vac\u00eda. Por ejemplo: portfolio = [] A continuaci\u00f3n, en lugar de sumar el costo total, convertir\u00e1 cada fila en una tupla exactamente como lo hizo en el \u00faltimo ejercicio y la agregar\u00e1 a esta lista. Por ejemplo: for row in rows: holding = (row[0], int(row[1]), float(row[2])) portfolio.append(holding) Finalmente, devolver\u00e1 el portfolio en una lista. Experimente con su funci\u00f3n de forma interactiva (solo un recordatorio de que para hacer esto, primero debe ejecutar el report.pyprograma en el int\u00e9rprete): Sugerencia: Haga uso de -i al ejecutar el archivo en la terminal, e.g. $ python -i archivo.py >>> portfolio = read_portfolio('Data/portfolio.csv') >>> portfolio [('AA', 100, 32.2), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('MSFT', 200, 51.23), ('GE', 95, 40.37), ('MSFT', 50, 65.1), ('IBM', 100, 70.44)] >>> >>> portfolio[0] ('AA', 100, 32.2) >>> portfolio[1] ('IBM', 50, 91.1) >>> portfolio[1][1] 50 >>> total = 0.0 >>> for s in portfolio: total += s[1] * s[2] >>> print(total) 44671.15 >>> Esta lista de tuplas que ha creado es muy similar a una matriz 2-D. Por ejemplo, puede acceder a una columna y una fila espec\u00edficas mediante una b\u00fasqueda como portfolio[row][column] d\u00f3nde row y column son n\u00fameros enteros. Dicho esto, tambi\u00e9n puede escribir el \u00faltimo ciclo for usando una declaraci\u00f3n como esta: >>> total = 0.0 >>> for name, shares, price in portfolio: total += shares*price >>> print(total) 44671.15 >>>","title":"Ejercicio 2.4: Una lista de tuplas"},{"location":"2/#ejercicio-25-lista-de-diccionarios","text":"Tome la funci\u00f3n que escribi\u00f3 en el ejercicio 2.4 y modif\u00edquela para representar cada acci\u00f3n de la cartera con un diccionario en lugar de una tupla. En este diccionario, use los nombres de campo de \"nombre\", \"acciones\" y \"precio\" para representar las diferentes columnas en el archivo de entrada. Experimente con esta nueva funci\u00f3n de la misma manera que lo hizo en el ejercicio 2.4. >>> portfolio = read_portfolio('Data/portfolio.csv') >>> portfolio [{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1}, {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23}, {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1}, {'name': 'IBM', 'shares': 100, 'price': 70.44}] >>> portfolio[0] {'name': 'AA', 'shares': 100, 'price': 32.2} >>> portfolio[1] {'name': 'IBM', 'shares': 50, 'price': 91.1} >>> portfolio[1]['shares'] 50 >>> total = 0.0 >>> for s in portfolio: total += s['shares']*s['price'] >>> print(total) 44671.15 >>> Aqu\u00ed, notar\u00e1 que se accede a los diferentes campos para cada entrada mediante nombres de clave en lugar de n\u00fameros de columna num\u00e9ricos. Esto se prefiere a menudo porque el c\u00f3digo resultante es m\u00e1s f\u00e1cil de leer m\u00e1s tarde. Ver diccionarios y listas de gran tama\u00f1o puede resultar complicado. Para limpiar la salida para la depuraci\u00f3n, considere usar la funci\u00f3n pprint . >>> from pprint import pprint >>> pprint(portfolio) [{'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'MSFT', 'price': 65.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}] >>>","title":"Ejercicio 2.5: Lista de diccionarios"},{"location":"2/#ejercicio-26-diccionarios-como-contenedor","text":"Un diccionario es una forma \u00fatil de realizar un seguimiento de los elementos en los que desea buscar elementos utilizando un \u00edndice que no sea un n\u00famero entero. En el shell de Python, intente jugar con un diccionario: >>> prices = { } >>> prices['IBM'] = 92.45 >>> prices['MSFT'] = 45.12 >>> prices ... look at the result ... >>> prices['IBM'] 92.45 >>> prices['AAPL'] ... look at the result ... >>> 'AAPL' in prices False >>> El archivo Data/prices.csv contiene una serie de l\u00edneas con precios de acciones. El archivo se parece a esto: \"AA\",9.22 \"AXP\",24.85 \"BA\",44.85 \"BAC\",11.27 \"C\",3.72 ... Escriba una funci\u00f3n read_prices(filename)que lea un conjunto de precios como este en un diccionario donde las claves del diccionario son los nombres de las acciones y los valores en el diccionario son los precios de las acciones. Para hacer esto, comience con un diccionario vac\u00edo y comience a insertar valores en \u00e9l tal como lo hizo anteriormente. Sin embargo, ahora est\u00e1 leyendo los valores de un archivo. Usaremos esta estructura de datos para buscar r\u00e1pidamente el precio de un nombre de acci\u00f3n determinado. Algunos peque\u00f1os consejos que necesitar\u00e1 para esta parte. Primero, aseg\u00farese de usar el csvm\u00f3dulo tal como lo hizo antes, no es necesario reinventar la rueda aqu\u00ed. >>> import csv >>> f = open('Data/prices.csv', 'r') >>> rows = csv.reader(f) >>> for row in rows: print(row) ['AA', '9.22'] ['AXP', '24.85'] ... [] >>> La otra peque\u00f1a complicaci\u00f3n es que el Data/prices.csvarchivo puede tener algunas l\u00edneas en blanco. Observe c\u00f3mo la \u00faltima fila de datos de arriba es una lista vac\u00eda, lo que significa que no hab\u00eda datos presentes en esa l\u00ednea. Existe la posibilidad de que esto provoque la muerte de su programa con una excepci\u00f3n. Utilice las declaraciones tryy exceptpara detectar esto seg\u00fan corresponda. Pensamiento: \u00bfser\u00eda mejor protegerse contra datos incorrectos con una ifdeclaraci\u00f3n -en su lugar? Una vez que haya escrito su funci\u00f3n read_prices(), pru\u00e9bela de forma interactiva para asegurarse de que funcione: >>> prices = read_prices('Data/prices.csv') >>> prices['IBM'] 106.28 >>> prices['MSFT'] 20.89 >>> La otra peque\u00f1a complicaci\u00f3n es que el archivo Data/prices.csv puede tener algunas l\u00edneas en blanco. Observe c\u00f3mo la \u00faltima fila de datos de arriba es una lista vac\u00eda, lo que significa que no hab\u00eda datos presentes en esa l\u00ednea. Existe la posibilidad de que esto provoque la muerte de su programa con una excepci\u00f3n. Utilice las declaraciones tryy exceptpara detectar esto seg\u00fan corresponda. Pensamiento: \u00bfser\u00eda mejor protegerse contra datos incorrectos con una ifdeclaraci\u00f3n -en su lugar? Una vez que haya escrito su funci\u00f3n read_prices() , pru\u00e9bela de forma interactiva para asegurarse de que funcione: >>> prices = read_prices('Data/prices.csv') >>> prices['IBM'] 106.28 >>> prices['MSFT'] 20.89 >>>","title":"Ejercicio 2.6: Diccionarios como contenedor"},{"location":"2/#ejercicio-27-descubra-se-puede-jubilar","text":"Complete este trabajo agregando algunas declaraciones adicionales a su programa report.py que calculen ganancias / p\u00e9rdidas. Estas declaraciones deben tomar la lista de acciones del ejercicio 2.5 y el diccionario de precios del ejercicio 2.6 y calcular el valor actual de la cartera junto con la ganancia / p\u00e9rdida.","title":"Ejercicio 2.7: Descubra se puede jubilar"},{"location":"2/#23-salida-formateada","text":"Esta secci\u00f3n es una peque\u00f1a digresi\u00f3n, pero cuando trabaja con datos, a menudo desea producir resultados estructurados (tablas, etc.). Por ejemplo: Name Shares Price ---------- ---------- ----------- AA 100 32.20 IBM 50 91.10 CAT 150 83.44 MSFT 200 51.23 GE 95 40.37 MSFT 50 65.10 IBM 100 70.44 Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.3 Salida formateada"},{"location":"2/#231-formateo-de-cadena","text":"Una forma de formatear cadenas en Python 3.6+ es con f-strings. >>> name = 'IBM' >>> shares = 100 >>> price = 91.1 >>> f'{name:>10s} {shares:>10d} {price:>10.2f}' ' IBM 100 91.10' >>> La pieza {expression:format} se reemplaza. Se usa com\u00fanmente con print. print(f'{name:>10s} {shares:>10d} {price:>10.2f}')","title":"2.3.1: Formateo de cadena"},{"location":"2/#232-codigos-de-formato","text":"C\u00f3digos de formato (despu\u00e9s de que el : interior de la {} ) son similares a C printf(). Los c\u00f3digos comunes incluyen: d Decimal integer b Binary integer x Hexadecimal integer f Float as [-]m.dddddd e Float as [-]m.dddddde+-xx g Float, but selective use of E notation s String c Character (from integer) Los modificadores comunes ajustan el ancho del campo y la precisi\u00f3n decimal. Esta es una lista parcial: :>10d Integer right aligned in 10-character field :<10d Integer left aligned in 10-character field :^10d Integer centered in 10-character field :0.2f Float with 2 digit precision","title":"2.3.2: C\u00f3digos de formato"},{"location":"2/#233-formateo-de-diccionarios","text":"Puede utilizar el format_map()m\u00e9todo para aplicar formato de cadena a un diccionario de valores: >>> s = { 'name': 'IBM', 'shares': 100, 'price': 91.1 } >>> '{name:>10s} {shares:10d} {price:10.2f}'.format_map(s) ' IBM 100 91.10' >>> Utiliza los mismos c\u00f3digos que f-stringspero toma los valores del diccionario suministrado.","title":"2.3.3: Formateo de diccionarios"},{"location":"2/#234-el-metodo-format","text":"Existe un m\u00e9todo format()que puede aplicar formato a argumentos o argumentos de palabras clave. >>> '{name:>10s} {shares:10d} {price:10.2f}'.format(name='IBM', shares=100, price=91.1) ' IBM 100 91.10' >>> '{:10s} {:10d} {:10.2f}'.format('IBM', 100, 91.1) ' IBM 100 91.10' >>> Francamente, format()es un poco prolijo. Prefiero las cuerdas f.","title":"2.3.4: El m\u00e9todo format()"},{"location":"2/#235-formateo-al-estilo-c","text":"Tambi\u00e9n puede utilizar el operador de formato % . >>> 'The value is %d' % 3 'The value is 3' >>> '%5d %-5d %10d' % (3,4,5) ' 3 4 5' >>> '%0.2f' % (3.1415926,) '3.14' Esto requiere un solo elemento o una tupla a la derecha. C\u00f3digos de formato son el modelo de la C printf() tambi\u00e9n. Nota: Este es el \u00fanico formato disponible en cadenas de bytes. >>> b'%s has %n messages' % (b'Dave', 37) b'Dave has 37 messages' >>>","title":"2.3.5: Formateo al estilo C"},{"location":"2/#236-ejercicios","text":"Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.3.6: Ejercicios"},{"location":"2/#ejercicio-28-como-formatear-numeros","text":"Un problema com\u00fan al imprimir n\u00fameros es especificar el n\u00famero de decimales. Una forma de solucionar este problema es usar f-strings. Prueba estos ejemplos: >>> value = 42863.1 >>> print(value) 42863.1 >>> print(f'{value:0.4f}') 42863.1000 >>> print(f'{value:>16.2f}') 42863.10 >>> print(f'{value:<16.2f}') 42863.10 >>> print(f'{value:*>16,.2f}') *******42,863.10 >>> La documentaci\u00f3n completa sobre los c\u00f3digos de formato utilizados para las cadenas f se puede encontrar aqu\u00ed . El formateo tambi\u00e9n se realiza a veces utilizando el operador % de cadenas. >>> print('%0.4f' % value) 42863.1000 >>> print('%16.2f' % value) 42863.10 >>> La documentaci\u00f3n sobre varios c\u00f3digos utilizados con %se puede encontrar aqu\u00ed. Aunque se usa com\u00fanmente con print, el formato de cadena no est\u00e1 ligado a la impresi\u00f3n. Si desea guardar una cadena formateada. Simplemente as\u00edgnelo a una variable. >>> f = '%0.4f' % value >>> f '42863.1000' >>>","title":"Ejercicio 2.8: Como formatear numeros"},{"location":"2/#ejercicio-29-coleccionando-data","text":"En el ejercicio 2.7, escribi\u00f3 un programa llamado report.pyque calcul\u00f3 la ganancia / p\u00e9rdida de una cartera de acciones. En este ejercicio, comenzar\u00e1 a modificarlo para producir una tabla como esta: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 En este informe, \"Precio\" es el precio actual de la acci\u00f3n de la acci\u00f3n y \"Cambio\" es el cambio en el precio de la acci\u00f3n desde el precio de compra inicial. Para generar el informe anterior, primero querr\u00e1 recopilar todos los datos que se muestran en la tabla. Escriba una funci\u00f3n make_report() que tome una lista de existencias y un diccionario de precios como entrada y devuelva una lista de tuplas que contenga las filas de la tabla anterior. Agregue esta funci\u00f3n a su archivo report.py . As\u00ed es como deber\u00eda funcionar si lo prueba de forma interactiva: >>> portfolio = read_portfolio('Data/portfolio.csv') >>> prices = read_prices('Data/prices.csv') >>> report = make_report(portfolio, prices) >>> for r in report: print(r) ('AA', 100, 9.22, -22.980000000000004) ('IBM', 50, 106.28, 15.180000000000007) ('CAT', 150, 35.46, -47.98) ('MSFT', 200, 20.89, -30.339999999999996) ('GE', 95, 13.48, -26.889999999999997) ... >>>","title":"Ejercicio 2.9: Coleccionando data"},{"location":"2/#ejercicio-210-imprimiendo-una-tabla-formateada","text":"Rehaga el bucle for del ejercicio 2.9, pero cambie la instrucci\u00f3n print para formatear las tuplas. >>> for r in report: print('%10s %10d %10.2f %10.2f' % r) AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 ... >>> Tambi\u00e9n puede expandir los valores y usar f-strings. Por ejemplo: >>> for name, shares, price, change in report: print(f'{name:>10s} {shares:>10d} {price:>10.2f} {change:>10.2f}') AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 ... >>> Tome las declaraciones anteriores y agr\u00e9guelas a su report.pyprograma. Haga que su programa tome la salida de la funci\u00f3n make_report() e imprima una tabla bien formateada como se muestra.","title":"Ejercicio 2.10: Imprimiendo una tabla formateada"},{"location":"2/#ejercicio-211-agregando-algunos-encabezados","text":"Suponga que tiene una tupla de nombres de encabezado como este: headers = ('Name', 'Shares', 'Price', 'Change') Agregue c\u00f3digo a su programa que toma la tupla de encabezados anterior y crea una cadena donde cada nombre de encabezado est\u00e1 alineado a la derecha en un campo de 10 caracteres de ancho y cada campo est\u00e1 separado por un solo espacio. ' Name Shares Price Change' Escriba c\u00f3digo que tome los encabezados y cree la cadena de separaci\u00f3n entre los encabezados y los datos que siguen. Esta cadena es solo un grupo de caracteres \"-\" debajo de cada nombre de campo. Por ejemplo: '---------- ---------- ---------- -----------' Cuando haya terminado, su programa deber\u00eda producir la tabla que se muestra en la parte superior de este ejercicio. Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84","title":"Ejercicio 2.11: Agregando algunos encabezados"},{"location":"2/#ejercicio-212-un-reto","text":"\u00bfC\u00f3mo modificar\u00eda su c\u00f3digo para que el precio incluya el s\u00edmbolo de moneda ($) y la salida se vea as\u00ed: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 $9.22 -22.98 IBM 50 $106.28 15.18 CAT 150 $35.46 -47.98 MSFT 200 $20.89 -30.34 GE 95 $13.48 -26.89 MSFT 50 $20.89 -44.21 IBM 100 $106.28 35.84","title":"Ejercicio 2.12: Un reto"},{"location":"2/#24-secuencias","text":"Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.4 Secuencias"},{"location":"2/#241-tipos-de-secuencias","text":"Python tiene tres tipos de datos de secuencia . Cuerda: 'Hello' . Una cadena es una secuencia de caracteres. Lista: [1, 4, 5] . Tupla: ('GOOG', 100, 490.1) . Todas las secuencias est\u00e1n ordenadas, indexadas por n\u00fameros enteros y tienen una longitud. a = 'Hello' # String b = [1, 4, 5] # List c = ('GOOG', 100, 490.1) # Tuple # Indexed order a[0] # 'H' b[-1] # 5 c[1] # 100 # Length of sequence len(a) # 5 len(b) # 3 len(c) # 3 Las secuencias pueden ser replicados: s * n . >>> a = 'Hello' >>> a * 3 'HelloHelloHello' >>> b = [1, 2, 3] >>> b * 2 [1, 2, 3, 1, 2, 3] >>> Secuencias del mismo tipo pueden ser concatenados: s + t . >>> a = (1, 2, 3) >>> b = (4, 5) >>> a + b (1, 2, 3, 4, 5) >>> >>> c = [1, 5] >>> a + c Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only concatenate tuple (not \"list\") to tuple","title":"2.4.1: Tipos de secuencias"},{"location":"2/#242-cortar","text":"Cortar significa tomar una subsecuencia de una secuencia. La sintaxis es s[start:end] . Donde start y end son los \u00edndices de la subsecuencia que desea. a = [0,1,2,3,4,5,6,7,8] a[2:5] # [2,3,4] a[-5:] # [4,5,6,7,8] a[:3] # [0,1,2] \u00cdndices start y end deben ser n\u00fameros enteros. Las rebanadas no incluyen el valor final. Es como un intervalo medio abierto de matem\u00e1ticas. Si se omiten los \u00edndices, por defecto van al principio o al final de la lista.","title":"2.4.2: Cortar"},{"location":"2/#243-reasignacion-de-cortes","text":"En las listas, los sectores se pueden reasignar y eliminar. # Reasginaci\u00f3n a = [0,1,2,3,4,5,6,7,8] a[2:4] = [10,11,12] # [0,1,10,11,12,4,5,6,7,8] Nota: No es necesario que el segmento reasignado tenga la misma longitud. # Remoci\u00f3n a = [0,1,2,3,4,5,6,7,8] del a[2:4] # [0,1,4,5,6,7,8]","title":"2.4.3: Reasignaci\u00f3n de cortes"},{"location":"2/#244-secuencia-de-reducciones","text":"Existen algunas funciones comunes para reducir una secuencia a un solo valor. >>> s = [1, 2, 3, 4] >>> sum(s) 10 >>> min(s) 1 >>> max(s) 4 >>> t = ['Hello', 'World'] >>> max(t) 'World' >>>","title":"2.4.4: Secuencia de reducciones"},{"location":"2/#245-iteracion-sobre-una-secuencia","text":"El bucle for itera sobre los elementos en una secuencia. >>> s = [1, 4, 9, 16] >>> for i in s: ... print(i) ... 1 4 9 16 >>> En cada iteraci\u00f3n del ciclo, obtienes un nuevo elemento con el que trabajar. Este nuevo valor se coloca en la variable de iteraci\u00f3n. En este ejemplo, la variable de iteraci\u00f3n es x : for x in s: # `x` es una variable de iteraci\u00f3n ...declaraciones En cada iteraci\u00f3n, el valor anterior de la variable de iteraci\u00f3n se sobrescribe (si lo hubiera). Una vez finalizado el ciclo, la variable retiene el \u00faltimo valor.","title":"2.4.5: Iteracion sobre una secuencia"},{"location":"2/#246-la-declaracion-break","text":"Puede usar la break declaraci\u00f3n para salir de un ciclo antes de tiempo. for name in namelist: if name == 'Jake': break ... ... declaraciones Cuando la break instrucci\u00f3n se ejecuta, sale del ciclo y pasa al siguiente statements . La declaraci\u00f3n break solo se aplica al bucle m\u00e1s interno. Si este bucle est\u00e1 dentro de otro bucle, no romper\u00e1 el bucle exterior.","title":"2.4.6: La declaraci\u00f3n break"},{"location":"2/#247-la-declaracion-continue","text":"Para omitir un elemento y pasar al siguiente, use la continue declaraci\u00f3n. for line in lines: if line == '\\n': # Skip blank lines continue # More statements ... Esto es \u00fatil cuando el elemento actual no es de inter\u00e9s o debe ignorarse en el procesamiento.","title":"2.4.7: La declaraci\u00f3n continue"},{"location":"2/#248-ciclando-sobre-enteros","text":"Si necesita contar, use range() . for i in range(100): # i = 0,1,...,99 La sintaxis es range([start,] end [,step]) for i in range(100): # i = 0,1,...,99 for j in range(10,20): # j = 10,11,..., 19 for k in range(10,50,2): # k = 10,12,...,48 # Note como cuenta en pasos de 2, no 1. El valor final nunca se incluye. Refleja el comportamiento de los cortes. start es opcional. Por defecto 0 . step es opcional. Por defecto 1 . range() calcula los valores seg\u00fan sea necesario. En realidad, no almacena una gran variedad de n\u00fameros.","title":"2.4.8: Ciclando sobre enteros"},{"location":"2/#249-la-funcion-enumerate","text":"La enumerate funci\u00f3n agrega un valor de contador adicional a la iteraci\u00f3n. names = ['Elwood', 'Jake', 'Curtis'] for i, name in enumerate(names): # Cicla con i = 0, name = 'Elwood' # i = 1, name = 'Jake' # i = 2, name = 'Curtis' La forma general es enumerate(sequence [, start = 0]) . start es opcional. Un buen ejemplo de uso enumerate() es el seguimiento de los n\u00fameros de l\u00ednea mientras se lee un archivo: with open(filename) as f: for lineno, line in enumerate(f, start=1): ... Al final, enumerate es solo un buen atajo para: i = 0 for x in s: statements i += 1 Usar enumerate es escribir menos y se ejecuta un poco m\u00e1s r\u00e1pido.","title":"2.4.9: La funci\u00f3n enumerate()"},{"location":"2/#2410-for-y-tuplas","text":"Puede iterar con m\u00faltiples variables de iteraci\u00f3n. points = [ (1, 4),(10, 40),(23, 14),(5, 6),(7, 8) ] for x, y in points: # Cicla con x = 1, y = 4 # x = 10, y = 40 # x = 23, y = 14 # ... Cuando se utilizan varias variables, cada tupla se descompone en un conjunto de variables de iteraci\u00f3n. El n\u00famero de variables debe coincidir con el n\u00famero de elementos de cada tupla.","title":"2.4.10: for y tuplas"},{"location":"2/#2411-la-funcion-zip","text":"La zip funci\u00f3n toma m\u00faltiples secuencias y crea un iterador que las combina. columns = ['name', 'shares', 'price'] values = ['GOOG', 100, 490.1 ] pairs = zip(columns, values) # ('name','GOOG'), ('shares',100), ('price',490.1) Para obtener el resultado, debes iterar. Puede utilizar varias variables para descomprimir las tuplas como se mostr\u00f3 anteriormente. for column, value in pairs: ... Un uso com\u00fan de zip es crear pares clave / valor para construir diccionarios. d = dict(zip(columns, values))","title":"2.4.11: La funci\u00f3n zip()"},{"location":"2/#2412-ejercicios","text":"Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.4.12: Ejercicios"},{"location":"2/#ejercicio-213-contar","text":"Pruebe algunos ejemplos b\u00e1sicos de conteo: >>> for n in range(10): # Cuenta 0 ... 9 print(n, end=' ') 0 1 2 3 4 5 6 7 8 9 >>> for n in range(10,0,-1): # Cuenta 10 ... 1 print(n, end=' ') 10 9 8 7 6 5 4 3 2 1 >>> for n in range(0,10,2): # Cuenta 0, 2, ... 8 print(n, end=' ') 0 2 4 6 8 >>>","title":"Ejercicio 2.13: Contar"},{"location":"2/#ejercicio-214-mas-operaciones-sobre-secuencias","text":"Experimente interactivamente con algunas de las operaciones de reducci\u00f3n de secuencia. >>> data = [4, 9, 1, 25, 16, 100, 49] >>> min(data) 1 >>> max(data) 100 >>> sum(data) 204 >>> Intente recorrer los datos. >>> for x in data: print(x) 4 9 ... >>> for n, x in enumerate(data): print(n, x) 0 4 1 9 2 1 ... >> A veces, los principiantes usan la for instrucci\u00f3n, len() y range() en alg\u00fan tipo de fragmento de c\u00f3digo horrible que parece surgido de las profundidades de un programa C oxidado. >>> for n in range(len(data)): print(data[n]) 4 9 1 ... >>> \u00a1No hagas eso! Leerlo no solo hace sangrar los ojos de todos, es ineficiente con la memoria y funciona mucho m\u00e1s lento. Simplemente use un for bucle normal si desea iterar sobre los datos. \u00daselo enumerate() si necesita el \u00edndice por alguna raz\u00f3n.","title":"Ejercicio 2.14: Mas operaciones sobre secuencias"},{"location":"2/#ejercicio-215-un-ejemplo-practico-de-enumerate","text":"Recuerde que el archivo Data/missing.csv contiene datos para una cartera de acciones, pero tiene algunas filas con datos faltantes. Usando enumerate() , modifique su pcost.py programa para que imprima un n\u00famero de l\u00ednea con el mensaje de advertencia cuando encuentre una entrada incorrecta. >>> cost = portfolio_cost('Data/missing.csv') Row 4: Couldn't convert: ['MSFT', '', '51.23'] Row 7: Couldn't convert: ['IBM', '', '70.44'] >>> Para hacer esto, necesitar\u00e1 cambiar algunas partes de su c\u00f3digo. ... for rowno, row in enumerate(rows, start=1): try: ... except ValueError: print(f'Fila {rowno}: Mala fila: {row}')","title":"Ejercicio 2.15: Un ejemplo pr\u00e1ctico de enumerate()"},{"location":"2/#ejercicio-216-usando-la-funcion-zip","text":"En el archivo Data/portfolio.csv , la primera l\u00ednea contiene encabezados de columna. En todo el c\u00f3digo anterior, los hemos estado descartando. >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'shares', 'price'] >>> Sin embargo, \u00bfqu\u00e9 pasar\u00eda si pudieras usar los encabezados para algo \u00fatil? Aqu\u00ed es donde la zip() funci\u00f3n entra en escena. Primero intente esto para emparejar los encabezados del archivo con una fila de datos: >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> list(zip(headers, row)) [ ('name', 'AA'), ('shares', '100'), ('price', '32.20') ] >>> Observe c\u00f3mo se zip() emparejaron los encabezados de columna con los valores de columna. Hemos utilizado list() aqu\u00ed para convertir el resultado en una lista para que pueda verlo. Normalmente, zip() crea un iterador que debe consumir un bucle for. Este emparejamiento es un paso intermedio para crear un diccionario. Ahora prueba esto: >>> record = dict(zip(headers, row)) >>> record {'price': '32.20', 'name': 'AA', 'shares': '100'} >>> Esta transformaci\u00f3n es uno de los trucos m\u00e1s \u00fatiles que debe conocer al procesar muchos archivos de datos. Por ejemplo, suponga que desea que el pcost.py programa funcione con varios archivos de entrada, pero sin tener en cuenta el n\u00famero de columna real donde aparecen el nombre, las acciones y el precio. Modifique la portfolio_cost() funci\u00f3n pcost.py para que se vea as\u00ed: # pcost.py def portfolio_cost(filename): ... for rowno, row in enumerate(rows, start=1): record = dict(zip(headers, row)) try: nshares = int(record['shares']) price = float(record['price']) total_cost += nshares * price except ValueError: # Esto atrapa errores de conversi\u00f3n a int() y float() print(f'Fila {rowno}: Mala fila: {row}') ... Ahora, pruebe su funci\u00f3n en un archivo de datos completamente diferente Data/portfoliodate.csv que se ve as\u00ed: name,date,time,shares,price \"AA\",\"6/11/2007\",\"9:50am\",100,32.20 \"IBM\",\"5/13/2007\",\"4:20pm\",50,91.10 \"CAT\",\"9/23/2006\",\"1:30pm\",150,83.44 \"MSFT\",\"5/17/2007\",\"10:30am\",200,51.23 \"GE\",\"2/1/2006\",\"10:45am\",95,40.37 \"MSFT\",\"10/31/2006\",\"12:05pm\",50,65.10 \"IBM\",\"7/9/2006\",\"3:15pm\",100,70.44 >>> portfolio_cost('Data/portfoliodate.csv') 44671.15 >>> Si lo hizo bien, ver\u00e1 que su programa a\u00fan funciona a pesar de que el archivo de datos tiene un formato de columna completamente diferente al anterior. \u00a1Eso es genial! El cambio realizado aqu\u00ed es sutil, pero significativo. En lugar de portfolio_cost() estar codificado para leer un solo formato de archivo fijo, la nueva versi\u00f3n lee cualquier archivo CSV y selecciona los valores de inter\u00e9s. Siempre que el archivo tenga las columnas requeridas, el c\u00f3digo funcionar\u00e1. Modifique el report.py programa que escribi\u00f3 en la Secci\u00f3n 2.3 para que utilice la misma t\u00e9cnica para seleccionar encabezados de columna. Intente ejecutar el report.py programa en el Data/portfoliodate.csv archivo y vea que produce la misma respuesta que antes.","title":"Ejercicio 2.16: Usando la funci\u00f3n zip()"},{"location":"2/#ejercicio-217-invirtiendo-un-diccionario","text":"Un diccionario asigna claves a valores. Por ejemplo, un diccionario de precios de acciones. >>> prices = { 'GOOG': 490.1, 'AA': 23.45, 'IBM': 91.1, 'MSFT': 34.23 } >>> Si usa el m\u00e9todo items() , puede obtener pares (key,value) : >>> prices.items() dict_items([('GOOG', 490.1), ('AA', 23.45), ('IBM', 91.1), ('MSFT', 34.23)]) >>> Sin embargo, \u00bfqu\u00e9 pasar\u00eda si quisiera obtener una lista de pares (value, key) ? Sugerencia: use zip() . >>> pricelist = list(zip(prices.values(),prices.keys())) >>> pricelist [(490.1, 'GOOG'), (23.45, 'AA'), (91.1, 'IBM'), (34.23, 'MSFT')] >>> \u00bfPor qu\u00e9 har\u00edas esto? Por un lado, le permite realizar ciertos tipos de procesamiento de datos en los datos del diccionario. >>> min(pricelist) (23.45, 'AA') >>> max(pricelist) (490.1, 'GOOG') >>> sorted(pricelist) [(23.45, 'AA'), (34.23, 'MSFT'), (91.1, 'IBM'), (490.1, 'GOOG')] >>> Esto tambi\u00e9n ilustra una caracter\u00edstica importante de las tuplas. Cuando se usan en comparaciones, las tuplas se comparan elemento por elemento comenzando con el primer elemento. Similar a c\u00f3mo se comparan las cadenas car\u00e1cter por car\u00e1cter. zip() se utiliza a menudo en situaciones como esta en las que necesita emparejar datos de diferentes lugares. Por ejemplo, emparejar los nombres de las columnas con los valores de las columnas para crear un diccionario de valores con nombre. Tenga en cuenta que zip() no se limita a pares. Por ejemplo, puede usarlo con cualquier n\u00famero de listas de entrada: >>> a = [1, 2, 3, 4] >>> b = ['w', 'x', 'y', 'z'] >>> c = [0.2, 0.4, 0.6, 0.8] >>> list(zip(a, b, c)) [(1, 'w', 0.2), (2, 'x', 0.4), (3, 'y', 0.6), (4, 'z', 0.8))] >>> Adem\u00e1s, tenga en cuenta que zip() se detiene una vez que se agota la secuencia de entrada m\u00e1s corta. >>> a = [1, 2, 3, 4, 5, 6] >>> b = ['x', 'y', 'z'] >>> list(zip(a,b)) [(1, 'x'), (2, 'y'), (3, 'z')] >>>","title":"Ejercicio 2.17: Invirtiendo un diccionario"},{"location":"2/#25-el-modulo-collections","text":"El collections m\u00f3dulo proporciona una serie de objetos \u00fatiles para el manejo de datos. Esta parte presenta brevemente algunas de estas caracter\u00edsticas. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.5 El modulo collections"},{"location":"2/#251-ejemplo-contando-cosas","text":"Digamos que desea tabular el total de acciones de cada acci\u00f3n. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('IBM', 100, 45.23), ('GOOG', 75, 572.45), ('AA', 50, 23.15) ] Hay dos IBM entradas y dos GOOG entradas en esta lista. Las acciones deben combinarse de alguna manera.","title":"2.5.1: Ejemplo: contando cosas"},{"location":"2/#252-contadores","text":"Soluci\u00f3n: utilice un Counter . from collections import Counter total_shares = Counter() for name, shares, price in portfolio: total_shares[name] += shares total_shares['IBM'] # 150","title":"2.5.2: Contadores"},{"location":"2/#253-ejemplo-asignaciones-uno-muchos","text":"Problema: desea asignar una clave a varios valores. portfolio = [ ('GOOG', 100, 490.1), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('IBM', 100, 45.23), ('GOOG', 75, 572.45), ('AA', 50, 23.15) ] Como en el ejemplo anterior, la clave IBM deber\u00eda tener dos tuplas diferentes en su lugar. Soluci\u00f3n: utilice un defaultdict . from collections import defaultdict holdings = defaultdict(list) for name, shares, price in portfolio: holdings[name].append((shares, price)) holdings['IBM'] # [ (50, 91.1), (100, 45.23) ] El defaultdict asegura que cada vez que acceda a una clave obtenga un valor predeterminado.","title":"2.5.3: Ejemplo: asignaciones uno-muchos"},{"location":"2/#254-ejemplo-un-historial","text":"Problema: queremos un historial de las \u00faltimas N cosas. Soluci\u00f3n: utilice un deque . from collections import deque history = deque(maxlen=N) with open(filename) as f: for line in f: history.append(line) ...","title":"2.5.4: Ejemplo: un historial"},{"location":"2/#255-ejercicios","text":"El collections m\u00f3dulo puede ser uno de los m\u00f3dulos de biblioteca m\u00e1s \u00fatiles para tratar tipos de problemas de manejo de datos con fines especiales, como la tabulaci\u00f3n y la indexaci\u00f3n. En este ejercicio, veremos algunos ejemplos simples. Comience ejecutando su report.py programa para que tenga la cartera de acciones cargada en el modo interactivo. bash % python3 -i report.py Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.5.5: Ejercicios"},{"location":"2/#218-tabulacion-con-contadores","text":"Suponga que desea tabular el n\u00famero total de acciones de cada acci\u00f3n. Esto es f\u00e1cil de usar Counter objetos. Intentalo: >>> portfolio = read_portfolio('Data/portfolio.csv') >>> from collections import Counter >>> holdings = Counter() >>> for s in portfolio: holdings[s['name']] += s['shares'] >>> holdings Counter({'MSFT': 250, 'IBM': 150, 'CAT': 150, 'AA': 100, 'GE': 95}) >>> Observe cuidadosamente c\u00f3mo las m\u00faltiples entradas para MSFT y IBM en portfolio se combinan en una sola entrada aqu\u00ed. Puede usar un contador como un diccionario para recuperar valores individuales: >>> holdings['IBM'] 150 >>> holdings['MSFT'] 250 >>> Si desea clasificar los valores, haga esto: >>> # Get three most held stocks >>> holdings.most_common(3) [('MSFT', 250), ('IBM', 150), ('CAT', 150)] >>> Tomemos otra cartera de acciones y creemos un nuevo contador: >>> portfolio2 = read_portfolio('Data/portfolio2.csv') >>> holdings2 = Counter() >>> for s in portfolio2: holdings2[s['name']] += s['shares'] >>> holdings2 Counter({'HPQ': 250, 'GE': 125, 'AA': 50, 'MSFT': 25}) >>> Finalmente, combinemos todas las existencias haciendo una operaci\u00f3n simple: >>> holdings Counter({'MSFT': 250, 'IBM': 150, 'CAT': 150, 'AA': 100, 'GE': 95}) >>> holdings2 Counter({'HPQ': 250, 'GE': 125, 'AA': 50, 'MSFT': 25}) >>> combined = holdings + holdings2 >>> combined Counter({'MSFT': 275, 'HPQ': 250, 'GE': 220, 'AA': 150, 'IBM': 150, 'CAT': 150}) >>> Esto es solo una peque\u00f1a muestra de lo que ofrecen los contadores. Sin embargo, si alguna vez necesita tabular valores, deber\u00eda considerar usar uno.","title":"2.18: Tabulaci\u00f3n con contadores"},{"location":"2/#256-comentario-el-modulo-collections","text":"El m\u00f3dulo collections es uno de los m\u00f3dulos de biblioteca m\u00e1s \u00fatiles de todo Python. De hecho, podr\u00edamos hacer un tutorial extenso sobre eso. Sin embargo, hacerlo ahora tambi\u00e9n ser\u00eda una distracci\u00f3n. Por ahora, ponga collections su lista de lecturas a la hora de dormir para m\u00e1s tarde.","title":"2.5.6: Comentario: el modulo collections"},{"location":"2/#26-comprension-de-listas","text":"Una tarea com\u00fan es procesar elementos en una lista. Esta secci\u00f3n presenta listas por comprensi\u00f3n, una poderosa herramienta para hacer precisamente eso. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.6 Comprensi\u00f3n de Listas"},{"location":"2/#261-creando-nuevas-listas","text":"Una lista de comprensi\u00f3n crea una nueva lista aplicando una operaci\u00f3n a cada elemento de una secuencia. >>> a = [1, 2, 3, 4, 5] >>> b = [2*x for x in a ] >>> b [2, 4, 6, 8, 10] >>> Otro ejemplo: >>> names = ['Elwood', 'Jake'] >>> a = [name.lower() for name in names] >>> a ['elwood', 'jake'] >>> La sintaxis general es: [ <expresi\u00f3n> for <variable_nombre> in <secuencia> ] .","title":"2.6.1: Creando nuevas listas"},{"location":"2/#262-filtrar","text":"Tambi\u00e9n puede filtrar durante la comprensi\u00f3n de la lista. >>> a = [1, -5, 4, 2, -2, 10] >>> b = [2*x for x in a if x > 0 ] >>> b [2, 8, 4, 20] >>>","title":"2.6.2: Filtrar"},{"location":"2/#263-casos-de-uso","text":"Las listas por comprensi\u00f3n son muy \u00fatiles. Por ejemplo, puede recopilar valores de campos de un diccionario espec\u00edfico: stocknames = [s['name'] for s in stocks] Puede realizar consultas similares a bases de datos en secuencias. a = [s for s in stocks if s['price'] > 100 and s['shares'] > 50 ] Tambi\u00e9n puede combinar una comprensi\u00f3n de lista con una reducci\u00f3n de secuencia: cost = sum([s['shares']*s['price'] for s in stocks])","title":"2.6.3: Casos de uso"},{"location":"2/#264-sintaxis-general","text":"[ <expresi\u00f3n> for <variable_nombre> in <secuencia> si <condici\u00f3n>] Que significa: result = [] for variable_name in sequence: if condition: result.append(expression)","title":"2.6.4: Sintaxis general"},{"location":"2/#265-digresion-historica","text":"Las listas por comprensi\u00f3n provienen de las matem\u00e1ticas (notaci\u00f3n del generador de conjuntos). a = [ x * x for x in s if x > 0 ] # Python a = { x^2 | x \u2208 s, x > 0 } # Math Tambi\u00e9n se implementa en varios otros idiomas. Sin embargo, la mayor\u00eda de los programadores probablemente no est\u00e9n pensando en su clase de matem\u00e1ticas. Entonces, est\u00e1 bien verlo como un atajo de lista genial.","title":"2.6.5: Digresi\u00f3n hist\u00f3rica"},{"location":"2/#266-ejercicios","text":"Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador Comience ejecutando su report.py programa para que tenga la cartera de acciones cargada en el modo interactivo. bash % python3 -i report.py","title":"2.6.6: Ejercicios"},{"location":"2/#ejercicio-219-comprension-de-listas","text":"Pruebe algunas comprensiones de listas simples solo para familiarizarse con la sintaxis. >>> nums = [1,2,3,4] >>> squares = [ x * x for x in nums ] >>> squares [1, 4, 9, 16] >>> twice = [ 2 * x for x in nums if x > 2 ] >>> twice [6, 8] >>> Observe c\u00f3mo las listas por comprensi\u00f3n est\u00e1n creando una nueva lista con los datos adecuadamente transformados o filtrados.","title":"Ejercicio 2.19: Comprension de listas"},{"location":"2/#ejercicio-220-reducciones-de-secuencia","text":"Calcule el costo total de la cartera con una sola declaraci\u00f3n de Python. >>> portfolio = read_portfolio('Data/portfolio.csv') >>> cost = sum([ s['shares'] * s['price'] for s in portfolio ]) >>> cost 44671.15 >>> Despu\u00e9s de haber hecho eso, muestre c\u00f3mo puede calcular el valor actual de la cartera con un solo extracto. >>> value = sum([ s['shares'] * prices[s['name']] for s in portfolio ]) >>> value 28686.1 >>> Ambas operaciones anteriores son un ejemplo de reducci\u00f3n de mapa. La comprensi\u00f3n de la lista est\u00e1 mapeando una operaci\u00f3n a lo largo de la lista. >>> [ s['shares'] * s['price'] for s in portfolio ] [3220.0000000000005, 4555.0, 12516.0, 10246.0, 3835.1499999999996, 3254.9999999999995, 7044.0] >>> La sum() funci\u00f3n est\u00e1 realizando despu\u00e9s una reducci\u00f3n en todo el resultado: >>> sum(_) 44671.15 >>> Con este conocimiento, ahora est\u00e1 listo para lanzar una nueva empresa de big data.","title":"Ejercicio 2.20: Reducciones de secuencia"},{"location":"2/#ejercicio-221-consulta-de-datos","text":"Pruebe los siguientes ejemplos de varias consultas de datos. Primero, una lista de todas las posiciones de la cartera con m\u00e1s de 100 acciones. >>> more100 = [ s for s in portfolio if s['shares'] > 100 ] >>> more100 [{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}] >>> Todas las posiciones en cartera de acciones de MSFT e IBM. >>> msftibm = [ s for s in portfolio if s['name'] in {'MSFT','IBM'} ] >>> msftibm [{'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}] >>> Una lista de todas las tenencias de la cartera que cuestan m\u00e1s de $10000 . >>> cost10k = [ s for s in portfolio if s['shares'] * s['price'] > 10000 ] >>> cost10k [{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}] >>>","title":"Ejercicio 2.21: Consulta de datos"},{"location":"2/#ejercicio-222-extraccion-de-datos","text":"Mostrar c\u00f3mo se podr\u00eda construir una lista de tuplas (name, shares) , donde name y shares son tomados de portfolio . >>> name_shares =[ (s['name'], s['shares']) for s in portfolio ] >>> name_shares [('AA', 100), ('IBM', 50), ('CAT', 150), ('MSFT', 200), ('GE', 95), ('MSFT', 50), ('IBM', 100)] >>> Si cambia los corchetes ( [ , ] ) por llaves ( { , } ), obtendr\u00e1 algo conocido como comprensi\u00f3n de conjuntos. Esto le brinda valores \u00fanicos o distintos. Por ejemplo, esto determina el conjunto de nombres de acciones \u00fanicos que aparecen en portfolio : >>> names = { s['name'] for s in portfolio } >>> names { 'AA', 'GE', 'IBM', 'MSFT', 'CAT'] } >>> Si especifica key:value pares, puede crear un diccionario. Por ejemplo, cree un diccionario que asigne el nombre de una acci\u00f3n al n\u00famero total de acciones que posee. >>> holdings = { name: 0 for name in names } >>> holdings {'AA': 0, 'GE': 0, 'IBM': 0, 'MSFT': 0, 'CAT': 0} >>> Esta \u00faltima caracter\u00edstica se conoce como comprensi\u00f3n de diccionario . Vamos a tabular: >>> for s in portfolio: holdings[s['name']] += s['shares'] >>> holdings { 'AA': 100, 'GE': 95, 'IBM': 150, 'MSFT':250, 'CAT': 150 } >>> Pruebe este ejemplo que filtra el diccionario prices solo a los nombres que aparecen en la cartera: >>> portfolio_prices = { name: prices[name] for name in names } >>> portfolio_prices {'AA': 9.22, 'GE': 13.48, 'IBM': 106.28, 'MSFT': 20.89, 'CAT': 35.46} >>>","title":"Ejercicio 2.22: Extracci\u00f3n de datos"},{"location":"2/#ejercicio-223-extraccion-de-datos-desde-archivos-csv","text":"Saber c\u00f3mo utilizar varias combinaciones de comprensiones de listas, conjuntos y diccionarios puede resultar \u00fatil en diversas formas de procesamiento de datos. A continuaci\u00f3n, se muestra un ejemplo que muestra c\u00f3mo extraer columnas seleccionadas de un archivo CSV. Primero, lea una fila de informaci\u00f3n de encabezado de un archivo CSV: >>> import csv >>> f = open('Data/portfoliodate.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['name', 'date', 'time', 'shares', 'price'] >>> A continuaci\u00f3n, defina una variable que enumere las columnas que realmente le interesan: >>> select = ['name', 'shares', 'price'] >>> Ahora, ubique los \u00edndices de las columnas anteriores en el archivo CSV de origen: >>> indices = [ headers.index(colname) for colname in select ] >>> indices [0, 3, 4] >>> Finalmente, lea una fila de datos y convi\u00e9rtala en un diccionario usando una comprensi\u00f3n de diccionario: >>> row = next(rows) >>> record = { colname: row[index] for colname, index in zip(select, indices) } # dict-comprehension >>> record {'price': '32.20', 'name': 'AA', 'shares': '100'} >>> Si se siente c\u00f3modo con lo que acaba de suceder, lea el resto del archivo: >>> portfolio = [ { colname: row[index] for colname, index in zip(select, indices) } for row in rows ] >>> portfolio [{'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> Vaya, acabas de reducir gran parte de la read_portfolio() funci\u00f3n a una sola declaraci\u00f3n.","title":"Ejercicio 2.23: Extracci\u00f3n de datos desde archivos CSV"},{"location":"2/#comentario","text":"Las listas por comprensi\u00f3n se utilizan com\u00fanmente en Python como un medio eficaz para transformar, filtrar o recopilar datos. Debido a la sintaxis, no querr\u00e1 exagerar; intente que la comprensi\u00f3n de cada lista sea lo m\u00e1s simple posible. Est\u00e1 bien dividir las cosas en varios pasos. Por ejemplo, no est\u00e1 claro si le gustar\u00eda dar ese \u00faltimo ejemplo a sus compa\u00f1eros de trabajo desprevenidos. Dicho esto, saber c\u00f3mo manipular datos r\u00e1pidamente es una habilidad incre\u00edblemente \u00fatil. Existen numerosas situaciones en las que es posible que deba resolver alg\u00fan tipo de problema \u00fanico que involucre la importaci\u00f3n, exportaci\u00f3n, extracci\u00f3n de datos, etc. Convertirse en un maestro gur\u00fa de la comprensi\u00f3n de listas puede reducir sustancialmente el tiempo dedicado a idear una soluci\u00f3n. Adem\u00e1s, no se olvide del collections m\u00f3dulo.","title":"Comentario"},{"location":"2/#27-objetos","text":"Esta secci\u00f3n presenta m\u00e1s detalles sobre el modelo de objetos internos de Python y analiza algunos asuntos relacionados con la administraci\u00f3n de memoria, la copia y la verificaci\u00f3n de tipos. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.7 Objetos"},{"location":"2/#271-asignacion","text":"Muchas operaciones en Python est\u00e1n relacionadas con la asignaci\u00f3n o el almacenamiento de valores. a = value # Asignaci\u00f3n a una variable s[n] = value # Asignaci\u00f3n a una lista s.append(value) # Agregando a una lista d['key'] = value # Agregando a un diccionario Una advertencia: las operaciones de asignaci\u00f3n nunca hacen una copia del valor asignado. Todas las asignaciones son simplemente copias de referencia (o copias de puntero si lo prefiere).","title":"2.7.1: Asignacion"},{"location":"2/#272-ejemplo-de-asignacion","text":"Considere este fragmento de c\u00f3digo. a = [1,2,3] b = a c = [a,b] Una imagen de las operaciones de memoria subyacentes. En este ejemplo, solo hay un objeto de lista [1,2,3] , pero hay cuatro referencias diferentes a \u00e9l. Esto significa que la modificaci\u00f3n de un valor afecta a todas las referencias. >>> a.append(999) >>> a [1,2,3,999] >>> b [1,2,3,999] >>> c [[1,2,3,999], [1,2,3,999]] >>> Observe c\u00f3mo un cambio en la lista original aparece en todas partes (\u00a1ay!). Esto se debe a que nunca se hicieron copias. Todo apunta a lo mismo.","title":"2.7.2: Ejemplo de asignacion"},{"location":"2/#273-reasignacion-de-valores","text":"La reasignaci\u00f3n de un valor nunca sobrescribe la memoria utilizada por el valor anterior. a = [1,2,3] b = a a = [4,5,6] print(a) # [4, 5, 6] print(b) # [1, 2, 3] Tiene el valor original Recuerde: las variables son nombres, no ubicaciones de memoria.","title":"2.7.3: Reasignacion de valores"},{"location":"2/#274-algunos-peligros","text":"Si no sabe acerca de este intercambio, se disparar\u00e1 en el pie en alg\u00fan momento. Escenario t\u00edpico. Modifica algunos datos pensando que es su propia copia privada y accidentalmente corrompe algunos datos en alguna otra parte del programa. Comentario: Esta es una de las razones por las que los tipos de datos primitivos (int, float, string) son inmutables (solo lectura).","title":"2.7.4: Algunos peligros"},{"location":"2/#275-identidad-y-referencia","text":"Utilice el operador is para comprobar si dos valores son exactamente el mismo objeto. >>> a = [1,2,3] >>> b = a >>> a is b True >>> is compara la identidad del objeto (un n\u00famero entero). La identidad se puede obtener utilizando id() . >>> id(a) 3588944 >>> id(b) 3588944 >>> Nota: Casi siempre es mejor utilizar == para comparar objetos. El comportamiento de is suele ser inesperado: >>> a = [1,2,3] >>> b = a >>> c = [1,2,3] >>> a is b True >>> a is c False >>> a == c # hmm... \u00bfpor qu\u00e9? True >>>","title":"2.7.5: Identidad y referencia"},{"location":"2/#276-copias-superficiales","text":"Las listas y los dictados tienen m\u00e9todos para copiar. >>> a = [2,3,[100,101],4] >>> b = list(a) # Make a copy >>> a is b False Es una lista nueva, pero los elementos de la lista se comparten. >>> a[2].append(102) >>> b[2] [100,101,102] >>> >>> a[2] is b[2] True >>> Por ejemplo, [100, 101, 102] se comparte la lista interna . Esto se conoce como copia superficial. Aqu\u00ed tienes una foto.","title":"2.7.6: Copias superficiales"},{"location":"2/#278-copias-profundas","text":"A veces es necesario hacer una copia de un objeto y todos los objetos que contiene. Puede utilizar el m\u00f3dulo copy para esto: >>> a = [2,3,[100,101],4] >>> import copy >>> b = copy.deepcopy(a) >>> a[2].append(102) >>> b[2] [100,101] >>> a[2] is b[2] False >>>","title":"2.7.8: Copias profundas"},{"location":"2/#279-nombres-valores-tipos","text":"Los nombres de las variables no tienen tipo . Es solo un nombre. Sin embargo, los valores no tienen un tipo subyacente. >>> a = 42 >>> b = 'Hello World' >>> type(a) <type 'int'> >>> type(b) <type 'str'> type() te dir\u00e1 qu\u00e9 es. El nombre del tipo se usa generalmente como una funci\u00f3n que crea o convierte un valor a ese tipo.","title":"2.7.9: Nombres, valores, tipos"},{"location":"2/#2710-verificacion-de-tipo","text":"C\u00f3mo saber si un objeto es de un tipo espec\u00edfico. if isinstance(a, list): print('a is a list') Comprobando uno de los muchos tipos posibles. if isinstance(a, (list,tuple)): print('a is a list or tuple') Precauci\u00f3n: No se exceda con la verificaci\u00f3n de tipos. Puede conducir a una complejidad de c\u00f3digo excesiva. Por lo general, solo lo har\u00eda si al hacerlo evitar\u00eda errores comunes cometidos por otros que usan su c\u00f3digo.","title":"2.7.10: Verificaci\u00f3n de tipo"},{"location":"2/#2711-todo-es-un-objeto","text":"Los n\u00fameros, cadenas, listas, funciones, excepciones, clases, instancias, etc. son todos objetos. Significa que todos los objetos que se pueden nombrar pueden pasarse como datos, colocarse en contenedores, etc., sin ninguna restricci\u00f3n. No hay tipos especiales de objetos. A veces se dice que todos los objetos son de \"primera clase\". Un simple ejemplo: >>> import math >>> items = [abs, math, ValueError ] >>> items [<built-in function abs>, <module 'math' (builtin)>, <type 'exceptions.ValueError'>] >>> items[0](-45) 45 >>> items[1].sqrt(2) 1.4142135623730951 >>> try: x = int('not a number') except items[2]: print('Failed!') Failed! >>> Aqu\u00ed items hay una lista que contiene una funci\u00f3n, un m\u00f3dulo y una excepci\u00f3n. Puede utilizar directamente los elementos de la lista en lugar de los nombres originales: items[0](-45) # abs items[1].sqrt(2) # math except items[2]: # ValueError Un gran poder conlleva responsabilidad. El hecho de que pueda hacer eso no significa que deba hacerlo.","title":"2.7.11: Todo es un objeto"},{"location":"2/#233-ejercicios","text":"En este conjunto de ejercicios, analizamos parte del poder que proviene de los objetos de primera clase. Nota: si desea hacer esta secci\u00f3n online, hemos puesto a disposici\u00f3n un editor, consola Python y terminal Linux en repl.it . De lo contrario, tendr\u00e1 que ejecutar instrucciones en su ordenador","title":"2.33: Ejercicios"},{"location":"2/#ejercicio-224-data-de-primera-clase","text":"En el archivo Data/portfolio.csv , leemos datos organizados como columnas que se ven as\u00ed: name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 ... En el c\u00f3digo anterior, us\u00e1bamos el csv m\u00f3dulo para leer el archivo, pero a\u00fan ten\u00edamos que realizar conversiones de tipo manuales. Por ejemplo: for row in rows: name = row[0] shares = int(row[1]) price = float(row[2]) Este tipo de conversi\u00f3n tambi\u00e9n se puede realizar de una manera m\u00e1s inteligente utilizando algunas operaciones b\u00e1sicas de lista. Haga una lista de Python que contenga los nombres de las funciones de conversi\u00f3n que usar\u00eda para convertir cada columna en el tipo apropiado: >>> types = [str, int, float] >>> La raz\u00f3n por la que incluso puede crear esta lista es que todo en Python es de primera clase . Entonces, si desea tener una lista de funciones, est\u00e1 bien. Los elementos de la lista que ha creado son funciones para convertir un valor x en un tipo determinado (por ejemplo, str(x) , int(x) , float(x) ). Ahora, lea una fila de datos del archivo anterior: >>> import csv >>> f = open('Data/portfolio.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> row ['AA', '100', '32.20'] >>> Como se se\u00f1al\u00f3, esta fila no es suficiente para hacer c\u00e1lculos porque los tipos son incorrectos. Por ejemplo: >>> row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiply sequence by non-int of type 'str' >>> Sin embargo, tal vez los datos se puedan emparejar con los tipos que especific\u00f3 en types . Por ejemplo: >>> types[1] <type 'int'> >>> row[1] '100' >>> Intente convertir uno de los valores: >>> types[1](row[1]) # Same as int(row[1]) 100 >>> Intente convertir un valor diferente: >>> types[2](row[2]) # Same as float(row[2]) 32.2 >>> Pruebe el c\u00e1lculo con valores convertidos: >>> types[1](row[1])*types[2](row[2]) 3220.0000000000005 >>> Comprima los tipos de columna con los campos y observe el resultado: >>> r = list(zip(types, row)) >>> r [(<type 'str'>, 'AA'), (<type 'int'>, '100'), (<type 'float'>,'32.20')] >>> Notar\u00e1 que esto ha emparejado una conversi\u00f3n de tipo con un valor. Por ejemplo, int se empareja con el valor '100' . La lista comprimida es \u00fatil si desea realizar conversiones en todos los valores, uno tras otro. Prueba esto: >>> converted = [] >>> for func, val in zip(types, row): converted.append(func(val)) ... >>> converted ['AA', 100, 32.2] >>> converted[1] * converted[2] 3220.0000000000005 >>> Aseg\u00farese de comprender lo que sucede en el c\u00f3digo anterior. En el bucle, la func variable es una de las funciones de conversi\u00f3n de tipo (por ejemplo, str , int , etc.) y la val variable es uno de los valores como 'AA' , '100' . La expresi\u00f3n func(val) est\u00e1 convirtiendo un valor (algo as\u00ed como un tipo de conversi\u00f3n). El c\u00f3digo anterior se puede comprimir en una sola lista comprensiva. >>> converted = [func(val) for func, val in zip(types, row)] >>> converted ['AA', 100, 32.2] >>>","title":"Ejercicio 2.24: Data de primera-clase"},{"location":"2/#ejercicio-225-creando-diccionarios","text":"\u00bfRecuerda c\u00f3mo la funci\u00f3n dict() puede hacer f\u00e1cilmente un diccionario si tiene una secuencia de nombres y valores clave? Hagamos un diccionario a partir de los encabezados de las columnas: >>> headers ['name', 'shares', 'price'] >>> converted ['AA', 100, 32.2] >>> dict(zip(headers, converted)) {'price': 32.2, 'name': 'AA', 'shares': 100} >>> Por supuesto, si est\u00e1 en su lista de comprensi\u00f3n fu, puede hacer toda la conversi\u00f3n en un solo paso usando un dict-comprehension: >>> { name: func(val) for name, func, val in zip(headers, types, row) } {'price': 32.2, 'name': 'AA', 'shares': 100} >>>","title":"Ejercicio 2.25: Creando diccionarios"},{"location":"2/#ejercicio-226-el-horizonte","text":"Con las t\u00e9cnicas de este ejercicio, podr\u00eda escribir declaraciones que conviertan f\u00e1cilmente campos de casi cualquier archivo de datos orientado a columnas en un diccionario de Python. Solo para ilustrar, suponga que lee datos de un archivo de datos diferente como este: >>> f = open('Data/dowstocks.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> headers ['name', 'price', 'date', 'time', 'change', 'open', 'high', 'low', 'volume'] >>> row ['AA', '39.48', '6/11/2007', '9:36am', '-0.18', '39.67', '39.69', '39.45', '181800'] >>> Convirtamos los campos usando un truco similar: >>> types = [str, float, str, str, float, float, float, float, int] >>> converted = [func(val) for func, val in zip(types, row)] >>> record = dict(zip(headers, converted)) >>> record {'volume': 181800, 'name': 'AA', 'price': 39.48, 'high': 39.69, 'low': 39.45, 'time': '9:36am', 'date': '6/11/2007', 'open': 39.67, 'change': -0.18} >>> record['name'] 'AA' >>> record['price'] 39.48 >>> Extra: \u00bfC\u00f3mo modificar\u00eda este ejemplo para analizar adicionalmente la entrada date en una tupla como (6, 11, 2007) ? Dedique alg\u00fan tiempo a reflexionar sobre lo que ha hecho en este ejercicio. Revisaremos estas ideas un poco m\u00e1s tarde.","title":"Ejercicio 2.26: El horizonte"},{"location":"3/","text":"3. Organizaci\u00f3n de un Programa En este modulo nos empapamos de m\u00e1s detalles sobre la composici\u00f3n de funciones, el manejo de errores y la introducci\u00f3n de modulos. Al final seremos capaces de escribir programas que son subdivididos en funciones esparcidas en varios archivos. Veremos algunas plantillas de c\u00f3digo que les ser\u00e1 \u00fatil para la creaci\u00f3n de programas. 3.1 Scripting En esta parte, veremos m\u00e1s de cerca la pr\u00e1ctica de escribir scripts en Python. 3.1.1 \u00bfQu\u00e9 es un gui\u00f3n / script? Un script es un programa que ejecuta una serie de declaraciones y se detiene. # programa.py declaracion1 declaracion2 declaracion3 ... Hasta ahora, vale destacar que hemos estado escribiendo scripts . 3.1.2 Un problema Si escribe un script \u00fatil, crecer\u00e1 en caracter\u00edsticas y funcionalidad. Es posible que desee aplicarlo a otros problemas relacionados. Con el tiempo, podr\u00eda convertirse en una aplicaci\u00f3n cr\u00edtica. Sin embargo, podr\u00eda convertirse en un gran enredado si no tiene cuidado. Entonces, es importante tener alg\u00fan tipo de organizaci\u00f3n. 3.1.3 Definiendo cosas Los nombres siempre deben definirse antes de que se utilicen m\u00e1s tarde. def square(x): return x*x a = 42 b = a + 2 # requiere que `a` est\u00e9 definida z = square(b) # require que `square` y `b` esten definidas El orden es importante. Casi siempre colocas las definiciones de variables y funciones cerca de la parte superior. 3.1.4 Definici\u00f3n de funciones Es una buena idea poner todo el c\u00f3digo relacionado con una sola tarea en un solo lugar. Para esto, haga uso de una funci\u00f3n. def read_prices(filename): prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Una funci\u00f3n tambi\u00e9n simplifica las operaciones repetidas. oldprices = read_prices('oldprices.csv') newprices = read_prices('newprices.csv') 3.1.5 \u00bfQu\u00e9 es una funci\u00f3n? Una funci\u00f3n es una secuencia de declaraciones con nombre. def funcname(args): declaracion declaracion ... return result Cualquier declaraci\u00f3n de Python se puede utilizar dentro. def foo(): import math print(math.sqrt(2)) help(math) No hay declaraciones especiales en Python (lo que hace que sea f\u00e1cil de recordar). 3.1.6 Definici\u00f3n de funci\u00f3n Las funciones se pueden definir en cualquier orden. def foo(x): bar(x) def bar(x): declaracion # OR def bar(x): declaracion def foo(x): bar(x) Las funciones solo deben definirse antes de ser utilizadas (o llamadas) durante la ejecuci\u00f3n del programa. foo(3) # foo debi\u00f3 haber estado definida Estil\u00edsticamente, probablemente sea m\u00e1s com\u00fan ver las funciones definidas de abajo hacia arriba. 3.1.7 Estilo de abajo hacia arriba Las funciones se tratan como bloques de construcci\u00f3n. Los bloques m\u00e1s peque\u00f1os / simples van primero. # myprogram.py def foo(x): ... def bar(x): ... foo(x) # Definida anteriormente ... def spam(x): ... bar(x) # Definida anteriormente ... spam(42) # C\u00f3digo que utiliza las funciones esta definido anteriormente Las funciones posteriores se basan en funciones anteriores. Nuevamente, esto es solo una cuesti\u00f3n de estilo. Lo \u00fanico que importa en el programa anterior es que la llamada spam(42) sea \u200b\u200bla \u00faltima. 3.1.8 Dise\u00f1o de funciones Idealmente, las funciones deber\u00edan ser una caja negra . Solo deben operar con entradas pasadas y evitar variables globales y efectos secundarios misteriosos. Sus principales objetivos: modularidad y previsibilidad . 3.1.9 Documentaci\u00f3n en cadenas La documentaci\u00f3n en cadenas, comunmente conocida en ingl\u00e9s como doc strings , es una buena pr\u00e1ctica que incluye un breve resumen de una oraci\u00f3n de lo que hace la funci\u00f3n. Si se necesita m\u00e1s informaci\u00f3n, se incluye un breve ejemplo de uso junto con una descripci\u00f3n m\u00e1s detallada de los argumentos. Las mismas se escriben inmediatamente despu\u00e9s del nombre de la funci\u00f3n y alimentan a help() , el IDE (ambiente integrado de desarrollo) y otras herramientas. def read_prices(filename): '''Lee precios de un archivo CSV file de nombre, precio, y data''' prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices 3.1.10 Tipo de anotaciones Tambi\u00e9n puede agregar sugerencias de tipo opcionales a las definiciones de funciones. def read_prices(filename: str) -> dict: '''Lee precios de un archivo CSV file de nombre, precio, y data''' prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Las sugerencias no hacen nada operativamente. Son puramente informativos. Sin embargo, pueden ser utilizados por IDE, verificadores de c\u00f3digo y otras herramientas para hacer m\u00e1s. 3.1.11 Ejercicios En la secci\u00f3n 2, escribi\u00f3 un programa llamado report.pyque imprim\u00eda un informe que mostraba el rendimiento de una cartera de acciones. Este programa constaba de algunas funciones. Por ejemplo: # report.py import csv def read_portfolio(filename): '''Lee un archivo de cartera de acciones en una lista de diccionarios con la clave siendo nombre, acciones y precio.''' portfolio = [] with open(filename) as f: rows = csv.reader(f) headers = next(rows) for row in rows: record = dict(zip(headers, row)) stock = { 'name' : record['name'], 'shares' : int(record['shares']), 'price' : float(record['price']) } portfolio.append(stock) return portfolio ... Sin embargo, tambi\u00e9n hubo partes del programa que solo realizaron una serie de c\u00e1lculos con gui\u00f3n. Este c\u00f3digo apareci\u00f3 cerca del final del programa. Por ejemplo: ... # Salida/output del reporte headers = ('Name', 'Shares', 'Price', 'Change') print('%10s %10s %10s %10s' % headers) print(('-' * 10 + ' ') * len(headers)) for row in report: print('%10s %10d %10.2f %10.2f' % row) ... En este ejercicio, tomaremos el programa anterior y lo organizaremos con un poco m\u00e1s de fuerza en torno al uso de funciones. Ejercicio 3.1: Estructurar un programa como una colecci\u00f3n de funciones Modifique su programa report.py para que todas las operaciones principales, incluyendo los c\u00e1lculos y la salida, se lleven a cabo mediante una colecci\u00f3n de funciones. Espec\u00edficamente: Cree una funci\u00f3n print_report(report) que imprima el informe. Cambie la \u00faltima parte del programa para que no sea m\u00e1s que una serie de llamadas a funciones y ning\u00fan otro c\u00e1lculo. Ejercicio 3.2: Creaci\u00f3n de una funci\u00f3n de nivel superior para la ejecuci\u00f3n del programa Tome la \u00faltima parte de su programa y empaquelo en una sola funci\u00f3n portfolio_report(portfolio_filename, prices_filename) . Haga que la funci\u00f3n funcione para que la siguiente llamada de funci\u00f3n cree el informe como antes: portfolio_report('Data/portfolio.csv', 'Data/prices.csv') En esta versi\u00f3n final, su programa no ser\u00e1 m\u00e1s que una serie de definiciones de funciones seguidas de una \u00fanica llamada de funci\u00f3n portfolio_report() final al (que ejecuta todos los pasos involucrados en el programa). Al convertir su programa en una sola funci\u00f3n, es f\u00e1cil ejecutarlo en diferentes entradas. Por ejemplo, pruebe estas declaraciones de forma interactiva despu\u00e9s de ejecutar su programa: >>> portfolio_report('Data/portfolio2.csv', 'Data/prices.csv') >>> # mire la salida de la linea anterior >>> files = ['Data/portfolio.csv', 'Data/portfolio2.csv'] >>> for name in files: print(f'{name:-^43s}') portfolio_report(name, 'Data/prices.csv') print() >>> # mire la salida del ciclo anterior >>> Comentario Python hace que sea muy f\u00e1cil escribir c\u00f3digo de scripting relativamente no estructurado en el que solo tiene un archivo con una secuencia de declaraciones. En el panorama general, casi siempre es mejor utilizar funciones cuando pueda. En alg\u00fan momento, ese script crecer\u00e1 y desear\u00e1 tener un poco m\u00e1s de organizaci\u00f3n. Adem\u00e1s, un hecho poco conocido es que Python se ejecuta un poco m\u00e1s r\u00e1pido si usa funciones. 3.2 M\u00e1s sobre funciones Aunque las funciones se introdujeron antes, se proporcionaron muy pocos detalles sobre c\u00f3mo funcionan realmente a un nivel m\u00e1s profundo. Esta secci\u00f3n tiene como objetivo llenar algunos vac\u00edos y discutir asuntos como convenciones de llamadas, reglas de alcance y m\u00e1s. 3.2.1 Llamar a una funci\u00f3n Considere esta funci\u00f3n: def read_prices(filename, debug): ... Puede llamar a la funci\u00f3n con argumentos posicionales: prices = read_prices('prices.csv', True) O puede llamar a la funci\u00f3n con argumentos de palabras clave: prices = read_prices(filename='prices.csv', debug=True) 3.2.2 Argumentos predeterminados A veces quieres que un argumento sea opcional. Si es as\u00ed, asigne un valor predeterminado en la definici\u00f3n de funci\u00f3n. def read_prices(filename, debug=False): ... Si se asigna un valor predeterminado, el argumento es opcional en las llamadas a funciones. d = read_prices('prices.csv') e = read_prices('prices.dat', True) Nota: Los argumentos con valores predeterminados deben aparecer al final de la lista de argumentos (todos los argumentos no opcionales van primero). 3.2.3 Prefiera argumentos de palabras clave vs argumentos opcionales Compare y contraste estos dos estilos de llamadas diferentes: parse_data(data, False, True) # ????? parse_data(data, ignore_errors=True) parse_data(data, debug=True) parse_data(data, debug=True, ignore_errors=True) En la mayor\u00eda de los casos, los argumentos de palabras clave mejoran la claridad del c\u00f3digo, especialmente para argumentos que sirven como indicadores o que est\u00e1n relacionados con caracter\u00edsticas opcionales. 3.2.4 Mejores pr\u00e1cticas de dise\u00f1o Siempre proporcione nombres cortos pero significativos a los argumentos de las funciones. Alguien que use una funci\u00f3n puede querer usar el estilo de llamada de palabras clave. d = read_prices('prices.csv', debug=True) Las herramientas de desarrollo de Python mostrar\u00e1n los nombres en las funciones de ayuda y la documentaci\u00f3n. 3.2.5 Devoluci\u00f3n de valores La declaraci\u00f3n return devuelve un valor def square(x): return x * x Si no se proporciona ning\u00fan valor de retorno o el return falta, se devuelve None . def bar(x): ...declaraciones return a = bar(4) # a = None # O def foo(x): ...declaraciones # Sin `return` b = foo(4) # b = None 3.2.6 M\u00faltiples valores de retorno Las funciones solo pueden devolver un valor. Sin embargo, una funci\u00f3n puede devolver varios valores devolvi\u00e9ndolos en una tupla. def divide(a,b): q = a // b # Cociente r = a % b # Remanente return q, r # Retorna una tuple Ejemplo de uso: x, y = divide(37,5) # x = 7, y = 2 x = divide(37, 5) # x = (7, 2) 3.2.7 Alcance de una variable Los programas asignan valores a las variables. x = value # variable Global def foo(): y = value # variable Local Las asignaciones de variables ocurren fuera y dentro de las definiciones de funciones. Las variables definidas en el exterior son \"globales\". Las variables dentro de una funci\u00f3n son \"locales\". 3.2.8 Variables locales Las variables asignadas dentro de las funciones son privadas. def read_portfolio(filename): portfolio = [] for line in open(filename): fields = line.split(',') s = (fields[0], int(fields[1]), float(fields[2])) portfolio.append(s) return portfolio En este ejemplo, filename , portfolio , line , fields y s son variables locales. Esas variables no se conservan ni se puede acceder a ellas despu\u00e9s de la llamada a la funci\u00f3n. >>> stocks = read_portfolio('portfolio.csv') >>> fields Traceback (most recent call last): File \"<stdin>\", line 1, in ? NameError: name 'fields' is not defined >>> Los locales tampoco pueden entrar en conflicto con las variables que se encuentran en otros lugares. 3.2.9 Variables globales Las funciones pueden acceder libremente a los valores de globales definidos en el mismo archivo. name = 'Dave' def greeting(): print('Hello', name) # Usando `name` variable global Sin embargo, las funciones no pueden modificar los globales: name = 'Dave' def spam(): name = 'Guido' spam() print(name) # prints 'Dave' Recuerde: todas las asignaciones en funciones son locales. 3.2.10 Modificar variables globales Si debe modificar una variable global, debe declararla como tal. name = 'Dave' def spam(): global name name = 'Guido' # cambia el nombre global anterior La declaraci\u00f3n global debe aparecer antes de su uso y la variable correspondiente debe existir en el mismo archivo que la funci\u00f3n. Habiendo visto esto, sepa que se considera de mala forma. De hecho, trate de evitarlo global completo si puede. Si necesita una funci\u00f3n para modificar alg\u00fan tipo de estado fuera de la funci\u00f3n, es mejor usar una clase en su lugar (m\u00e1s sobre esto m\u00e1s adelante). 3.2.11 Transferencia de argumentos Cuando llama a una funci\u00f3n, las variables de argumento son nombres que hacen referencia a los valores pasados. Estos valores NO son copias (consulte la secci\u00f3n 2.7). Si se pasan tipos de datos mutables (por ejemplo, listas, diccionarios), se pueden modificar en el lugar. def foo(items): items.append(42) # Modifica el objeto de entrada a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] Punto clave: las funciones no reciben una copia de los argumentos de entrada. 3.2.12 Reasignaci\u00f3n vs modificaci\u00f3n Aseg\u00farese de comprender la sutil diferencia entre modificar un valor y reasignar un nombre de variable. def foo(items): items.append(42) # Modifica el objeto de entrada a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] # VS def bar(items): items = [4,5,6] # Reasigna variable local `items` a otro objeto b = [1, 2, 3] bar(b) print(b) # [1, 2, 3] Recordatorio: la asignaci\u00f3n de variables nunca sobrescribe la memoria. El nombre simplemente est\u00e1 vinculado a un nuevo valor. 3.2.13 Ejercicios Este conjunto de ejercicios le permite implementar lo que es, quiz\u00e1s, la parte m\u00e1s poderosa y dif\u00edcil del curso. Hay muchos pasos y muchos conceptos de ejercicios anteriores que se juntan todos a la vez. La soluci\u00f3n final es solo de unas 25 l\u00edneas de c\u00f3digo, pero t\u00f3mese su tiempo y aseg\u00farese de comprender cada parte. Una parte central de su programa report.py se centra en la lectura de archivos CSV. Por ejemplo, la funci\u00f3n read_portfolio() lee un archivo que contiene filas de datos de cartera y la funci\u00f3n read_prices() lee un archivo que contiene filas de datos de precios. En ambas funciones, hay muchas partes \"complicadas\" de bajo nivel y caracter\u00edsticas similares. Por ejemplo, ambos abren un archivo y lo envuelven con el m\u00f3dulo csv y ambos convierten varios campos en nuevos tipos. Si estuvieses haciendo mucho an\u00e1lisis de archivos, probablemente queras limpiar algo de esto y hacerlo m\u00e1s general. Ese es nuestro objetivo. Comience este ejercicio abriendo un archivo llamado fileparse.py . Aqu\u00ed es donde estaremos haciendo nuestro trabajo. Ejercicio 3.3: lectura de archivos CSV Para empezar, centr\u00e9monos en el problema de leer un archivo CSV en una lista de diccionarios. En el archivo fileparse.py , defina una funci\u00f3n que se vea as\u00ed: # fileparse.py import csv def parse_csv(filename): ''' Convierte un archivo CSV a una lista de registro ''' with open(filename) as f: rows = csv.reader(f) headers = next(rows) # Lee la primera fila con el encabezado records = [] for row in rows: if not row: # Omite filas sin data continue record = dict(zip(headers, row)) records.append(record) return records Esta funci\u00f3n lee un archivo CSV en una lista de diccionarios mientras oculta los detalles de la apertura del archivo, lo envuelve con el m\u00f3dulo csv , ignora las l\u00edneas en blanco, etc. Pru\u00e9belo: Sugerencia: $ python3 -i fileparse.py . >>> portfolio = parse_csv('Data/portfolio.csv') >>> portfolio [{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> Esto es bueno, excepto que no puede hacer ning\u00fan tipo de c\u00e1lculo \u00fatil con los datos porque todo est\u00e1 representado como una cadena. Arreglaremos esto en breve, pero sigamos mejorandolo. Ejercicio 3.4: Creaci\u00f3n de un selector de columnas En muchos casos, solo le interesan las columnas seleccionadas de un archivo CSV, no todos los datos. Modifique la funci\u00f3n parse_csv() para que, opcionalmente, permita que las columnas especificadas por el usuario se seleccionen de la siguiente manera: >>> # Lea toda la data >>> portfolio = parse_csv('Data/portfolio.csv') >>> portfolio [{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> # Lee solo parte de la data >>> shares_held = parse_csv('Data/portfolio.csv', select=['name','shares']) >>> shares_held [{'name': 'AA', 'shares': '100'}, {'name': 'IBM', 'shares': '50'}, {'name': 'CAT', 'shares': '150'}, {'name': 'MSFT', 'shares': '200'}, {'name': 'GE', 'shares': '95'}, {'name': 'MSFT', 'shares': '50'}, {'name': 'IBM', 'shares': '100'}] >>> En el ejercicio 2.23 se dio un ejemplo de selector de columnas. Sin embargo, aqu\u00ed hay una forma de hacerlo: # fileparse.py import csv def parse_csv(filename, select=None): ''' Convierte un archivo CSV file a una lista de registros ''' with open(filename) as f: rows = csv.reader(f) # Read the file headers headers = next(rows) # Si se proporcion\u00f3 un selector de columna, busque los \u00edndices de las # columnas especificadas. # Tambi\u00e9n reduzca el conjunto de encabezados utilizados para los diccionarios resultantes if select: indices = [headers.index(colname) for colname in select] headers = select else: indices = [] records = [] for row in rows: if not row: # Omitir filas sin data continue # Filtrar la fila si se seleccionaron columnas espec\u00edficas if indices: row = [ row[index] for index in indices ] # Crear diccionario record = dict(zip(headers, row)) records.append(record) return records Hay una serie de partes complicadas en esta parte. Probablemente lo m\u00e1s importante es el mapeo de las columnas seleccionadas a los \u00edndices de filas. Por ejemplo, suponga que el archivo de entrada tiene los siguientes encabezados: >>> headers = ['name', 'date', 'time', 'shares', 'price'] >>> Ahora, suponga que las columnas seleccionadas fueran las siguientes: >>> select = ['name', 'shares'] >>> Para realizar la selecci\u00f3n adecuada, debe asignar los nombres de las columnas seleccionadas a los \u00edndices de las columnas en el archivo. Eso es lo que est\u00e1 haciendo este paso: >>> indices = [headers.index(colname) for colname in select] >>> indices [0, 3] >>> En otras palabras, \"nombre\" es la columna 0 y \"recursos compartidos\" es la columna 3 . Cuando lee una fila de datos del archivo, los \u00edndices se utilizan para filtrarla: >>> row = ['AA', '6/11/2007', '9:50am', '100', '32.20' ] >>> row = [ row[index] for index in indices ] >>> row ['AA', '100'] >>> Ejercicio 3.5: Realizaci\u00f3n de conversi\u00f3n de tipos Modifique la funci\u00f3n parse_csv() para que, opcionalmente, permita que se apliquen conversiones de tipo a los datos devueltos. Por ejemplo: >>> portfolio = parse_csv('Data/portfolio.csv', types=[str, int, float]) >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}] >>> shares_held = parse_csv('Data/portfolio.csv', select=['name', 'shares'], types=[str, int]) >>> shares_held [{'name': 'AA', 'shares': 100}, {'name': 'IBM', 'shares': 50}, {'name': 'CAT', 'shares': 150}, {'name': 'MSFT', 'shares': 200}, {'name': 'GE', 'shares': 95}, {'name': 'MSFT', 'shares': 50}, {'name': 'IBM', 'shares': 100}] >>> Ya explor\u00f3 esto en el ejercicio 2.24. Deber\u00e1 insertar el siguiente fragmento de c\u00f3digo en su soluci\u00f3n: ... if types: row = [func(val) for func, val in zip(types, row) ] ... Ejercicio 3.6: Trabajar sin encabezados Algunos archivos CSV no incluyen informaci\u00f3n de encabezado. Por ejemplo, el archivo se prices.csvve as\u00ed: \"AA\",9.22 \"AXP\",24.85 \"BA\",44.85 \"BAC\",11.27 ... Modifique la parse_csv() funci\u00f3n para que pueda trabajar con dichos archivos creando una lista de tuplas. Por ejemplo: >>> prices = parse_csv('Data/prices.csv', types=[str,float], has_headers=False) >>> prices [('AA', 9.22), ('AXP', 24.85), ('BA', 44.85), ('BAC', 11.27), ('C', 3.72), ('CAT', 35.46), ('CVX', 66.67), ('DD', 28.47), ('DIS', 24.22), ('GE', 13.48), ('GM', 0.75), ('HD', 23.16), ('HPQ', 34.35), ('IBM', 106.28), ('INTC', 15.72), ('JNJ', 55.16), ('JPM', 36.9), ('KFT', 26.11), ('KO', 49.16), ('MCD', 58.99), ('MMM', 57.1), ('MRK', 27.58), ('MSFT', 20.89), ('PFE', 15.19), ('PG', 51.94), ('T', 24.79), ('UTX', 52.61), ('VZ', 29.26), ('WMT', 49.74), ('XOM', 69.35)] >>> Para realizar este cambio, deber\u00e1 modificar el c\u00f3digo para que la primera l\u00ednea de datos no se interprete como una l\u00ednea de encabezado. Adem\u00e1s, deber\u00e1 asegurarse de no crear diccionarios, ya que ya no hay nombres de columna para usar como claves. Ejercicio 3.7: elegir un delimitador de columna diferente Aunque los archivos CSV son bastante comunes, tambi\u00e9n es posible que encuentre un archivo que use un separador de columna diferente, como una sangr\u00eda (tab) o un espacio. Por ejemplo, el archivo se Data/portfolio.datve as\u00ed: name shares price \"AA\" 100 32.20 \"IBM\" 50 91.10 \"CAT\" 150 83.44 \"MSFT\" 200 51.23 \"GE\" 95 40.37 \"MSFT\" 50 65.10 \"IBM\" 100 70.44 La funci\u00f3n csv.reader() permite dar un delimitador de columna diferente de la siguiente manera: rows = csv.reader(f, delimiter=' ') Modifique su funci\u00f3n parse_csv() para que tambi\u00e9n permita cambiar el delimitador. Por ejemplo: >>> portfolio = parse_csv('Data/portfolio.dat', types=[str, int, float], delimiter=' ') >>> portfolio [{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> Comentario Si ha llegado hasta aqu\u00ed, ha creado una agradable funci\u00f3n de biblioteca que es realmente \u00fatil. Puede usarla para analizar archivos CSV arbitrarios, seleccionar columnas de inter\u00e9s, realizar conversiones de tipos, sin tener que preocuparse demasiado por el funcionamiento interno de los archivos o el m\u00f3dulo csv. 3.3 Comprobaci\u00f3n de errores Aunque las excepciones se introdujeron anteriormente, esta secci\u00f3n incluye algunos detalles adicionales sobre la verificaci\u00f3n de errores y el manejo de excepciones. 3.3.1 C\u00f3mo fallan los programas Python no realiza ninguna verificaci\u00f3n ni validaci\u00f3n de los tipos o valores de los argumentos de la funci\u00f3n. Una funci\u00f3n funcionar\u00e1 con cualquier dato que sea compatible con las declaraciones de la funci\u00f3n. def add(x, y): return x + y add(3, 4) # 7 add('Hello', 'World') # 'HelloWorld' add('3', '4') # '34' Si hay errores en una funci\u00f3n, aparecen en tiempo de ejecuci\u00f3n (como excepci\u00f3n). def add(x, y): return x + y >>> add(3, '4') Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +: 'int' and 'str' >>> Para verificar el c\u00f3digo, hay un fuerte \u00e9nfasis en las pruebas (se tratar\u00e1 m\u00e1s adelante). 3.3.2 Excepciones Las excepciones se utilizan para se\u00f1alar errores. Para plantear una excepci\u00f3n usted mismo, haga uso de la declaraci\u00f3n raise. if name not in authorized: raise RuntimeError(f'{name} not authorized') Para detectar una excepci\u00f3n, utilice try-except. try: authenticate(username) except RuntimeError as e: print(e) 3.3.3 Manejo de excepciones Las excepciones se propagan a la primera coincidencia except. def grok(): ... raise RuntimeError('Whoa!') # Excepci\u00f3n se alza aqu\u00ed def spam(): grok() # Esto alzr\u00e1 la excepci\u00f3n def bar(): try: spam() except RuntimeError as e: # La excepci\u00f3n se atrapa aqu\u00ed ... def foo(): try: bar() except RuntimeError as e: # La excepci\u00f3n no llega aqu\u00ed ... foo() Para manejar la excepci\u00f3n, coloque declaraciones en el exceptbloque. Puede agregar cualquier declaraci\u00f3n que desee para manejar el error. def grok(): ... raise RuntimeError('Whoa!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n se atrapa aqu\u00ed declaraciones # Use estas declaraciones declaraciones ... bar() Despu\u00e9s del manejo, la ejecuci\u00f3n se reanuda con la primera declaraci\u00f3n despu\u00e9s de try-except. def grok(): ... raise RuntimeError('Whoa!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n se atrapa aqu\u00ed statements statements ... statements # Reanuda ejecuci\u00f3n aqu\u00ed statements # y contin\u00faa aqu\u00ed ... bar() 3.3.4 Excepciones integradas Hay alrededor de dos docenas de excepciones integradas. Por lo general, el nombre de la excepci\u00f3n es indicativo de lo que est\u00e1 mal (por ejemplo, ValueError se genera a porque proporcion\u00f3 un valor incorrecto). Esta no es una lista exhaustiva. Consulte la documentaci\u00f3n para obtener m\u00e1s informaci\u00f3n. ArithmeticError AssertionError EnvironmentError EOFError ImportError IndexError KeyboardInterrupt KeyError MemoryError NameError ReferenceError RuntimeError SyntaxError SystemError TypeError ValueError 3.3.5 Valores de excepci\u00f3n Las excepciones tienen un valor asociado. Contiene informaci\u00f3n m\u00e1s espec\u00edfica sobre lo que est\u00e1 mal. raise RuntimeError('Invalid user name') Este valor es parte de la instancia de excepci\u00f3n que se coloca en la variable proporcionada a except. try: ... except RuntimeError as e: # `e` holds the exception raised ... e es una instancia del tipo de excepci\u00f3n. Sin embargo, a menudo parece una cadena cuando se imprime. except RuntimeError as e: print('Failed : Reason', e) 3.3.6 Detectar varios errores Puede detectar diferentes tipos de excepciones utilizando varios bloques except . try: ... except LookupError as e: ... except RuntimeError as e: ... except IOError as e: ... except KeyboardInterrupt as e: ... Alternativamente, si las declaraciones para gestionar las excepciones son las mismas, puede agruparlas: try: ... except (IOError,LookupError,RuntimeError) as e: ... 3.3.7 Detectar todos los errores Para detectar cualquier excepci\u00f3n, use Exception as\u00ed: try: ... except Exception: # PELIGRO. Mire abajo. print('An error occurred') En general, escribir c\u00f3digo como ese es una mala idea porque no sabr\u00e1 la raz\u00f3n del fallo, toda vez que est\u00e1 atrapando todos los errores. 3.3.8 Manera incorrecta de detectar errores Esta es la forma incorrecta de usar las excepciones. try: go_do_something() except Exception: print('Computer says no') Esto detecta todos los errores posibles y puede hacer que sea imposible depurar cuando el c\u00f3digo falla por alguna raz\u00f3n que no esperaba (por ejemplo, m\u00f3dulo Python desinstalado, etc.). 3.3.9 Otro enfoque Si va a detectar todos los errores, este es un enfoque m\u00e1s sensato. try: go_do_something() except Exception as e: print('Computer says no. Reason :', e) Informe sobre el motivo espec\u00edfico de la falla. Casi siempre es una buena idea tener alg\u00fan mecanismo para ver / informar errores cuando escribe c\u00f3digo que detecta todas las posibles excepciones. Sin embargo, en general, es mejor detectar el error de la forma m\u00e1s precisa posible. Solo detecte los errores que realmente pueda manejar. Deje pasar otros errores, tal vez alg\u00fan otro c\u00f3digo pueda manejarlos. 3.3.7 Volver a plantear una excepci\u00f3n \u00dase raise para propagar un error detectado. try: go_do_something() except Exception as e: print('Computer says no. Reason :', e) raise Esto le permite tomar medidas (por ejemplo, reporter\u00eda) y transmitir el error al objeto que llama la funci\u00f3n. 3.3.8 Mejores pr\u00e1cticas de excepci\u00f3n No atrapes excepciones. Falle r\u00e1pido y fuerte. Si es importante, alguien m\u00e1s se ocupar\u00e1 del problema. Solo capture una excepci\u00f3n si se puede recuperar y seguir adelante con el programa. 3.3.9 declaraci\u00f3n finally Especifique el c\u00f3digo que debe ejecutarse independientemente de si se produce una excepci\u00f3n o no. candado = Candado() ... candado.acquire() try: ... finally: candado.release() # esto SIEMPRE se ejecutar\u00e1. Con y sin excepci\u00f3n. Se usa com\u00fanmente para administrar recursos de manera segura (especialmente bloqueos (locks), archivos, etc.). 3.3.10 declaraci\u00f3n with En c\u00f3digo de hoy en d\u00eda, un try-finally a menudo se reemplaza con la declaraci\u00f3n with . candado = Candado() with candado: # candado adquirido ... # candado liberado Un ejemplo m\u00e1s familiar: with open(filename) as f: # Utilice el archivo ... # Archivo cerrado with define un contexto de uso para un recurso. Cuando la ejecuci\u00f3n sale de ese contexto, se liberan los recursos. with solo funciona con ciertos objetos que han sido programados espec\u00edficamente para soportarlo. 3.3.9 Ejercicios Ejercicio 3.8: Generaci\u00f3n de excepciones La funci\u00f3n parse_csv() que escribi\u00f3 en la \u00faltima secci\u00f3n permite seleccionar columnas especificadas por el usuario, pero eso solo funciona si el archivo de datos de entrada tiene encabezados de columna. Modifique el c\u00f3digo para que se genere una excepci\u00f3n si se pasan los argumentos select y has_headers=False . Por ejemplo: >>> parse_csv('Data/prices.csv', select=['name','price'], has_headers=False) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 9, in parse_csv raise RuntimeError(\"select argument requires column headers\") RuntimeError: select argument requires column headers >>> Una vez haya agregado esta comprobaci\u00f3n, puede preguntarse si deber\u00eda realizar otros tipos de comprobaciones en la funci\u00f3n. Por ejemplo, \u00bfdeber\u00eda comprobar que el nombre del archivo es una cadena, que los tipos son una lista o algo por el estilo? Como regla general, es mejor omitir tales pruebas y dejar que el programa falle en entradas incorrectas. El mensaje de rastreo se\u00f1alar\u00e1 la fuente del problema y puede ayudar en la depuraci\u00f3n. La raz\u00f3n principal para agregar la verificaci\u00f3n anterior es evitar ejecutar el c\u00f3digo en un modo sin sentido (por ejemplo, usando una funci\u00f3n que requiere encabezados de columna, pero especificando simult\u00e1neamente que no hay encabezados). Esto indica un error de programaci\u00f3n por parte del c\u00f3digo de llamada. A menudo, es una buena idea verificar los casos que \"no se supone que sucedan\". Ejercicio 3.9: captura de excepciones La funci\u00f3n parse_csv() que escribi\u00f3 se utiliza para procesar todo el contenido de un archivo. Sin embargo, en el mundo real, es posible que los archivos de entrada tengan datos da\u00f1ados, faltantes o sucios. Pruebe este experimento: >>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float]) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 36, in parse_csv row = [func(val) for func, val in zip(types, row)] ValueError: invalid literal for int() with base 10: '' >>> Modifique la funci\u00f3n parse_csv() para detectar todas las excepciones ValueError generadas durante la creaci\u00f3n de registros e imprima un mensaje de advertencia para las filas que no se pueden convertir. El mensaje debe incluir el n\u00famero de fila e informaci\u00f3n sobre la raz\u00f3n por la que fall\u00f3. Para probar su funci\u00f3n, intente leer el archivo de Data/missing.csv arriba. Por ejemplo: >>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float]) Row 4: Couldn't convert ['MSFT', '', '51.23'] Row 4: Reason invalid literal for int() with base 10: '' Row 7: Couldn't convert ['IBM', '', '70.44'] Row 7: Reason invalid literal for int() with base 10: '' >>> >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}] >>> Ejercicio 3.10: Silenciar errores Modifique la funci\u00f3n parse_csv() para que los mensajes de error de an\u00e1lisis puedan silenciarse si el usuario lo desea expl\u00edcitamente. Por ejemplo: >>> portfolio = parse_csv('Data/missing.csv', types=[str,int,float], silence_errors=True) >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}] >>> El manejo de errores es una de las cosas m\u00e1s dif\u00edciles de corregir en la mayor\u00eda de los programas. Como regla general, no debe ignorar silenciosamente los errores . En su lugar, es mejor informar problemas y darle al usuario la opci\u00f3n de silenciar el mensaje de error si as\u00ed lo desea. 3.4 M\u00f3dulos Esta secci\u00f3n presenta el concepto de m\u00f3dulos y el trabajo con funciones que abarcan varios archivos. 3.4.1 M\u00f3dulos e importaci\u00f3n Cualquier archivo fuente de Python es un m\u00f3dulo. # foo.py def grok(a): ... def spam(b): ... La declaraci\u00f3n import carga y ejecuta un m\u00f3dulo. # program.py import foo a = foo.grok(2) b = foo.spam('Hello') ... 3.4.2 \u00c1mbito o espacio de nombres Un m\u00f3dulo es una colecci\u00f3n de valores con nombre y, a veces, se dice que es un espacio de nombres. Es un contenedor abstracto creado para alojar una agrupaci\u00f3n l\u00f3gica de identificadores \u00fanicos. Los nombres son todas las variables y funciones globales definidas en el archivo fuente. Despu\u00e9s de la importaci\u00f3n, el nombre del m\u00f3dulo se utiliza como prefijo. De ah\u00ed es donde viene el concepto de \u00e1mbti o espacio de nombres. import foo a = foo.grok(2) b = foo.spam('Hello') ... El nombre del m\u00f3dulo est\u00e1 directamente vinculado al nombre del archivo (foo -> foo.py). 3.4.3 Definiciones globales Todo lo definido en el \u00e1mbito global es lo que llena el espacio de nombres del m\u00f3dulo. Considere dos m\u00f3dulos que definen la misma variable x. # foo.py x = 42 def grok(a): ... # bar.py x = 37 def spam(a): ... En este caso, las definiciones x se refieren a diferentes variables. Uno es foo.x y el otro es bar.x . Diferentes m\u00f3dulos pueden usar los mismos nombres y esos nombres no entrar\u00e1n en conflicto entre s\u00ed. Los m\u00f3dulos est\u00e1n aislados. 3.4.4 M\u00f3dulos como entornos Los m\u00f3dulos forman un entorno envolvente para todo el c\u00f3digo definido en el interior. # foo.py x = 42 def grok(a): print(x) Las variables globales siempre est\u00e1n vinculadas al m\u00f3dulo adjunto (mismo archivo). Cada archivo fuente es su propio peque\u00f1o universo. 3.4.5 Ejecuci\u00f3n del m\u00f3dulo Cuando se importa un m\u00f3dulo, todas las declaraciones del m\u00f3dulo se ejecutan una tras otra hasta que se llega al final del archivo. El contenido del espacio de nombres del m\u00f3dulo son todos los nombres globales que a\u00fan est\u00e1n definidos al final del proceso de ejecuci\u00f3n. Si hay sentencias de scripting que llevan a cabo tareas en el \u00e1mbito global (impresi\u00f3n, creaci\u00f3n de archivos, etc.) las ver\u00e1 ejecutar en la importaci\u00f3n. 3.4.6 declaraci\u00f3n import as Puede cambiar el nombre de un m\u00f3dulo a medida que lo importa: import math as m def rectangular(r, theta): x = r * m.cos(theta) y = r * m.sin(theta) return x, y Funciona igual que una importaci\u00f3n normal. Simplemente cambia el nombre del m\u00f3dulo en ese archivo. 3.4.7 importaci\u00f3n de m\u00f3dulo con from Esto selecciona los s\u00edmbolos seleccionados de un m\u00f3dulo y los hace disponibles localmente. from math import sin, cos def rectangular(r, theta): x = r * cos(theta) y = r * sin(theta) return x, y Esto permite utilizar partes de un m\u00f3dulo sin tener que escribir el prefijo del m\u00f3dulo. Es \u00fatil para nombres de uso frecuente. 3.4.8 Comentarios sobre la importaci\u00f3n Las variaciones en la importaci\u00f3n no cambian la forma en que funcionan los m\u00f3dulos. import math # vs import math as m # vs from math import cos, sin ... En concreto, import siempre ejecuta todo el archivo y los m\u00f3dulos siguen siendo entornos aislados. La declaraci\u00f3n import as solo cambia el nombre localmente. La declaraci\u00f3n from math import cos, sin todav\u00eda carga todo el m\u00f3dulo de matem\u00e1ticas detr\u00e1s de escena. Simplemente copia los nombres cos y sin del m\u00f3dulo en el espacio local una vez hecho. 3.4.9 Carga del m\u00f3dulo Cada m\u00f3dulo se carga y se ejecuta solo una vez. Nota: Las importaciones repetidas solo devuelven una referencia al m\u00f3dulo cargado anteriormente. sys.modules es un dictado de todos los m\u00f3dulos cargados. >>> import sys >>> sys.modules.keys() ['copy_reg', '__main__', 'site', '__builtin__', 'encodings', 'encodings.encodings', 'posixpath', ...] >>> Precauci\u00f3n: surge una com\u00fan confusi\u00f3n si repite una declaraci\u00f3n import despu\u00e9s de cambiar el c\u00f3digo fuente de un m\u00f3dulo. Debido a la memoria cach\u00e9 del m\u00f3dulo sys.modules, las importaciones repetidas siempre devuelven el m\u00f3dulo cargado anteriormente, incluso si se realiz\u00f3 un cambio. La forma m\u00e1s segura de cargar c\u00f3digo modificado en Python es salir y reiniciar el int\u00e9rprete. 3.4.10 Localizaci\u00f3n de m\u00f3dulos Python consulta una lista de rutas ( sys.path ) cuando busca m\u00f3dulos. >>> import sys >>> sys.path [ '', '/usr/local/lib/python36/python36.zip', '/usr/local/lib/python36', ... ] El directorio de trabajo actual suele ser el primero. 3.4.11 Ruta de b\u00fasqueda del m\u00f3dulo Como se se\u00f1al\u00f3 anteriormente, sys.path contiene las rutas de b\u00fasqueda. Puede ajustarlo manualmente si es necesario. import sys sys.path.append('/project/foo/pyfiles') Las rutas tambi\u00e9n se pueden agregar mediante variables de entorno. $ env PYTHONPATH=/project/foo/pyfiles python3 Python 3.6.0 (default, Feb 3 2017, 05:53:21) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)] >>> import sys >>> sys.path ['','/project/foo/pyfiles', ...] Como regla general, no deber\u00eda ser necesario ajustar manualmente la ruta de b\u00fasqueda del m\u00f3dulo. Sin embargo, a veces surge si est\u00e1 intentando importar c\u00f3digo Python que se encuentra en una ubicaci\u00f3n inusual o que no es f\u00e1cilmente accesible desde el directorio de trabajo actual. Ejercicios Para este ejercicio que involucra m\u00f3dulos, es de vital importancia asegurarse de que est\u00e1 ejecutando Python en un entorno adecuado. Los m\u00f3dulos a menudo presentan a los nuevos programadores problemas relacionados con el directorio de trabajo actual o con la configuraci\u00f3n de la ruta de Python. Para este curso, se asume que est\u00e1 escribiendo todo su c\u00f3digo en el directorio donde est\u00e1n todos sus archivos de trabajo. Para obtener los mejores resultados, debe asegurarse de estar tambi\u00e9n en ese directorio cuando inicie el int\u00e9rprete. De lo contrario, debe asegurarse de que su directorio de trabajo se agregue a sys.path . Ejercicio 3.11: Importaciones de m\u00f3dulos En la secci\u00f3n 3, creamos una funci\u00f3n de prop\u00f3sito general parse_csv() para analizar el contenido de los archivos de datos CSV. Ahora, veremos c\u00f3mo usar esa funci\u00f3n en otros programas. Primero, comience en una nueva ventana de shell. Navega hasta la carpeta donde tienes todos tus archivos. Los vamos a importar. Inicie el modo interactivo de Python. $ python Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Una vez que haya hecho eso, intente importar algunos de los programas que escribi\u00f3 anteriormente. Deber\u00eda ver su salida exactamente como antes. Solo para enfatizar: la importaci\u00f3n de un m\u00f3dulo ejecuta su c\u00f3digo. >>> import bounce ... mire la salida ... >>> import mortgage ... mire la salida ... >>> import report ... mire la salida ... >>> Si nada de esto funciona, probablemente est\u00e9 ejecutando Python en el directorio incorrecto. Ahora, intente importar su m\u00f3dulo fileparse y obtenga ayuda sobre \u00e9l. >>> import fileparse >>> help(fileparse) ... mire la salida ... >>> dir(fileparse) ... mire la salida ... >>> Intente usar el m\u00f3dulo para leer algunos datos: >>> portfolio = fileparse.parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float]) >>> portfolio ... look at the output ... >>> pricelist = fileparse.parse_csv('Data/prices.csv', types=[str,float], has_headers=False) >>> pricelist ... look at the output ... >>> prices = dict(pricelist) >>> prices ... look at the output ... >>> prices['IBM'] 106.11 >>> Intente importar una funci\u00f3n para que no necesite incluir el nombre del m\u00f3dulo: >>> from fileparse import parse_csv >>> portfolio = parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float]) >>> portfolio ... look at the output ... >>> Ejercicio 3.12: Uso de su m\u00f3dulo de biblioteca En la secci\u00f3n 2, escribi\u00f3 un programa report.py que produjo un informe de acciones como este: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 Tome ese programa y modif\u00edquelo para que todo el procesamiento del archivo de entrada se realice usando funciones en su m\u00f3dulo fileparse . Para hacer eso, importe fileparse como m\u00f3dulo y cambie las funciones read_portfolio() y read_prices() para usar la funci\u00f3n parse_csv() . Utilice el ejemplo interactivo al comienzo de este ejercicio como gu\u00eda. Posteriormente, deber\u00eda obtener exactamente el mismo resultado que antes. Ejercicio 3.14: Uso de m\u00e1s importaciones de bibliotecas En la secci\u00f3n 1, escribi\u00f3 un programa pcost.py que ley\u00f3 una cartera y calcul\u00f3 su costo. >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> Modifique el archivo pcost.py para que use la funci\u00f3n report.read_portfolio() . Comentario Cuando haya terminado con este ejercicio, debe tener tres programas. 1. fileparse.py que contiene una funci\u00f3n parse_csv() de prop\u00f3sito general. 2. report.py que produce un informe agradable, pero tambi\u00e9n contiene read_portfolio() y read_prices() . 3. Y finalmente, pcost.py que calcula el costo de la cartera, pero hace uso de la read_portfolio() funci\u00f3n escrita para el report.py programa. 3.5 M\u00f3dulo principal Esta secci\u00f3n presenta el concepto de programa principal o m\u00f3dulo principal. 3.5.1 Funciones principales En muchos lenguajes de programaci\u00f3n, hay un concepto de principal funci\u00f3n o m\u00e9todo. // c / c++ int main(int argc, char *argv[]) { ... } // java class myprog { public static void main(String args[]) { ... } } Esta es la primera funci\u00f3n que se ejecuta cuando se inicia una aplicaci\u00f3n. 3.5.2 M\u00f3dulo principal de Python Python no tiene principal funci\u00f3n o m\u00e9todo. En cambio, hay un m\u00f3dulo principal. El m\u00f3dulo principal es el archivo fuente que se ejecuta primero. $ python3 prog.py ... Cualquier archivo que le d\u00e9 al int\u00e9rprete al inicio se convierte en principal. No importa el nombre. 3.5.2 main Es una pr\u00e1ctica est\u00e1ndar para los m\u00f3dulos que se ejecutan como un script principal utilizar esta convenci\u00f3n: # prog.py ... if __name__ == '__main__': # Ejecutando el programa principal ... declaraciones ... Las declaraciones incluidas dentro de la declaraci\u00f3n if se convierten en el programa principal . 3.5.3 Programas principales frente a importaciones de bibliotecas Cualquier archivo de Python puede ejecutarse como principal o como una importaci\u00f3n de biblioteca: $ python prog.py # Running as main import prog # Running as library import En ambos casos, __name__ es el nombre del m\u00f3dulo. Sin embargo, solo se establecer\u00e1 en __main__ si se ejecuta como main. Por lo general, no desea que las instrucciones que forman parte del programa principal se ejecuten en una importaci\u00f3n de biblioteca. Por lo tanto, es com\u00fan tener un if-c\u00f3digo de verificaci\u00f3n que se puede usar de cualquier manera. if __name__ == '__main__': # Does not execute if loaded with import ... 3.5.3 Plantilla de programa Aqu\u00ed hay una plantilla de programa com\u00fan para escribir un programa Python: # prog.py # declaracioens import (librerias) import modules # Functions def spam(): ... def blah(): ... # Main function def main(): ... if __name__ == '__main__': main() 3.5.4 Herramientas de l\u00ednea de comandos Python se usa a menudo para herramientas de l\u00ednea de comandos $ python report.py portfolio.csv prices.csv Significa que los scripts se ejecutan desde el shell / terminal. Los casos de uso comunes son para automatizaci\u00f3n, tareas en segundo plano, etc. 3.5.5 Argumentos de l\u00ednea de comando La l\u00ednea de comando es una lista de cadenas de texto. $ python report.py portfolio.csv prices.csv Esta lista de cadenas de texto se encuentra en sys.argv . # en el comando de terminal previo sys.argv # ['report.py, 'portfolio.csv', 'prices.csv'] Aqu\u00ed hay un ejemplo simple de procesamiento de argumentos: import sys if len(sys.argv) != 3: raise SystemExit(f'Usage: {sys.argv[0]} ' 'portfile pricefile') portfile = sys.argv[1] pricefile = sys.argv[2] ... 3.5.6 Est\u00e1ndar I/O (Entrada/Salida) La entrada / salida est\u00e1ndar (o stdio ) son archivos que funcionan igual que los archivos normales. sys.stdout sys.stderr sys.stdin De forma predeterminada, la impresi\u00f3n est\u00e1 dirigida a sys.stdout. Se lee la entrada sys.stdin . Los rastreos y errores est\u00e1n dirigidos a sys.stderr . Tenga en cuenta que stdio podr\u00eda estar conectado a terminales, archivos, tuber\u00edas, etc. $ python prog.py > results.txt # o $ cmd1 | python3 prog.py | cmd2 3.5.7 Variables de entorno Las variables de entorno se establecen en el shell. $ setenv NAME dave $ setenv RSH ssh $ python prog.py os.environ es un diccionario que contiene estos valores. import os name = os.environ['NAME'] # 'dave' Los cambios se reflejan en cualquier subproceso que el programa inicie posteriormente. 3.5.8 Saliendo del programa La salida de un programa se maneja mediante excepciones. raise SystemExit raise SystemExit(exitcode) raise SystemExit('Informative message') Una alternativa. import sys sys.exit(exitcode) Un c\u00f3digo de salida distinto de cero indica un error. 3.5.9 La #!linea En Unix, la #!l\u00ednea puede lanzar un script como Python. Agregue lo siguiente a la primera l\u00ednea de su archivo de secuencia de comandos. #!/usr/bin/env python3 # prog.py ... Requiere el permiso ejecutable. bash % chmod +x prog.py # Then you can execute bash % prog.py ... output ... Nota: Python Launcher en Windows tambi\u00e9n busca la #!l\u00ednea para indicar la versi\u00f3n del idioma. 3.5.10 Plantilla de script Finalmente, aqu\u00ed hay una plantilla de c\u00f3digo com\u00fan para los programas de Python que se ejecutan como scripts de l\u00ednea de comandos: #!/usr/bin/env python3 # prog.py # declaraciones import (libraries) import modules # Functions def spam(): ... def blah(): ... # funci\u00f3n main] def main(argv): # analice linea de argumentos, ambiente, etc. ... if __name__ == '__main__': import sys main(sys.argv) 3.5.11 Ejercicios Ejercicio 3.15: funciones main() En el archivo, report.pyagregue una funci\u00f3n main() que acepte una lista de opciones de l\u00ednea de comando y produzca el mismo resultado que antes. Deber\u00eda poder ejecutarlo de forma interactiva as\u00ed: >>> import report >>> report.main(['report.py', 'Data/portfolio.csv', 'Data/prices.csv']) Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Modifique el pcost.py archivo para que tenga una main() funci\u00f3n similar: >>> import pcost >>> pcost.main(['pcost.py', 'Data/portfolio.csv']) Total cost: 44671.15 >>> Ejercicio 3.16: Creaci\u00f3n de guiones Modifique los programas report.py y pcost.py para que puedan ejecutarse como un script en la l\u00ednea de comando: $ python3 report.py Data/portfolio.csv Data/prices.csv Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 $ python pcost.py Data/portfolio.csv Total cost: 44671.15 3.6 Discusi\u00f3n del dise\u00f1o En esta secci\u00f3n, reconsideramos una decisi\u00f3n de dise\u00f1o tomada anteriormente. 3.6.1 Nombres de archivo versus iterables Compare estos dos programas que devuelven el mismo resultado. # proporcione un nombre de archivo def read_data(filename): records = [] with open(filename) as f: for line in f: ... records.append(r) return records d = read_data('file.csv') # proporcione lineas def read_data(lines): records = [] for line in lines: ... records.append(r) return records with open('file.csv') as f: d = read_data(f) \u00bfCu\u00e1l de estas funciones prefieres? \u00bfPor qu\u00e9? \u00bfCu\u00e1l de estas funciones es m\u00e1s flexible? 3.6.2 Idea profunda: \"Duck Typing\" Duck Typing es un concepto de programaci\u00f3n de computadoras para determinar si un objeto se puede usar para un prop\u00f3sito particular. Es una aplicaci\u00f3n de la prueba del pato . Si parece un pato, nada como un pato y grazna como un pato, entonces probablemente sea un pato. En la segunda versi\u00f3n de read_data() arriba, la funci\u00f3n espera cualquier objeto iterable. No solo las l\u00edneas de un archivo. def read_data(lines): records = [] for line in lines: ... records.append(r) return records Esto significa que podemos usarlo con otras l\u00edneas. # archivo CSV lines = open('data.csv') data = read_data(lines) # archivo zipped lines = gzip.open('data.csv.gz','rt') data = read_data(lines) # entrada est\u00e1ndar lines = sys.stdin data = read_data(lines) # lista de cadenas lines = ['ACME,50,91.1','IBM,75,123.45', ... ] data = read_data(lines) Hay una considerable flexibilidad con este dise\u00f1o. Pregunta: \u00bfDebemos aceptar o rechazar esta flexibilidad? Piense en los pros y cons y llegue a una conclus\u00ed\u00f3n a base de los mismos. Considere que distintos tipos de requerimentos le impulsarian hacia m\u00e1s o menos flexibilidad. 3.6.3 Mejores pr\u00e1cticas de dise\u00f1o de bibliotecas Las bibliotecas de c\u00f3digos a menudo se sirven mejor adoptando la flexibilidad. No restrinja sus opciones. Una gran flexibilidad conlleva un gran poder. 3.6.4 Ejercicio Ejercicio 3.17: De nombres de archivo a objetos similares a archivos Ahora ha creado un archivo fileparse.py que contiene una funci\u00f3n parse_csv() . La funci\u00f3n funcion\u00f3 as\u00ed: >>> import fileparse >>> portfolio = fileparse.parse_csv('Data/portfolio.csv', types=[str,int,float]) >>> En este momento, la funci\u00f3n espera que se le pase un nombre de archivo. Sin embargo, puede hacer que el c\u00f3digo sea m\u00e1s flexible. Modifique la funci\u00f3n para que funcione con cualquier objeto similar a un archivo / iterable. Por ejemplo: >>> import fileparse >>> import gzip >>> with gzip.open('Data/portfolio.csv.gz', 'rt') as file: ... port = fileparse.parse_csv(file, types=[str,int,float]) ... >>> lines = ['name,shares,price', 'AA,100,34.23', 'IBM,50,91.1', 'HPE,75,45.1'] >>> port = fileparse.parse_csv(lines, types=[str,int,float]) >>> En este nuevo c\u00f3digo, \u00bfqu\u00e9 sucede si pasa un nombre de archivo como antes? >>> port = fileparse.parse_csv('Data/portfolio.csv', types=[str,int,float]) >>> port ... mire la salida (deber\u00eda estar algo alocada) ... >>> S\u00ed, debe tener cuidado. \u00bfPodr\u00eda agregar un control de seguridad para evitar esto? Ejercicio 3.18: Arreglar funciones existentes Corrija las funciones read_portfolio() y read_prices() en el archivo report.py para que funcionen con la versi\u00f3n modificada de parse_csv() . Esto solo deber\u00eda implicar una peque\u00f1a modificaci\u00f3n. Posteriormente, sus programas report.py y pcost.py deber\u00edan funcionar de la misma manera que siempre.","title":"3 Organizaci\u00f3n de un Programa"},{"location":"3/#3-organizacion-de-un-programa","text":"En este modulo nos empapamos de m\u00e1s detalles sobre la composici\u00f3n de funciones, el manejo de errores y la introducci\u00f3n de modulos. Al final seremos capaces de escribir programas que son subdivididos en funciones esparcidas en varios archivos. Veremos algunas plantillas de c\u00f3digo que les ser\u00e1 \u00fatil para la creaci\u00f3n de programas.","title":"3. Organizaci\u00f3n de un Programa"},{"location":"3/#31-scripting","text":"En esta parte, veremos m\u00e1s de cerca la pr\u00e1ctica de escribir scripts en Python.","title":"3.1 Scripting"},{"location":"3/#311-que-es-un-guion-script","text":"Un script es un programa que ejecuta una serie de declaraciones y se detiene. # programa.py declaracion1 declaracion2 declaracion3 ... Hasta ahora, vale destacar que hemos estado escribiendo scripts .","title":"3.1.1 \u00bfQu\u00e9 es un gui\u00f3n / script?"},{"location":"3/#312-un-problema","text":"Si escribe un script \u00fatil, crecer\u00e1 en caracter\u00edsticas y funcionalidad. Es posible que desee aplicarlo a otros problemas relacionados. Con el tiempo, podr\u00eda convertirse en una aplicaci\u00f3n cr\u00edtica. Sin embargo, podr\u00eda convertirse en un gran enredado si no tiene cuidado. Entonces, es importante tener alg\u00fan tipo de organizaci\u00f3n.","title":"3.1.2 Un problema"},{"location":"3/#313-definiendo-cosas","text":"Los nombres siempre deben definirse antes de que se utilicen m\u00e1s tarde. def square(x): return x*x a = 42 b = a + 2 # requiere que `a` est\u00e9 definida z = square(b) # require que `square` y `b` esten definidas El orden es importante. Casi siempre colocas las definiciones de variables y funciones cerca de la parte superior.","title":"3.1.3 Definiendo cosas"},{"location":"3/#314-definicion-de-funciones","text":"Es una buena idea poner todo el c\u00f3digo relacionado con una sola tarea en un solo lugar. Para esto, haga uso de una funci\u00f3n. def read_prices(filename): prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Una funci\u00f3n tambi\u00e9n simplifica las operaciones repetidas. oldprices = read_prices('oldprices.csv') newprices = read_prices('newprices.csv')","title":"3.1.4 Definici\u00f3n de funciones"},{"location":"3/#315-que-es-una-funcion","text":"Una funci\u00f3n es una secuencia de declaraciones con nombre. def funcname(args): declaracion declaracion ... return result Cualquier declaraci\u00f3n de Python se puede utilizar dentro. def foo(): import math print(math.sqrt(2)) help(math) No hay declaraciones especiales en Python (lo que hace que sea f\u00e1cil de recordar).","title":"3.1.5 \u00bfQu\u00e9 es una funci\u00f3n?"},{"location":"3/#316-definicion-de-funcion","text":"Las funciones se pueden definir en cualquier orden. def foo(x): bar(x) def bar(x): declaracion # OR def bar(x): declaracion def foo(x): bar(x) Las funciones solo deben definirse antes de ser utilizadas (o llamadas) durante la ejecuci\u00f3n del programa. foo(3) # foo debi\u00f3 haber estado definida Estil\u00edsticamente, probablemente sea m\u00e1s com\u00fan ver las funciones definidas de abajo hacia arriba.","title":"3.1.6 Definici\u00f3n de funci\u00f3n"},{"location":"3/#317-estilo-de-abajo-hacia-arriba","text":"Las funciones se tratan como bloques de construcci\u00f3n. Los bloques m\u00e1s peque\u00f1os / simples van primero. # myprogram.py def foo(x): ... def bar(x): ... foo(x) # Definida anteriormente ... def spam(x): ... bar(x) # Definida anteriormente ... spam(42) # C\u00f3digo que utiliza las funciones esta definido anteriormente Las funciones posteriores se basan en funciones anteriores. Nuevamente, esto es solo una cuesti\u00f3n de estilo. Lo \u00fanico que importa en el programa anterior es que la llamada spam(42) sea \u200b\u200bla \u00faltima.","title":"3.1.7 Estilo de abajo hacia arriba"},{"location":"3/#318-diseno-de-funciones","text":"Idealmente, las funciones deber\u00edan ser una caja negra . Solo deben operar con entradas pasadas y evitar variables globales y efectos secundarios misteriosos. Sus principales objetivos: modularidad y previsibilidad .","title":"3.1.8 Dise\u00f1o de funciones"},{"location":"3/#319-documentacion-en-cadenas","text":"La documentaci\u00f3n en cadenas, comunmente conocida en ingl\u00e9s como doc strings , es una buena pr\u00e1ctica que incluye un breve resumen de una oraci\u00f3n de lo que hace la funci\u00f3n. Si se necesita m\u00e1s informaci\u00f3n, se incluye un breve ejemplo de uso junto con una descripci\u00f3n m\u00e1s detallada de los argumentos. Las mismas se escriben inmediatamente despu\u00e9s del nombre de la funci\u00f3n y alimentan a help() , el IDE (ambiente integrado de desarrollo) y otras herramientas. def read_prices(filename): '''Lee precios de un archivo CSV file de nombre, precio, y data''' prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices","title":"3.1.9 Documentaci\u00f3n en cadenas"},{"location":"3/#3110-tipo-de-anotaciones","text":"Tambi\u00e9n puede agregar sugerencias de tipo opcionales a las definiciones de funciones. def read_prices(filename: str) -> dict: '''Lee precios de un archivo CSV file de nombre, precio, y data''' prices = {} with open(filename) as f: f_csv = csv.reader(f) for row in f_csv: prices[row[0]] = float(row[1]) return prices Las sugerencias no hacen nada operativamente. Son puramente informativos. Sin embargo, pueden ser utilizados por IDE, verificadores de c\u00f3digo y otras herramientas para hacer m\u00e1s.","title":"3.1.10 Tipo de anotaciones"},{"location":"3/#3111-ejercicios","text":"En la secci\u00f3n 2, escribi\u00f3 un programa llamado report.pyque imprim\u00eda un informe que mostraba el rendimiento de una cartera de acciones. Este programa constaba de algunas funciones. Por ejemplo: # report.py import csv def read_portfolio(filename): '''Lee un archivo de cartera de acciones en una lista de diccionarios con la clave siendo nombre, acciones y precio.''' portfolio = [] with open(filename) as f: rows = csv.reader(f) headers = next(rows) for row in rows: record = dict(zip(headers, row)) stock = { 'name' : record['name'], 'shares' : int(record['shares']), 'price' : float(record['price']) } portfolio.append(stock) return portfolio ... Sin embargo, tambi\u00e9n hubo partes del programa que solo realizaron una serie de c\u00e1lculos con gui\u00f3n. Este c\u00f3digo apareci\u00f3 cerca del final del programa. Por ejemplo: ... # Salida/output del reporte headers = ('Name', 'Shares', 'Price', 'Change') print('%10s %10s %10s %10s' % headers) print(('-' * 10 + ' ') * len(headers)) for row in report: print('%10s %10d %10.2f %10.2f' % row) ... En este ejercicio, tomaremos el programa anterior y lo organizaremos con un poco m\u00e1s de fuerza en torno al uso de funciones.","title":"3.1.11 Ejercicios"},{"location":"3/#ejercicio-31-estructurar-un-programa-como-una-coleccion-de-funciones","text":"Modifique su programa report.py para que todas las operaciones principales, incluyendo los c\u00e1lculos y la salida, se lleven a cabo mediante una colecci\u00f3n de funciones. Espec\u00edficamente: Cree una funci\u00f3n print_report(report) que imprima el informe. Cambie la \u00faltima parte del programa para que no sea m\u00e1s que una serie de llamadas a funciones y ning\u00fan otro c\u00e1lculo.","title":"Ejercicio 3.1: Estructurar un programa como una colecci\u00f3n de funciones"},{"location":"3/#ejercicio-32-creacion-de-una-funcion-de-nivel-superior-para-la-ejecucion-del-programa","text":"Tome la \u00faltima parte de su programa y empaquelo en una sola funci\u00f3n portfolio_report(portfolio_filename, prices_filename) . Haga que la funci\u00f3n funcione para que la siguiente llamada de funci\u00f3n cree el informe como antes: portfolio_report('Data/portfolio.csv', 'Data/prices.csv') En esta versi\u00f3n final, su programa no ser\u00e1 m\u00e1s que una serie de definiciones de funciones seguidas de una \u00fanica llamada de funci\u00f3n portfolio_report() final al (que ejecuta todos los pasos involucrados en el programa). Al convertir su programa en una sola funci\u00f3n, es f\u00e1cil ejecutarlo en diferentes entradas. Por ejemplo, pruebe estas declaraciones de forma interactiva despu\u00e9s de ejecutar su programa: >>> portfolio_report('Data/portfolio2.csv', 'Data/prices.csv') >>> # mire la salida de la linea anterior >>> files = ['Data/portfolio.csv', 'Data/portfolio2.csv'] >>> for name in files: print(f'{name:-^43s}') portfolio_report(name, 'Data/prices.csv') print() >>> # mire la salida del ciclo anterior >>>","title":"Ejercicio 3.2: Creaci\u00f3n de una funci\u00f3n de nivel superior para la ejecuci\u00f3n del programa"},{"location":"3/#comentario","text":"Python hace que sea muy f\u00e1cil escribir c\u00f3digo de scripting relativamente no estructurado en el que solo tiene un archivo con una secuencia de declaraciones. En el panorama general, casi siempre es mejor utilizar funciones cuando pueda. En alg\u00fan momento, ese script crecer\u00e1 y desear\u00e1 tener un poco m\u00e1s de organizaci\u00f3n. Adem\u00e1s, un hecho poco conocido es que Python se ejecuta un poco m\u00e1s r\u00e1pido si usa funciones.","title":"Comentario"},{"location":"3/#32-mas-sobre-funciones","text":"Aunque las funciones se introdujeron antes, se proporcionaron muy pocos detalles sobre c\u00f3mo funcionan realmente a un nivel m\u00e1s profundo. Esta secci\u00f3n tiene como objetivo llenar algunos vac\u00edos y discutir asuntos como convenciones de llamadas, reglas de alcance y m\u00e1s.","title":"3.2 M\u00e1s sobre funciones"},{"location":"3/#321-llamar-a-una-funcion","text":"Considere esta funci\u00f3n: def read_prices(filename, debug): ... Puede llamar a la funci\u00f3n con argumentos posicionales: prices = read_prices('prices.csv', True) O puede llamar a la funci\u00f3n con argumentos de palabras clave: prices = read_prices(filename='prices.csv', debug=True)","title":"3.2.1 Llamar a una funci\u00f3n"},{"location":"3/#322-argumentos-predeterminados","text":"A veces quieres que un argumento sea opcional. Si es as\u00ed, asigne un valor predeterminado en la definici\u00f3n de funci\u00f3n. def read_prices(filename, debug=False): ... Si se asigna un valor predeterminado, el argumento es opcional en las llamadas a funciones. d = read_prices('prices.csv') e = read_prices('prices.dat', True) Nota: Los argumentos con valores predeterminados deben aparecer al final de la lista de argumentos (todos los argumentos no opcionales van primero).","title":"3.2.2 Argumentos predeterminados"},{"location":"3/#323-prefiera-argumentos-de-palabras-clave-vs-argumentos-opcionales","text":"Compare y contraste estos dos estilos de llamadas diferentes: parse_data(data, False, True) # ????? parse_data(data, ignore_errors=True) parse_data(data, debug=True) parse_data(data, debug=True, ignore_errors=True) En la mayor\u00eda de los casos, los argumentos de palabras clave mejoran la claridad del c\u00f3digo, especialmente para argumentos que sirven como indicadores o que est\u00e1n relacionados con caracter\u00edsticas opcionales.","title":"3.2.3 Prefiera argumentos de palabras clave vs argumentos opcionales"},{"location":"3/#324-mejores-practicas-de-diseno","text":"Siempre proporcione nombres cortos pero significativos a los argumentos de las funciones. Alguien que use una funci\u00f3n puede querer usar el estilo de llamada de palabras clave. d = read_prices('prices.csv', debug=True) Las herramientas de desarrollo de Python mostrar\u00e1n los nombres en las funciones de ayuda y la documentaci\u00f3n.","title":"3.2.4 Mejores pr\u00e1cticas de dise\u00f1o"},{"location":"3/#325-devolucion-de-valores","text":"La declaraci\u00f3n return devuelve un valor def square(x): return x * x Si no se proporciona ning\u00fan valor de retorno o el return falta, se devuelve None . def bar(x): ...declaraciones return a = bar(4) # a = None # O def foo(x): ...declaraciones # Sin `return` b = foo(4) # b = None","title":"3.2.5 Devoluci\u00f3n de valores"},{"location":"3/#326-multiples-valores-de-retorno","text":"Las funciones solo pueden devolver un valor. Sin embargo, una funci\u00f3n puede devolver varios valores devolvi\u00e9ndolos en una tupla. def divide(a,b): q = a // b # Cociente r = a % b # Remanente return q, r # Retorna una tuple Ejemplo de uso: x, y = divide(37,5) # x = 7, y = 2 x = divide(37, 5) # x = (7, 2)","title":"3.2.6 M\u00faltiples valores de retorno"},{"location":"3/#327-alcance-de-una-variable","text":"Los programas asignan valores a las variables. x = value # variable Global def foo(): y = value # variable Local Las asignaciones de variables ocurren fuera y dentro de las definiciones de funciones. Las variables definidas en el exterior son \"globales\". Las variables dentro de una funci\u00f3n son \"locales\".","title":"3.2.7 Alcance de una variable"},{"location":"3/#328-variables-locales","text":"Las variables asignadas dentro de las funciones son privadas. def read_portfolio(filename): portfolio = [] for line in open(filename): fields = line.split(',') s = (fields[0], int(fields[1]), float(fields[2])) portfolio.append(s) return portfolio En este ejemplo, filename , portfolio , line , fields y s son variables locales. Esas variables no se conservan ni se puede acceder a ellas despu\u00e9s de la llamada a la funci\u00f3n. >>> stocks = read_portfolio('portfolio.csv') >>> fields Traceback (most recent call last): File \"<stdin>\", line 1, in ? NameError: name 'fields' is not defined >>> Los locales tampoco pueden entrar en conflicto con las variables que se encuentran en otros lugares.","title":"3.2.8 Variables locales"},{"location":"3/#329-variables-globales","text":"Las funciones pueden acceder libremente a los valores de globales definidos en el mismo archivo. name = 'Dave' def greeting(): print('Hello', name) # Usando `name` variable global Sin embargo, las funciones no pueden modificar los globales: name = 'Dave' def spam(): name = 'Guido' spam() print(name) # prints 'Dave' Recuerde: todas las asignaciones en funciones son locales.","title":"3.2.9 Variables globales"},{"location":"3/#3210-modificar-variables-globales","text":"Si debe modificar una variable global, debe declararla como tal. name = 'Dave' def spam(): global name name = 'Guido' # cambia el nombre global anterior La declaraci\u00f3n global debe aparecer antes de su uso y la variable correspondiente debe existir en el mismo archivo que la funci\u00f3n. Habiendo visto esto, sepa que se considera de mala forma. De hecho, trate de evitarlo global completo si puede. Si necesita una funci\u00f3n para modificar alg\u00fan tipo de estado fuera de la funci\u00f3n, es mejor usar una clase en su lugar (m\u00e1s sobre esto m\u00e1s adelante).","title":"3.2.10 Modificar variables globales"},{"location":"3/#3211-transferencia-de-argumentos","text":"Cuando llama a una funci\u00f3n, las variables de argumento son nombres que hacen referencia a los valores pasados. Estos valores NO son copias (consulte la secci\u00f3n 2.7). Si se pasan tipos de datos mutables (por ejemplo, listas, diccionarios), se pueden modificar en el lugar. def foo(items): items.append(42) # Modifica el objeto de entrada a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] Punto clave: las funciones no reciben una copia de los argumentos de entrada.","title":"3.2.11 Transferencia de argumentos"},{"location":"3/#3212-reasignacion-vs-modificacion","text":"Aseg\u00farese de comprender la sutil diferencia entre modificar un valor y reasignar un nombre de variable. def foo(items): items.append(42) # Modifica el objeto de entrada a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] # VS def bar(items): items = [4,5,6] # Reasigna variable local `items` a otro objeto b = [1, 2, 3] bar(b) print(b) # [1, 2, 3] Recordatorio: la asignaci\u00f3n de variables nunca sobrescribe la memoria. El nombre simplemente est\u00e1 vinculado a un nuevo valor.","title":"3.2.12 Reasignaci\u00f3n vs modificaci\u00f3n"},{"location":"3/#3213-ejercicios","text":"Este conjunto de ejercicios le permite implementar lo que es, quiz\u00e1s, la parte m\u00e1s poderosa y dif\u00edcil del curso. Hay muchos pasos y muchos conceptos de ejercicios anteriores que se juntan todos a la vez. La soluci\u00f3n final es solo de unas 25 l\u00edneas de c\u00f3digo, pero t\u00f3mese su tiempo y aseg\u00farese de comprender cada parte. Una parte central de su programa report.py se centra en la lectura de archivos CSV. Por ejemplo, la funci\u00f3n read_portfolio() lee un archivo que contiene filas de datos de cartera y la funci\u00f3n read_prices() lee un archivo que contiene filas de datos de precios. En ambas funciones, hay muchas partes \"complicadas\" de bajo nivel y caracter\u00edsticas similares. Por ejemplo, ambos abren un archivo y lo envuelven con el m\u00f3dulo csv y ambos convierten varios campos en nuevos tipos. Si estuvieses haciendo mucho an\u00e1lisis de archivos, probablemente queras limpiar algo de esto y hacerlo m\u00e1s general. Ese es nuestro objetivo. Comience este ejercicio abriendo un archivo llamado fileparse.py . Aqu\u00ed es donde estaremos haciendo nuestro trabajo.","title":"3.2.13 Ejercicios"},{"location":"3/#ejercicio-33-lectura-de-archivos-csv","text":"Para empezar, centr\u00e9monos en el problema de leer un archivo CSV en una lista de diccionarios. En el archivo fileparse.py , defina una funci\u00f3n que se vea as\u00ed: # fileparse.py import csv def parse_csv(filename): ''' Convierte un archivo CSV a una lista de registro ''' with open(filename) as f: rows = csv.reader(f) headers = next(rows) # Lee la primera fila con el encabezado records = [] for row in rows: if not row: # Omite filas sin data continue record = dict(zip(headers, row)) records.append(record) return records Esta funci\u00f3n lee un archivo CSV en una lista de diccionarios mientras oculta los detalles de la apertura del archivo, lo envuelve con el m\u00f3dulo csv , ignora las l\u00edneas en blanco, etc. Pru\u00e9belo: Sugerencia: $ python3 -i fileparse.py . >>> portfolio = parse_csv('Data/portfolio.csv') >>> portfolio [{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> Esto es bueno, excepto que no puede hacer ning\u00fan tipo de c\u00e1lculo \u00fatil con los datos porque todo est\u00e1 representado como una cadena. Arreglaremos esto en breve, pero sigamos mejorandolo.","title":"Ejercicio 3.3: lectura de archivos CSV"},{"location":"3/#ejercicio-34-creacion-de-un-selector-de-columnas","text":"En muchos casos, solo le interesan las columnas seleccionadas de un archivo CSV, no todos los datos. Modifique la funci\u00f3n parse_csv() para que, opcionalmente, permita que las columnas especificadas por el usuario se seleccionen de la siguiente manera: >>> # Lea toda la data >>> portfolio = parse_csv('Data/portfolio.csv') >>> portfolio [{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>> # Lee solo parte de la data >>> shares_held = parse_csv('Data/portfolio.csv', select=['name','shares']) >>> shares_held [{'name': 'AA', 'shares': '100'}, {'name': 'IBM', 'shares': '50'}, {'name': 'CAT', 'shares': '150'}, {'name': 'MSFT', 'shares': '200'}, {'name': 'GE', 'shares': '95'}, {'name': 'MSFT', 'shares': '50'}, {'name': 'IBM', 'shares': '100'}] >>> En el ejercicio 2.23 se dio un ejemplo de selector de columnas. Sin embargo, aqu\u00ed hay una forma de hacerlo: # fileparse.py import csv def parse_csv(filename, select=None): ''' Convierte un archivo CSV file a una lista de registros ''' with open(filename) as f: rows = csv.reader(f) # Read the file headers headers = next(rows) # Si se proporcion\u00f3 un selector de columna, busque los \u00edndices de las # columnas especificadas. # Tambi\u00e9n reduzca el conjunto de encabezados utilizados para los diccionarios resultantes if select: indices = [headers.index(colname) for colname in select] headers = select else: indices = [] records = [] for row in rows: if not row: # Omitir filas sin data continue # Filtrar la fila si se seleccionaron columnas espec\u00edficas if indices: row = [ row[index] for index in indices ] # Crear diccionario record = dict(zip(headers, row)) records.append(record) return records Hay una serie de partes complicadas en esta parte. Probablemente lo m\u00e1s importante es el mapeo de las columnas seleccionadas a los \u00edndices de filas. Por ejemplo, suponga que el archivo de entrada tiene los siguientes encabezados: >>> headers = ['name', 'date', 'time', 'shares', 'price'] >>> Ahora, suponga que las columnas seleccionadas fueran las siguientes: >>> select = ['name', 'shares'] >>> Para realizar la selecci\u00f3n adecuada, debe asignar los nombres de las columnas seleccionadas a los \u00edndices de las columnas en el archivo. Eso es lo que est\u00e1 haciendo este paso: >>> indices = [headers.index(colname) for colname in select] >>> indices [0, 3] >>> En otras palabras, \"nombre\" es la columna 0 y \"recursos compartidos\" es la columna 3 . Cuando lee una fila de datos del archivo, los \u00edndices se utilizan para filtrarla: >>> row = ['AA', '6/11/2007', '9:50am', '100', '32.20' ] >>> row = [ row[index] for index in indices ] >>> row ['AA', '100'] >>>","title":"Ejercicio 3.4: Creaci\u00f3n de un selector de columnas"},{"location":"3/#ejercicio-35-realizacion-de-conversion-de-tipos","text":"Modifique la funci\u00f3n parse_csv() para que, opcionalmente, permita que se apliquen conversiones de tipo a los datos devueltos. Por ejemplo: >>> portfolio = parse_csv('Data/portfolio.csv', types=[str, int, float]) >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}] >>> shares_held = parse_csv('Data/portfolio.csv', select=['name', 'shares'], types=[str, int]) >>> shares_held [{'name': 'AA', 'shares': 100}, {'name': 'IBM', 'shares': 50}, {'name': 'CAT', 'shares': 150}, {'name': 'MSFT', 'shares': 200}, {'name': 'GE', 'shares': 95}, {'name': 'MSFT', 'shares': 50}, {'name': 'IBM', 'shares': 100}] >>> Ya explor\u00f3 esto en el ejercicio 2.24. Deber\u00e1 insertar el siguiente fragmento de c\u00f3digo en su soluci\u00f3n: ... if types: row = [func(val) for func, val in zip(types, row) ] ...","title":"Ejercicio 3.5: Realizaci\u00f3n de conversi\u00f3n de tipos"},{"location":"3/#ejercicio-36-trabajar-sin-encabezados","text":"Algunos archivos CSV no incluyen informaci\u00f3n de encabezado. Por ejemplo, el archivo se prices.csvve as\u00ed: \"AA\",9.22 \"AXP\",24.85 \"BA\",44.85 \"BAC\",11.27 ... Modifique la parse_csv() funci\u00f3n para que pueda trabajar con dichos archivos creando una lista de tuplas. Por ejemplo: >>> prices = parse_csv('Data/prices.csv', types=[str,float], has_headers=False) >>> prices [('AA', 9.22), ('AXP', 24.85), ('BA', 44.85), ('BAC', 11.27), ('C', 3.72), ('CAT', 35.46), ('CVX', 66.67), ('DD', 28.47), ('DIS', 24.22), ('GE', 13.48), ('GM', 0.75), ('HD', 23.16), ('HPQ', 34.35), ('IBM', 106.28), ('INTC', 15.72), ('JNJ', 55.16), ('JPM', 36.9), ('KFT', 26.11), ('KO', 49.16), ('MCD', 58.99), ('MMM', 57.1), ('MRK', 27.58), ('MSFT', 20.89), ('PFE', 15.19), ('PG', 51.94), ('T', 24.79), ('UTX', 52.61), ('VZ', 29.26), ('WMT', 49.74), ('XOM', 69.35)] >>> Para realizar este cambio, deber\u00e1 modificar el c\u00f3digo para que la primera l\u00ednea de datos no se interprete como una l\u00ednea de encabezado. Adem\u00e1s, deber\u00e1 asegurarse de no crear diccionarios, ya que ya no hay nombres de columna para usar como claves.","title":"Ejercicio 3.6: Trabajar sin encabezados"},{"location":"3/#ejercicio-37-elegir-un-delimitador-de-columna-diferente","text":"Aunque los archivos CSV son bastante comunes, tambi\u00e9n es posible que encuentre un archivo que use un separador de columna diferente, como una sangr\u00eda (tab) o un espacio. Por ejemplo, el archivo se Data/portfolio.datve as\u00ed: name shares price \"AA\" 100 32.20 \"IBM\" 50 91.10 \"CAT\" 150 83.44 \"MSFT\" 200 51.23 \"GE\" 95 40.37 \"MSFT\" 50 65.10 \"IBM\" 100 70.44 La funci\u00f3n csv.reader() permite dar un delimitador de columna diferente de la siguiente manera: rows = csv.reader(f, delimiter=' ') Modifique su funci\u00f3n parse_csv() para que tambi\u00e9n permita cambiar el delimitador. Por ejemplo: >>> portfolio = parse_csv('Data/portfolio.dat', types=[str, int, float], delimiter=' ') >>> portfolio [{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}] >>>","title":"Ejercicio 3.7: elegir un delimitador de columna diferente"},{"location":"3/#comentario_1","text":"Si ha llegado hasta aqu\u00ed, ha creado una agradable funci\u00f3n de biblioteca que es realmente \u00fatil. Puede usarla para analizar archivos CSV arbitrarios, seleccionar columnas de inter\u00e9s, realizar conversiones de tipos, sin tener que preocuparse demasiado por el funcionamiento interno de los archivos o el m\u00f3dulo csv.","title":"Comentario"},{"location":"3/#33-comprobacion-de-errores","text":"Aunque las excepciones se introdujeron anteriormente, esta secci\u00f3n incluye algunos detalles adicionales sobre la verificaci\u00f3n de errores y el manejo de excepciones.","title":"3.3 Comprobaci\u00f3n de errores"},{"location":"3/#331-como-fallan-los-programas","text":"Python no realiza ninguna verificaci\u00f3n ni validaci\u00f3n de los tipos o valores de los argumentos de la funci\u00f3n. Una funci\u00f3n funcionar\u00e1 con cualquier dato que sea compatible con las declaraciones de la funci\u00f3n. def add(x, y): return x + y add(3, 4) # 7 add('Hello', 'World') # 'HelloWorld' add('3', '4') # '34' Si hay errores en una funci\u00f3n, aparecen en tiempo de ejecuci\u00f3n (como excepci\u00f3n). def add(x, y): return x + y >>> add(3, '4') Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +: 'int' and 'str' >>> Para verificar el c\u00f3digo, hay un fuerte \u00e9nfasis en las pruebas (se tratar\u00e1 m\u00e1s adelante).","title":"3.3.1 C\u00f3mo fallan los programas"},{"location":"3/#332-excepciones","text":"Las excepciones se utilizan para se\u00f1alar errores. Para plantear una excepci\u00f3n usted mismo, haga uso de la declaraci\u00f3n raise. if name not in authorized: raise RuntimeError(f'{name} not authorized') Para detectar una excepci\u00f3n, utilice try-except. try: authenticate(username) except RuntimeError as e: print(e)","title":"3.3.2 Excepciones"},{"location":"3/#333-manejo-de-excepciones","text":"Las excepciones se propagan a la primera coincidencia except. def grok(): ... raise RuntimeError('Whoa!') # Excepci\u00f3n se alza aqu\u00ed def spam(): grok() # Esto alzr\u00e1 la excepci\u00f3n def bar(): try: spam() except RuntimeError as e: # La excepci\u00f3n se atrapa aqu\u00ed ... def foo(): try: bar() except RuntimeError as e: # La excepci\u00f3n no llega aqu\u00ed ... foo() Para manejar la excepci\u00f3n, coloque declaraciones en el exceptbloque. Puede agregar cualquier declaraci\u00f3n que desee para manejar el error. def grok(): ... raise RuntimeError('Whoa!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n se atrapa aqu\u00ed declaraciones # Use estas declaraciones declaraciones ... bar() Despu\u00e9s del manejo, la ejecuci\u00f3n se reanuda con la primera declaraci\u00f3n despu\u00e9s de try-except. def grok(): ... raise RuntimeError('Whoa!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n se atrapa aqu\u00ed statements statements ... statements # Reanuda ejecuci\u00f3n aqu\u00ed statements # y contin\u00faa aqu\u00ed ... bar()","title":"3.3.3 Manejo de excepciones"},{"location":"3/#334-excepciones-integradas","text":"Hay alrededor de dos docenas de excepciones integradas. Por lo general, el nombre de la excepci\u00f3n es indicativo de lo que est\u00e1 mal (por ejemplo, ValueError se genera a porque proporcion\u00f3 un valor incorrecto). Esta no es una lista exhaustiva. Consulte la documentaci\u00f3n para obtener m\u00e1s informaci\u00f3n. ArithmeticError AssertionError EnvironmentError EOFError ImportError IndexError KeyboardInterrupt KeyError MemoryError NameError ReferenceError RuntimeError SyntaxError SystemError TypeError ValueError","title":"3.3.4 Excepciones integradas"},{"location":"3/#335-valores-de-excepcion","text":"Las excepciones tienen un valor asociado. Contiene informaci\u00f3n m\u00e1s espec\u00edfica sobre lo que est\u00e1 mal. raise RuntimeError('Invalid user name') Este valor es parte de la instancia de excepci\u00f3n que se coloca en la variable proporcionada a except. try: ... except RuntimeError as e: # `e` holds the exception raised ... e es una instancia del tipo de excepci\u00f3n. Sin embargo, a menudo parece una cadena cuando se imprime. except RuntimeError as e: print('Failed : Reason', e)","title":"3.3.5 Valores de excepci\u00f3n"},{"location":"3/#336-detectar-varios-errores","text":"Puede detectar diferentes tipos de excepciones utilizando varios bloques except . try: ... except LookupError as e: ... except RuntimeError as e: ... except IOError as e: ... except KeyboardInterrupt as e: ... Alternativamente, si las declaraciones para gestionar las excepciones son las mismas, puede agruparlas: try: ... except (IOError,LookupError,RuntimeError) as e: ...","title":"3.3.6 Detectar varios errores"},{"location":"3/#337-detectar-todos-los-errores","text":"Para detectar cualquier excepci\u00f3n, use Exception as\u00ed: try: ... except Exception: # PELIGRO. Mire abajo. print('An error occurred') En general, escribir c\u00f3digo como ese es una mala idea porque no sabr\u00e1 la raz\u00f3n del fallo, toda vez que est\u00e1 atrapando todos los errores.","title":"3.3.7 Detectar todos los errores"},{"location":"3/#338-manera-incorrecta-de-detectar-errores","text":"Esta es la forma incorrecta de usar las excepciones. try: go_do_something() except Exception: print('Computer says no') Esto detecta todos los errores posibles y puede hacer que sea imposible depurar cuando el c\u00f3digo falla por alguna raz\u00f3n que no esperaba (por ejemplo, m\u00f3dulo Python desinstalado, etc.).","title":"3.3.8 Manera incorrecta de detectar errores"},{"location":"3/#339-otro-enfoque","text":"Si va a detectar todos los errores, este es un enfoque m\u00e1s sensato. try: go_do_something() except Exception as e: print('Computer says no. Reason :', e) Informe sobre el motivo espec\u00edfico de la falla. Casi siempre es una buena idea tener alg\u00fan mecanismo para ver / informar errores cuando escribe c\u00f3digo que detecta todas las posibles excepciones. Sin embargo, en general, es mejor detectar el error de la forma m\u00e1s precisa posible. Solo detecte los errores que realmente pueda manejar. Deje pasar otros errores, tal vez alg\u00fan otro c\u00f3digo pueda manejarlos.","title":"3.3.9 Otro enfoque"},{"location":"3/#337-volver-a-plantear-una-excepcion","text":"\u00dase raise para propagar un error detectado. try: go_do_something() except Exception as e: print('Computer says no. Reason :', e) raise Esto le permite tomar medidas (por ejemplo, reporter\u00eda) y transmitir el error al objeto que llama la funci\u00f3n.","title":"3.3.7 Volver a plantear una excepci\u00f3n"},{"location":"3/#338-mejores-practicas-de-excepcion","text":"No atrapes excepciones. Falle r\u00e1pido y fuerte. Si es importante, alguien m\u00e1s se ocupar\u00e1 del problema. Solo capture una excepci\u00f3n si se puede recuperar y seguir adelante con el programa.","title":"3.3.8 Mejores pr\u00e1cticas de excepci\u00f3n"},{"location":"3/#339-declaracion-finally","text":"Especifique el c\u00f3digo que debe ejecutarse independientemente de si se produce una excepci\u00f3n o no. candado = Candado() ... candado.acquire() try: ... finally: candado.release() # esto SIEMPRE se ejecutar\u00e1. Con y sin excepci\u00f3n. Se usa com\u00fanmente para administrar recursos de manera segura (especialmente bloqueos (locks), archivos, etc.).","title":"3.3.9 declaraci\u00f3n finally"},{"location":"3/#3310-declaracion-with","text":"En c\u00f3digo de hoy en d\u00eda, un try-finally a menudo se reemplaza con la declaraci\u00f3n with . candado = Candado() with candado: # candado adquirido ... # candado liberado Un ejemplo m\u00e1s familiar: with open(filename) as f: # Utilice el archivo ... # Archivo cerrado with define un contexto de uso para un recurso. Cuando la ejecuci\u00f3n sale de ese contexto, se liberan los recursos. with solo funciona con ciertos objetos que han sido programados espec\u00edficamente para soportarlo.","title":"3.3.10 declaraci\u00f3n with"},{"location":"3/#339-ejercicios","text":"","title":"3.3.9 Ejercicios"},{"location":"3/#ejercicio-38-generacion-de-excepciones","text":"La funci\u00f3n parse_csv() que escribi\u00f3 en la \u00faltima secci\u00f3n permite seleccionar columnas especificadas por el usuario, pero eso solo funciona si el archivo de datos de entrada tiene encabezados de columna. Modifique el c\u00f3digo para que se genere una excepci\u00f3n si se pasan los argumentos select y has_headers=False . Por ejemplo: >>> parse_csv('Data/prices.csv', select=['name','price'], has_headers=False) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 9, in parse_csv raise RuntimeError(\"select argument requires column headers\") RuntimeError: select argument requires column headers >>> Una vez haya agregado esta comprobaci\u00f3n, puede preguntarse si deber\u00eda realizar otros tipos de comprobaciones en la funci\u00f3n. Por ejemplo, \u00bfdeber\u00eda comprobar que el nombre del archivo es una cadena, que los tipos son una lista o algo por el estilo? Como regla general, es mejor omitir tales pruebas y dejar que el programa falle en entradas incorrectas. El mensaje de rastreo se\u00f1alar\u00e1 la fuente del problema y puede ayudar en la depuraci\u00f3n. La raz\u00f3n principal para agregar la verificaci\u00f3n anterior es evitar ejecutar el c\u00f3digo en un modo sin sentido (por ejemplo, usando una funci\u00f3n que requiere encabezados de columna, pero especificando simult\u00e1neamente que no hay encabezados). Esto indica un error de programaci\u00f3n por parte del c\u00f3digo de llamada. A menudo, es una buena idea verificar los casos que \"no se supone que sucedan\".","title":"Ejercicio 3.8: Generaci\u00f3n de excepciones"},{"location":"3/#ejercicio-39-captura-de-excepciones","text":"La funci\u00f3n parse_csv() que escribi\u00f3 se utiliza para procesar todo el contenido de un archivo. Sin embargo, en el mundo real, es posible que los archivos de entrada tengan datos da\u00f1ados, faltantes o sucios. Pruebe este experimento: >>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float]) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 36, in parse_csv row = [func(val) for func, val in zip(types, row)] ValueError: invalid literal for int() with base 10: '' >>> Modifique la funci\u00f3n parse_csv() para detectar todas las excepciones ValueError generadas durante la creaci\u00f3n de registros e imprima un mensaje de advertencia para las filas que no se pueden convertir. El mensaje debe incluir el n\u00famero de fila e informaci\u00f3n sobre la raz\u00f3n por la que fall\u00f3. Para probar su funci\u00f3n, intente leer el archivo de Data/missing.csv arriba. Por ejemplo: >>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float]) Row 4: Couldn't convert ['MSFT', '', '51.23'] Row 4: Reason invalid literal for int() with base 10: '' Row 7: Couldn't convert ['IBM', '', '70.44'] Row 7: Reason invalid literal for int() with base 10: '' >>> >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}] >>>","title":"Ejercicio 3.9: captura de excepciones"},{"location":"3/#ejercicio-310-silenciar-errores","text":"Modifique la funci\u00f3n parse_csv() para que los mensajes de error de an\u00e1lisis puedan silenciarse si el usuario lo desea expl\u00edcitamente. Por ejemplo: >>> portfolio = parse_csv('Data/missing.csv', types=[str,int,float], silence_errors=True) >>> portfolio [{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}] >>> El manejo de errores es una de las cosas m\u00e1s dif\u00edciles de corregir en la mayor\u00eda de los programas. Como regla general, no debe ignorar silenciosamente los errores . En su lugar, es mejor informar problemas y darle al usuario la opci\u00f3n de silenciar el mensaje de error si as\u00ed lo desea.","title":"Ejercicio 3.10: Silenciar errores"},{"location":"3/#34-modulos","text":"Esta secci\u00f3n presenta el concepto de m\u00f3dulos y el trabajo con funciones que abarcan varios archivos.","title":"3.4 M\u00f3dulos"},{"location":"3/#341-modulos-e-importacion","text":"Cualquier archivo fuente de Python es un m\u00f3dulo. # foo.py def grok(a): ... def spam(b): ... La declaraci\u00f3n import carga y ejecuta un m\u00f3dulo. # program.py import foo a = foo.grok(2) b = foo.spam('Hello') ...","title":"3.4.1 M\u00f3dulos e importaci\u00f3n"},{"location":"3/#342-ambito-o-espacio-de-nombres","text":"Un m\u00f3dulo es una colecci\u00f3n de valores con nombre y, a veces, se dice que es un espacio de nombres. Es un contenedor abstracto creado para alojar una agrupaci\u00f3n l\u00f3gica de identificadores \u00fanicos. Los nombres son todas las variables y funciones globales definidas en el archivo fuente. Despu\u00e9s de la importaci\u00f3n, el nombre del m\u00f3dulo se utiliza como prefijo. De ah\u00ed es donde viene el concepto de \u00e1mbti o espacio de nombres. import foo a = foo.grok(2) b = foo.spam('Hello') ... El nombre del m\u00f3dulo est\u00e1 directamente vinculado al nombre del archivo (foo -> foo.py).","title":"3.4.2 \u00c1mbito o espacio de nombres"},{"location":"3/#343-definiciones-globales","text":"Todo lo definido en el \u00e1mbito global es lo que llena el espacio de nombres del m\u00f3dulo. Considere dos m\u00f3dulos que definen la misma variable x. # foo.py x = 42 def grok(a): ... # bar.py x = 37 def spam(a): ... En este caso, las definiciones x se refieren a diferentes variables. Uno es foo.x y el otro es bar.x . Diferentes m\u00f3dulos pueden usar los mismos nombres y esos nombres no entrar\u00e1n en conflicto entre s\u00ed. Los m\u00f3dulos est\u00e1n aislados.","title":"3.4.3 Definiciones globales"},{"location":"3/#344-modulos-como-entornos","text":"Los m\u00f3dulos forman un entorno envolvente para todo el c\u00f3digo definido en el interior. # foo.py x = 42 def grok(a): print(x) Las variables globales siempre est\u00e1n vinculadas al m\u00f3dulo adjunto (mismo archivo). Cada archivo fuente es su propio peque\u00f1o universo.","title":"3.4.4 M\u00f3dulos como entornos"},{"location":"3/#345-ejecucion-del-modulo","text":"Cuando se importa un m\u00f3dulo, todas las declaraciones del m\u00f3dulo se ejecutan una tras otra hasta que se llega al final del archivo. El contenido del espacio de nombres del m\u00f3dulo son todos los nombres globales que a\u00fan est\u00e1n definidos al final del proceso de ejecuci\u00f3n. Si hay sentencias de scripting que llevan a cabo tareas en el \u00e1mbito global (impresi\u00f3n, creaci\u00f3n de archivos, etc.) las ver\u00e1 ejecutar en la importaci\u00f3n.","title":"3.4.5 Ejecuci\u00f3n del m\u00f3dulo"},{"location":"3/#346-declaracion-import-as","text":"Puede cambiar el nombre de un m\u00f3dulo a medida que lo importa: import math as m def rectangular(r, theta): x = r * m.cos(theta) y = r * m.sin(theta) return x, y Funciona igual que una importaci\u00f3n normal. Simplemente cambia el nombre del m\u00f3dulo en ese archivo.","title":"3.4.6 declaraci\u00f3n import as"},{"location":"3/#347-importacion-de-modulo-con-from","text":"Esto selecciona los s\u00edmbolos seleccionados de un m\u00f3dulo y los hace disponibles localmente. from math import sin, cos def rectangular(r, theta): x = r * cos(theta) y = r * sin(theta) return x, y Esto permite utilizar partes de un m\u00f3dulo sin tener que escribir el prefijo del m\u00f3dulo. Es \u00fatil para nombres de uso frecuente.","title":"3.4.7 importaci\u00f3n de m\u00f3dulo con from"},{"location":"3/#348-comentarios-sobre-la-importacion","text":"Las variaciones en la importaci\u00f3n no cambian la forma en que funcionan los m\u00f3dulos. import math # vs import math as m # vs from math import cos, sin ... En concreto, import siempre ejecuta todo el archivo y los m\u00f3dulos siguen siendo entornos aislados. La declaraci\u00f3n import as solo cambia el nombre localmente. La declaraci\u00f3n from math import cos, sin todav\u00eda carga todo el m\u00f3dulo de matem\u00e1ticas detr\u00e1s de escena. Simplemente copia los nombres cos y sin del m\u00f3dulo en el espacio local una vez hecho.","title":"3.4.8 Comentarios sobre la importaci\u00f3n"},{"location":"3/#349-carga-del-modulo","text":"Cada m\u00f3dulo se carga y se ejecuta solo una vez. Nota: Las importaciones repetidas solo devuelven una referencia al m\u00f3dulo cargado anteriormente. sys.modules es un dictado de todos los m\u00f3dulos cargados. >>> import sys >>> sys.modules.keys() ['copy_reg', '__main__', 'site', '__builtin__', 'encodings', 'encodings.encodings', 'posixpath', ...] >>> Precauci\u00f3n: surge una com\u00fan confusi\u00f3n si repite una declaraci\u00f3n import despu\u00e9s de cambiar el c\u00f3digo fuente de un m\u00f3dulo. Debido a la memoria cach\u00e9 del m\u00f3dulo sys.modules, las importaciones repetidas siempre devuelven el m\u00f3dulo cargado anteriormente, incluso si se realiz\u00f3 un cambio. La forma m\u00e1s segura de cargar c\u00f3digo modificado en Python es salir y reiniciar el int\u00e9rprete.","title":"3.4.9 Carga del m\u00f3dulo"},{"location":"3/#3410-localizacion-de-modulos","text":"Python consulta una lista de rutas ( sys.path ) cuando busca m\u00f3dulos. >>> import sys >>> sys.path [ '', '/usr/local/lib/python36/python36.zip', '/usr/local/lib/python36', ... ] El directorio de trabajo actual suele ser el primero.","title":"3.4.10 Localizaci\u00f3n de m\u00f3dulos"},{"location":"3/#3411-ruta-de-busqueda-del-modulo","text":"Como se se\u00f1al\u00f3 anteriormente, sys.path contiene las rutas de b\u00fasqueda. Puede ajustarlo manualmente si es necesario. import sys sys.path.append('/project/foo/pyfiles') Las rutas tambi\u00e9n se pueden agregar mediante variables de entorno. $ env PYTHONPATH=/project/foo/pyfiles python3 Python 3.6.0 (default, Feb 3 2017, 05:53:21) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)] >>> import sys >>> sys.path ['','/project/foo/pyfiles', ...] Como regla general, no deber\u00eda ser necesario ajustar manualmente la ruta de b\u00fasqueda del m\u00f3dulo. Sin embargo, a veces surge si est\u00e1 intentando importar c\u00f3digo Python que se encuentra en una ubicaci\u00f3n inusual o que no es f\u00e1cilmente accesible desde el directorio de trabajo actual.","title":"3.4.11 Ruta de b\u00fasqueda del m\u00f3dulo"},{"location":"3/#ejercicios","text":"Para este ejercicio que involucra m\u00f3dulos, es de vital importancia asegurarse de que est\u00e1 ejecutando Python en un entorno adecuado. Los m\u00f3dulos a menudo presentan a los nuevos programadores problemas relacionados con el directorio de trabajo actual o con la configuraci\u00f3n de la ruta de Python. Para este curso, se asume que est\u00e1 escribiendo todo su c\u00f3digo en el directorio donde est\u00e1n todos sus archivos de trabajo. Para obtener los mejores resultados, debe asegurarse de estar tambi\u00e9n en ese directorio cuando inicie el int\u00e9rprete. De lo contrario, debe asegurarse de que su directorio de trabajo se agregue a sys.path .","title":"Ejercicios"},{"location":"3/#ejercicio-311-importaciones-de-modulos","text":"En la secci\u00f3n 3, creamos una funci\u00f3n de prop\u00f3sito general parse_csv() para analizar el contenido de los archivos de datos CSV. Ahora, veremos c\u00f3mo usar esa funci\u00f3n en otros programas. Primero, comience en una nueva ventana de shell. Navega hasta la carpeta donde tienes todos tus archivos. Los vamos a importar. Inicie el modo interactivo de Python. $ python Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Una vez que haya hecho eso, intente importar algunos de los programas que escribi\u00f3 anteriormente. Deber\u00eda ver su salida exactamente como antes. Solo para enfatizar: la importaci\u00f3n de un m\u00f3dulo ejecuta su c\u00f3digo. >>> import bounce ... mire la salida ... >>> import mortgage ... mire la salida ... >>> import report ... mire la salida ... >>> Si nada de esto funciona, probablemente est\u00e9 ejecutando Python en el directorio incorrecto. Ahora, intente importar su m\u00f3dulo fileparse y obtenga ayuda sobre \u00e9l. >>> import fileparse >>> help(fileparse) ... mire la salida ... >>> dir(fileparse) ... mire la salida ... >>> Intente usar el m\u00f3dulo para leer algunos datos: >>> portfolio = fileparse.parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float]) >>> portfolio ... look at the output ... >>> pricelist = fileparse.parse_csv('Data/prices.csv', types=[str,float], has_headers=False) >>> pricelist ... look at the output ... >>> prices = dict(pricelist) >>> prices ... look at the output ... >>> prices['IBM'] 106.11 >>> Intente importar una funci\u00f3n para que no necesite incluir el nombre del m\u00f3dulo: >>> from fileparse import parse_csv >>> portfolio = parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float]) >>> portfolio ... look at the output ... >>>","title":"Ejercicio 3.11: Importaciones de m\u00f3dulos"},{"location":"3/#ejercicio-312-uso-de-su-modulo-de-biblioteca","text":"En la secci\u00f3n 2, escribi\u00f3 un programa report.py que produjo un informe de acciones como este: Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 Tome ese programa y modif\u00edquelo para que todo el procesamiento del archivo de entrada se realice usando funciones en su m\u00f3dulo fileparse . Para hacer eso, importe fileparse como m\u00f3dulo y cambie las funciones read_portfolio() y read_prices() para usar la funci\u00f3n parse_csv() . Utilice el ejemplo interactivo al comienzo de este ejercicio como gu\u00eda. Posteriormente, deber\u00eda obtener exactamente el mismo resultado que antes.","title":"Ejercicio 3.12: Uso de su m\u00f3dulo de biblioteca"},{"location":"3/#ejercicio-314-uso-de-mas-importaciones-de-bibliotecas","text":"En la secci\u00f3n 1, escribi\u00f3 un programa pcost.py que ley\u00f3 una cartera y calcul\u00f3 su costo. >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> Modifique el archivo pcost.py para que use la funci\u00f3n report.read_portfolio() .","title":"Ejercicio 3.14: Uso de m\u00e1s importaciones de bibliotecas"},{"location":"3/#comentario_2","text":"Cuando haya terminado con este ejercicio, debe tener tres programas. 1. fileparse.py que contiene una funci\u00f3n parse_csv() de prop\u00f3sito general. 2. report.py que produce un informe agradable, pero tambi\u00e9n contiene read_portfolio() y read_prices() . 3. Y finalmente, pcost.py que calcula el costo de la cartera, pero hace uso de la read_portfolio() funci\u00f3n escrita para el report.py programa.","title":"Comentario"},{"location":"3/#35-modulo-principal","text":"Esta secci\u00f3n presenta el concepto de programa principal o m\u00f3dulo principal.","title":"3.5 M\u00f3dulo principal"},{"location":"3/#351-funciones-principales","text":"En muchos lenguajes de programaci\u00f3n, hay un concepto de principal funci\u00f3n o m\u00e9todo. // c / c++ int main(int argc, char *argv[]) { ... } // java class myprog { public static void main(String args[]) { ... } } Esta es la primera funci\u00f3n que se ejecuta cuando se inicia una aplicaci\u00f3n.","title":"3.5.1 Funciones principales"},{"location":"3/#352-modulo-principal-de-python","text":"Python no tiene principal funci\u00f3n o m\u00e9todo. En cambio, hay un m\u00f3dulo principal. El m\u00f3dulo principal es el archivo fuente que se ejecuta primero. $ python3 prog.py ... Cualquier archivo que le d\u00e9 al int\u00e9rprete al inicio se convierte en principal. No importa el nombre.","title":"3.5.2 M\u00f3dulo principal de Python"},{"location":"3/#352-main","text":"Es una pr\u00e1ctica est\u00e1ndar para los m\u00f3dulos que se ejecutan como un script principal utilizar esta convenci\u00f3n: # prog.py ... if __name__ == '__main__': # Ejecutando el programa principal ... declaraciones ... Las declaraciones incluidas dentro de la declaraci\u00f3n if se convierten en el programa principal .","title":"3.5.2 main"},{"location":"3/#353-programas-principales-frente-a-importaciones-de-bibliotecas","text":"Cualquier archivo de Python puede ejecutarse como principal o como una importaci\u00f3n de biblioteca: $ python prog.py # Running as main import prog # Running as library import En ambos casos, __name__ es el nombre del m\u00f3dulo. Sin embargo, solo se establecer\u00e1 en __main__ si se ejecuta como main. Por lo general, no desea que las instrucciones que forman parte del programa principal se ejecuten en una importaci\u00f3n de biblioteca. Por lo tanto, es com\u00fan tener un if-c\u00f3digo de verificaci\u00f3n que se puede usar de cualquier manera. if __name__ == '__main__': # Does not execute if loaded with import ...","title":"3.5.3 Programas principales frente a importaciones de bibliotecas"},{"location":"3/#353-plantilla-de-programa","text":"Aqu\u00ed hay una plantilla de programa com\u00fan para escribir un programa Python: # prog.py # declaracioens import (librerias) import modules # Functions def spam(): ... def blah(): ... # Main function def main(): ... if __name__ == '__main__': main()","title":"3.5.3 Plantilla de programa"},{"location":"3/#354-herramientas-de-linea-de-comandos","text":"Python se usa a menudo para herramientas de l\u00ednea de comandos $ python report.py portfolio.csv prices.csv Significa que los scripts se ejecutan desde el shell / terminal. Los casos de uso comunes son para automatizaci\u00f3n, tareas en segundo plano, etc.","title":"3.5.4 Herramientas de l\u00ednea de comandos"},{"location":"3/#355-argumentos-de-linea-de-comando","text":"La l\u00ednea de comando es una lista de cadenas de texto. $ python report.py portfolio.csv prices.csv Esta lista de cadenas de texto se encuentra en sys.argv . # en el comando de terminal previo sys.argv # ['report.py, 'portfolio.csv', 'prices.csv'] Aqu\u00ed hay un ejemplo simple de procesamiento de argumentos: import sys if len(sys.argv) != 3: raise SystemExit(f'Usage: {sys.argv[0]} ' 'portfile pricefile') portfile = sys.argv[1] pricefile = sys.argv[2] ...","title":"3.5.5 Argumentos de l\u00ednea de comando"},{"location":"3/#356-estandar-io-entradasalida","text":"La entrada / salida est\u00e1ndar (o stdio ) son archivos que funcionan igual que los archivos normales. sys.stdout sys.stderr sys.stdin De forma predeterminada, la impresi\u00f3n est\u00e1 dirigida a sys.stdout. Se lee la entrada sys.stdin . Los rastreos y errores est\u00e1n dirigidos a sys.stderr . Tenga en cuenta que stdio podr\u00eda estar conectado a terminales, archivos, tuber\u00edas, etc. $ python prog.py > results.txt # o $ cmd1 | python3 prog.py | cmd2","title":"3.5.6  Est\u00e1ndar I/O (Entrada/Salida)"},{"location":"3/#357-variables-de-entorno","text":"Las variables de entorno se establecen en el shell. $ setenv NAME dave $ setenv RSH ssh $ python prog.py os.environ es un diccionario que contiene estos valores. import os name = os.environ['NAME'] # 'dave' Los cambios se reflejan en cualquier subproceso que el programa inicie posteriormente.","title":"3.5.7 Variables de entorno"},{"location":"3/#358-saliendo-del-programa","text":"La salida de un programa se maneja mediante excepciones. raise SystemExit raise SystemExit(exitcode) raise SystemExit('Informative message') Una alternativa. import sys sys.exit(exitcode) Un c\u00f3digo de salida distinto de cero indica un error.","title":"3.5.8 Saliendo del programa"},{"location":"3/#359-la-linea","text":"En Unix, la #!l\u00ednea puede lanzar un script como Python. Agregue lo siguiente a la primera l\u00ednea de su archivo de secuencia de comandos. #!/usr/bin/env python3 # prog.py ... Requiere el permiso ejecutable. bash % chmod +x prog.py # Then you can execute bash % prog.py ... output ... Nota: Python Launcher en Windows tambi\u00e9n busca la #!l\u00ednea para indicar la versi\u00f3n del idioma.","title":"3.5.9 La #!linea"},{"location":"3/#3510-plantilla-de-script","text":"Finalmente, aqu\u00ed hay una plantilla de c\u00f3digo com\u00fan para los programas de Python que se ejecutan como scripts de l\u00ednea de comandos: #!/usr/bin/env python3 # prog.py # declaraciones import (libraries) import modules # Functions def spam(): ... def blah(): ... # funci\u00f3n main] def main(argv): # analice linea de argumentos, ambiente, etc. ... if __name__ == '__main__': import sys main(sys.argv)","title":"3.5.10 Plantilla de script"},{"location":"3/#3511-ejercicios","text":"","title":"3.5.11 Ejercicios"},{"location":"3/#ejercicio-315-funciones-main","text":"En el archivo, report.pyagregue una funci\u00f3n main() que acepte una lista de opciones de l\u00ednea de comando y produzca el mismo resultado que antes. Deber\u00eda poder ejecutarlo de forma interactiva as\u00ed: >>> import report >>> report.main(['report.py', 'Data/portfolio.csv', 'Data/prices.csv']) Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Modifique el pcost.py archivo para que tenga una main() funci\u00f3n similar: >>> import pcost >>> pcost.main(['pcost.py', 'Data/portfolio.csv']) Total cost: 44671.15 >>> Ejercicio 3.16: Creaci\u00f3n de guiones Modifique los programas report.py y pcost.py para que puedan ejecutarse como un script en la l\u00ednea de comando: $ python3 report.py Data/portfolio.csv Data/prices.csv Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 $ python pcost.py Data/portfolio.csv Total cost: 44671.15","title":"Ejercicio 3.15: funciones main()"},{"location":"3/#36-discusion-del-diseno","text":"En esta secci\u00f3n, reconsideramos una decisi\u00f3n de dise\u00f1o tomada anteriormente.","title":"3.6 Discusi\u00f3n del dise\u00f1o"},{"location":"3/#361-nombres-de-archivo-versus-iterables","text":"Compare estos dos programas que devuelven el mismo resultado. # proporcione un nombre de archivo def read_data(filename): records = [] with open(filename) as f: for line in f: ... records.append(r) return records d = read_data('file.csv') # proporcione lineas def read_data(lines): records = [] for line in lines: ... records.append(r) return records with open('file.csv') as f: d = read_data(f) \u00bfCu\u00e1l de estas funciones prefieres? \u00bfPor qu\u00e9? \u00bfCu\u00e1l de estas funciones es m\u00e1s flexible?","title":"3.6.1 Nombres de archivo versus iterables"},{"location":"3/#362-idea-profunda-duck-typing","text":"Duck Typing es un concepto de programaci\u00f3n de computadoras para determinar si un objeto se puede usar para un prop\u00f3sito particular. Es una aplicaci\u00f3n de la prueba del pato . Si parece un pato, nada como un pato y grazna como un pato, entonces probablemente sea un pato. En la segunda versi\u00f3n de read_data() arriba, la funci\u00f3n espera cualquier objeto iterable. No solo las l\u00edneas de un archivo. def read_data(lines): records = [] for line in lines: ... records.append(r) return records Esto significa que podemos usarlo con otras l\u00edneas. # archivo CSV lines = open('data.csv') data = read_data(lines) # archivo zipped lines = gzip.open('data.csv.gz','rt') data = read_data(lines) # entrada est\u00e1ndar lines = sys.stdin data = read_data(lines) # lista de cadenas lines = ['ACME,50,91.1','IBM,75,123.45', ... ] data = read_data(lines) Hay una considerable flexibilidad con este dise\u00f1o. Pregunta: \u00bfDebemos aceptar o rechazar esta flexibilidad? Piense en los pros y cons y llegue a una conclus\u00ed\u00f3n a base de los mismos. Considere que distintos tipos de requerimentos le impulsarian hacia m\u00e1s o menos flexibilidad.","title":"3.6.2  Idea profunda: \"Duck Typing\""},{"location":"3/#363-mejores-practicas-de-diseno-de-bibliotecas","text":"Las bibliotecas de c\u00f3digos a menudo se sirven mejor adoptando la flexibilidad. No restrinja sus opciones. Una gran flexibilidad conlleva un gran poder.","title":"3.6.3 Mejores pr\u00e1cticas de dise\u00f1o de bibliotecas"},{"location":"3/#364-ejercicio","text":"","title":"3.6.4 Ejercicio"},{"location":"3/#ejercicio-317-de-nombres-de-archivo-a-objetos-similares-a-archivos","text":"Ahora ha creado un archivo fileparse.py que contiene una funci\u00f3n parse_csv() . La funci\u00f3n funcion\u00f3 as\u00ed: >>> import fileparse >>> portfolio = fileparse.parse_csv('Data/portfolio.csv', types=[str,int,float]) >>> En este momento, la funci\u00f3n espera que se le pase un nombre de archivo. Sin embargo, puede hacer que el c\u00f3digo sea m\u00e1s flexible. Modifique la funci\u00f3n para que funcione con cualquier objeto similar a un archivo / iterable. Por ejemplo: >>> import fileparse >>> import gzip >>> with gzip.open('Data/portfolio.csv.gz', 'rt') as file: ... port = fileparse.parse_csv(file, types=[str,int,float]) ... >>> lines = ['name,shares,price', 'AA,100,34.23', 'IBM,50,91.1', 'HPE,75,45.1'] >>> port = fileparse.parse_csv(lines, types=[str,int,float]) >>> En este nuevo c\u00f3digo, \u00bfqu\u00e9 sucede si pasa un nombre de archivo como antes? >>> port = fileparse.parse_csv('Data/portfolio.csv', types=[str,int,float]) >>> port ... mire la salida (deber\u00eda estar algo alocada) ... >>> S\u00ed, debe tener cuidado. \u00bfPodr\u00eda agregar un control de seguridad para evitar esto?","title":"Ejercicio 3.17: De nombres de archivo a objetos similares a archivos"},{"location":"3/#ejercicio-318-arreglar-funciones-existentes","text":"Corrija las funciones read_portfolio() y read_prices() en el archivo report.py para que funcionen con la versi\u00f3n modificada de parse_csv() . Esto solo deber\u00eda implicar una peque\u00f1a modificaci\u00f3n. Posteriormente, sus programas report.py y pcost.py deber\u00edan funcionar de la misma manera que siempre.","title":"Ejercicio 3.18: Arreglar funciones existentes"},{"location":"4/","text":"4. Clases y Objetos Introduciremos el concepto de clases y objetos. Aprenderemos sobre la declaraci\u00f3n class que nos permite crear nuevos objetos. Tambi\u00e9n introcimos el concepto de inherencia, unaherramienta que es comunmente utilizada para construir programar extensibles. Finalmente, veremos otras caracter\u00edsticas de clases como los m\u00e9todos especiales, b\u00fasqueda dinamica de atributos, y la definici\u00f3n de nuevas excepciones. 4.1 Clases Esta secci\u00f3n presenta la declaraci\u00f3n de clase y la idea de crear nuevos objetos. 4.1.1 Programaci\u00f3n orientada a objetos (OO) Una t\u00e9cnica de programaci\u00f3n en la que el c\u00f3digo se organiza como una colecci\u00f3n de objetos . Un objeto consta de: Datos. Atributos Comportamiento. M\u00e9todos que son funciones aplicadas al objeto. Ya ha estado utilizando OO durante este curso. Por ejemplo, manipular una lista. >>> nums = [1, 2, 3] >>> nums.append(4) # Metodo >>> nums.insert(1,10) # Metodo >>> nums [1, 10, 2, 3, 4] # Data >>> nums es una instancia de una lista. Los m\u00e9todos ( append() e insert() ) se adjuntan a la instancia ( nums ). La declaraci\u00f3n class Utilice la declaraci\u00f3n class para definir un nuevo objeto. class Player: def __init__(self, x, y): self.x = x self.y = y self.health = 100 def move(self, dx, dy): self.x += dx self.y += dy def damage(self, pts): self.health -= pts En pocas palabras, una clase es un conjunto de funciones que realizan varias operaciones en las denominadas instancias . 4.1.2 Instancias Las instancias son los objetos reales que manipula en su programa. Se crean llamando a la clase como funci\u00f3n. >>> a = Player(2, 3) >>> b = Player(10, 20) >>> a y b son instancias de Player . Importante: La declaraci\u00f3n de clase es solo la definici\u00f3n (no hace nada por s\u00ed misma). Similar a la definici\u00f3n de una funci\u00f3n. 4.1.3 Datos de instancia Cada instancia tiene sus propios datos locales. >>> a.x 2 >>> b.x 10 Estos datos son inicializados por __init__() . class Player: def __init__(self, x, y): # Cualquier valor guardado en `self` es data de la instancia self.x = x self.y = y self.health = 100 No hay restricciones sobre el n\u00famero total o el tipo de atributos almacenados. 4.1.4 M\u00e9todos de instancia Los m\u00e9todos de instancia son funciones aplicadas a instancias de un objeto. class Player: ... # `move` es un metodo def move(self, dx, dy): self.x += dx self.y += dy El objeto en s\u00ed siempre se pasa como primer argumento. >>> a.move(1, 2) # empareja `a` a `self` # empareja `1` a `dx` # empareja `2` a `dy` def move(self, dx, dy): Por convenci\u00f3n, se llama la instancia self . Sin embargo, el nombre real utilizado no es importante. El objeto siempre se pasa como primer argumento. Es simplemente estilo de programaci\u00f3n Python para llamar a este argumento self . 4.1.5 Alcance de la clase Las clases no definen un \u00e1mbito / espacio de nombres. class Player: ... def move(self, dx, dy): self.x += dx self.y += dy def left(self, amt): move(-amt, 0) # NO. Llama funci\u00f3n global `move` self.move(-amt, 0) # SI. Llama metodo `move` de arriba. Si desea operar en una instancia, siempre se refiere a ella expl\u00edcitamente (por ejemplo, self ). 4.1.6 Ejercicios A partir de este conjunto de ejercicios, comenzamos a realizar una serie de cambios en el c\u00f3digo existente de las secciones anteriores. Es fundamental que tenga una versi\u00f3n funcional del ejercicio 3.18 para comenzar. Si no la tiene, trabaje con el c\u00f3digo de soluci\u00f3n que se encuentra en el directorio Solutions/3_18 . Est\u00e1 bien copiarlo. 4.1.7 Ejercicio 4.1: Objetos como estructuras de datos En la secci\u00f3n 2 y 3, trabajamos con datos representados como tuplas y diccionarios. Por ejemplo, una tenencia de acciones podr\u00eda representarse como una tupla como esta: s = ('GOOG',100,490.10) o como un diccionario como este: s = { 'name' : 'GOOG', 'shares' : 100, 'price' : 490.10 } Incluso puede escribir funciones para manipular dichos datos. Por ejemplo: def cost(s): return s['shares'] * s['price'] Sin embargo, a medida que su programa crece, es posible que desee crear un mejor sentido de organizaci\u00f3n. Por lo tanto, otro enfoque para representar datos ser\u00eda definir una clase. Cree un archivo llamado stock.py y defina una clase Stock que represente una sola tenencia de acciones. Las instancias de Stock deben tener los atributos de name , shares y price . Por ejemplo: >>> import stock >>> a = stock.Stock('GOOG',100,490.10) >>> a.name 'GOOG' >>> a.shares 100 >>> a.price 490.1 >>> Cree algunos objetos Stock m\u00e1s y manip\u00falelos. Por ejemplo: >>> b = stock.Stock('AAPL', 50, 122.34) >>> c = stock.Stock('IBM', 75, 91.75) >>> b.shares * b.price 6117.0 >>> c.shares * c.price 6881.25 >>> stocks = [a, b, c] >>> stocks [<stock.Stock object at 0x37d0b0>, <stock.Stock object at 0x37d110>, <stock.Stock object at 0x37d050>] >>> for s in stocks: print(f'{s.name:>10s} {s.shares:>10d} {s.price:>10.2f}') ... mire la salida ... >>> Una cosa a enfatizar aqu\u00ed es que la clase Stock act\u00faa como una f\u00e1brica para crear instancias de objetos. B\u00e1sicamente, la llamas como una funci\u00f3n y crea un nuevo objeto para ti. Adem\u00e1s, debe enfatizarse que cada objeto es distinto: cada uno tiene sus propios datos que est\u00e1n separados de otros objetos que se han creado. Un objeto definido por una clase es algo similar a un diccionario, solo que con una sintaxis algo diferente. Por ejemplo, en lugar de escribir s['name'] o s['price'] , ahora escribe s.name y s.price . Ejercicio 4.2: Adici\u00f3n de algunos m\u00e9todos Con las clases, puede adjuntar funciones a sus objetos. Estos se conocen como m\u00e9todos y son funciones que operan sobre los datos almacenados dentro de un objeto. Agregue un m\u00e9todo cost() y sell() a su objeto Stock . Deber\u00edan funcionar as\u00ed: >>> import stock >>> s = stock.Stock('GOOG', 100, 490.10) >>> s.cost() 49010.0 >>> s.shares 100 >>> s.sell(25) >>> s.shares 75 >>> s.cost() 36757.5 >>> Ejercicio 4.3: Creando una lista de instancias Pruebe estos pasos para hacer una lista de instancias de Stock a partir de una lista de diccionarios. Luego calcule el costo total: >>> import fileparse >>> with open('Data/portfolio.csv') as lines: ... portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float]) ... >>> portfolio = [ stock.Stock(d['name'], d['shares'], d['price']) for d in portdicts] >>> portfolio [<stock.Stock object at 0x10c9e2128>, <stock.Stock object at 0x10c9e2048>, <stock.Stock object at 0x10c9e2080>, <stock.Stock object at 0x10c9e25f8>, <stock.Stock object at 0x10c9e2630>, <stock.Stock object at 0x10ca6f748>, <stock.Stock object at 0x10ca6f7b8>] >>> sum([s.cost() for s in portfolio]) 44671.15 >>> Ejercicio 4.4: Usar tu clase Modifique la funci\u00f3n read_portfolio() en el programa report.py para que lea un portafolio en una lista de instancias Stock como se muestra en el ejercicio 4.3. Una vez que haya hecho eso, modifique todo el c\u00f3digo en report.py y pcost.py para que funcione con Stock casos en lugar de los diccionarios. Sugerencia: no deber\u00eda tener que realizar cambios importantes en el c\u00f3digo. Principalmente, cambiar\u00e1 el acceso al diccionario, como s['shares'] en s.shares . Deber\u00eda poder ejecutar sus funciones de la misma manera que antes: >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> 4.2 Herencia La herencia es una herramienta de uso com\u00fan para escribir programas extensibles. Esta secci\u00f3n explora esa idea. 4.2.1 Introducci\u00f3n La herencia se usa para especializar objetos existentes: class Parent: ... class Child(Parent): ... La nueva clase Child se denomina clase derivada o subclase. La clase Parent se conoce como clase base o superclase. Parent se especifica en () despu\u00e9s de que el nombre de la clase, class Child(Parent): . 4.2.2 Extensi\u00f3n Con la herencia, est\u00e1s tomando una clase existente y: Agregando nuevos m\u00e9todos Redefiniendo algunos de los m\u00e9todos existentes Agregando nuevos atributos a las instancias Al final, est\u00e1 ampliando el c\u00f3digo existente. 4.2.3 Ejemplo Suponga que esta es su clase inicial: class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price def cost(self): return self.shares * self.price def sell(self, nshares): self.shares -= nshares Puede cambiar cualquier parte de esto mediante herencia. 4.2.4 Agregando un nuevo m\u00e9todo class MyStock(Stock): def panic(self): self.sell(self.shares) Ejemplo de uso. >>> s = MyStock('GOOG', 100, 490.1) >>> s.sell(25) >>> s.shares 75 >>> s.panic() >>> s.shares 0 >>> 4.2.5 Redefiniendo un m\u00e9todo existente class MyStock(Stock): def cost(self): return 1.25 * self.shares * self.price Ejemplo de uso. >>> s = MyStock('GOOG', 100, 490.1) >>> s.cost() 61262.5 >>> El nuevo m\u00e9todo reemplaza al antiguo. Los otros m\u00e9todos no se ven afectados. 4.2.6 Comportamiento Primordial A veces, una clase extiende un m\u00e9todo existente, pero quiere usar la implementaci\u00f3n original dentro de la redefinici\u00f3n. Para esto, haga uso de super() : class Stock: ... def cost(self): return self.shares * self.price ... class MyStock(Stock): def cost(self): # haga la llamada a `super` actual_cost = super().cost() return 1.25 * actual_cost Haga uso de super() para llamar a la versi\u00f3n anterior. Precauci\u00f3n: en Python 2, la sintaxis era m\u00e1s detallada. actual_cost = super(MyStock, self).cost() 4.2.7 __init__ y herencia Si __init__ se redefine, es esencial inicializar la clase padre. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price class MyStock(Stock): def __init__(self, name, shares, price, factor): # revise el llamado a `super` y `__init__` super().__init__(name, shares, price) self.factor = factor def cost(self): return self.factor * super().cost() Debe llamar el m\u00e9todo __init__() en super cu\u00e1l es la forma de llamar a la versi\u00f3n anterior como se mostr\u00f3 anteriormente. 4.2.8 Usando la herencia La herencia se usa a veces para organizar objetos relacionados. class Shape: ... class Circle(Shape): ... class Rectangle(Shape): ... Piense en una jerarqu\u00eda l\u00f3gica o taxonom\u00eda. Sin embargo, un uso m\u00e1s com\u00fan (y pr\u00e1ctico) est\u00e1 relacionado con hacer c\u00f3digo reutilizable o extensible. Por ejemplo, un marco puede definir una clase base e indicarle que la personalice. class CustomHandler(TCPHandler): def handle_request(self): ... # Custom processing La clase base contiene alg\u00fan c\u00f3digo de prop\u00f3sito general. Tu clase hereda y personaliza partes espec\u00edficas. 4.2.9 Relaci\u00f3n \"es un\" La herencia establece una relaci\u00f3n de tipo. class Shape: ... class Circle(Shape): ... Compruebe la instancia del objeto. >>> c = Circle(4.0) >>> isinstance(c, Shape) True >>> Importante: lo ideal es que cualquier c\u00f3digo que funcione con instancias de la clase principal tambi\u00e9n funcionar\u00e1 con instancias de la clase secundaria. 4.2.10 clase base object Si una clase no tiene padre, a veces se usa object como base. class Shape(object): ... object es la ra\u00edz de todos los objetos en Python. Nota: no es t\u00e9cnicamente necesario, pero a menudo se lo ve especificado como una retenci\u00f3n de su uso obligatorio en Python 2. Si se omite, la clase a\u00fan hereda impl\u00edcitamente object . 4.2.11 Herencia m\u00faltiple Puede heredar de varias clases especific\u00e1ndolas en la definici\u00f3n de la clase. class Mother: ... class Father: ... class Child(Mother, Father): ... La clase Child hereda caracter\u00edsticas de ambos padres. Hay algunos detalles bastante complicados. No lo haga a menos que sepa lo que est\u00e1 haciendo. Se proporcionar\u00e1 m\u00e1s informaci\u00f3n en la siguiente secci\u00f3n, pero no vamos a utilizar m\u00e1s la herencia m\u00faltiple en este curso. 4.2.12 Ejercicios Un uso importante de la herencia es la escritura de c\u00f3digo que debe ampliarse o personalizarse de diversas formas, especialmente en bibliotecas o marcos de trabajo (frameworks). Para ilustrarlo, considere la print_report() funci\u00f3n en su programa report.py . Deber\u00eda verse algo como esto: def print_report(reportdata): ''' Print a nicely formated table from a list of (name, shares, price, change) tuples. ''' headers = ('Name','Shares','Price','Change') print('%10s %10s %10s %10s' % headers) print(('-'*10 + ' ')*len(headers)) for row in reportdata: print('%10s %10d %10.2f %10.2f' % row) Cuando ejecuta su programa de informes, deber\u00eda obtener un resultado como este: >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 Ejercicio 4.5: un problema de extensibilidad Suponga que desea modificar la funci\u00f3n print_report() para admitir una variedad de formatos de salida diferentes, como texto sin formato, HTML, CSV o XML. Para hacer esto, podr\u00eda intentar escribir una funci\u00f3n gigantesca que lo hiciera todo. Sin embargo, hacerlo probablemente conducir\u00eda a un desorden insostenible. En cambio, esta es una oportunidad perfecta para usar la herencia. Para comenzar, conc\u00e9ntrese en los pasos involucrados en la creaci\u00f3n de una tabla. En la parte superior de la tabla hay un conjunto de encabezados de tabla. Despu\u00e9s de eso, aparecen filas de datos de la tabla. Tomemos esos pasos y pong\u00e1moslos en su propia clase. Cree un archivo llamado tableformat.py y defina la siguiente clase: # tableformat.py class TableFormatter: def headings(self, headers): ''' Emite el encabezado de la tabla ''' raise NotImplementedError() def row(self, rowdata): ''' Emite una fila de data de tabla. ''' raise NotImplementedError() Esta clase no hace nada, pero sirve como una especie de especificaci\u00f3n de dise\u00f1o para clases adicionales que se definir\u00e1n en breve. Una clase como esta a veces se denomina \"clase base abstracta\". Modifique la funci\u00f3n print_report() para que acepte un objeto TableFormatter como entrada e invoque m\u00e9todos en \u00e9l para producir la salida. Por ejemplo, as\u00ed: # report.py ... def print_report(reportdata, formatter): ''' Imprima una tabla con un formato agradable a partir de una lista de tuplas (nombre, acciones, precio, cambio). ''' formatter.headings(['Name','Shares','Price','Change']) for name, shares, price, change in reportdata: rowdata = [ name, str(shares), f'{price:0.2f}', f'{change:0.2f}' ] formatter.row(rowdata) Toda vez que agreg\u00f3 un argumento a print_report() , tambi\u00e9n necesitar\u00e1 modificar la portfolio_report()funci\u00f3n. C\u00e1mbielo para que cree un aspecto TableFormatter como este: # report.py import tableformat ... def portfolio_report(portfoliofile, pricefile): ''' Make a stock report given portfolio and price data files. ''' # Read data files portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Create the report data report = make_report_data(portfolio, prices) # Print it out formatter = tableformat.TableFormatter() print_report(report, formatter) Ejecute este nuevo c\u00f3digo: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') ... el programa se bloquea ... Deber\u00eda bloquearse inmediatamente con una excepci\u00f3n NotImplementedError . Eso no es demasiado emocionante, pero es exactamente lo que esper\u00e1bamos. Contin\u00fae con la siguiente parte. Ejercicio 4.6: Uso de la herencia para producir resultados diferentes La clase TableFormatter que defini\u00f3 en la parte (a) est\u00e1 destinada a ampliarse mediante herencia. De hecho, esa es toda la idea. Para ilustrar, defina una clase TextTableFormatter como esta: # tableformat.py ... class TextTableFormatter(TableFormatter): ''' Emite una tabla de texto sin formato ''' def headings(self, headers): for h in headers: print(f'{h:>10s}', end=' ') print() print(('-'*10 + ' ')*len(headers)) def row(self, rowdata): for d in rowdata: print(f'{d:>10s}', end=' ') print() Modifique la funci\u00f3n portfolio_report() as\u00ed y pru\u00e9bela: # report.py ... def portfolio_report(portfoliofile, pricefile): ''' Hace un informe de acciones en funci\u00f3n de los archivos de datos de precios y cartera. ''' # Lee los archivos de data portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crea el reporte de data report = make_report_data(portfolio, prices) # Lo imprime formatter = tableformat.TextTableFormatter() print_report(report, formatter) Esto deber\u00eda producir el mismo resultado que antes: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Sin embargo, cambiemos la salida a otra cosa. Defina una nueva clase CSVTableFormatter que produzca resultados en formato CSV: # tableformat.py ... class CSVTableFormatter(TableFormatter): ''' Output de data de portfolio en formato CSV. ''' def headings(self, headers): print(','.join(headers)) def row(self, rowdata): print(','.join(rowdata)) Modifique su programa principal de la siguiente manera: def portfolio_report(portfoliofile, pricefile): ''' Hace un informe de acciones en funci\u00f3n de los archivos de datos de precios y cartera. ''' portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) report = make_report_data(portfolio, prices) formatter = tableformat.CSVTableFormatter() print_report(report, formatter) Ahora deber\u00eda ver una salida CSV como esta: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name,Shares,Price,Change AA,100,9.22,-22.98 IBM,50,106.28,15.18 CAT,150,35.46,-47.98 MSFT,200,20.89,-30.34 GE,95,13.48,-26.89 MSFT,50,20.89,-44.21 IBM,100,106.28,35.84 Con una idea similar, defina una clase HTMLTableFormatter que produzca una tabla con el siguiente resultado: <tr><th>Name</th><th>Shares</th><th>Price</th><th>Change</th></tr> <tr><td>AA</td><td>100</td><td>9.22</td><td>-22.98</td></tr> <tr><td>IBM</td><td>50</td><td>106.28</td><td>15.18</td></tr> <tr><td>CAT</td><td>150</td><td>35.46</td><td>-47.98</td></tr> <tr><td>MSFT</td><td>200</td><td>20.89</td><td>-30.34</td></tr> <tr><td>GE</td><td>95</td><td>13.48</td><td>-26.89</td></tr> <tr><td>MSFT</td><td>50</td><td>20.89</td><td>-44.21</td></tr> <tr><td>IBM</td><td>100</td><td>106.28</td><td>35.84</td></tr> Pruebe su c\u00f3digo modificando el programa principal para crear un objeto HTMLTableFormatter en lugar de un objeto CSVTableFormatter . Ejercicio 4.7: Polimorfismo en acci\u00f3n Una caracter\u00edstica importante de la programaci\u00f3n orientada a objetos es que puede conectar un objeto a un programa y funcionar\u00e1 sin tener que cambiar el c\u00f3digo existente. Por ejemplo, si escribiera un programa que esperaba usar un objeto TableFormatter , funcionar\u00eda sin importar qu\u00e9 tipo de TableFormatter le haya dado. Este comportamiento a veces se denomina \"polimorfismo\". Un problema potencial es averiguar c\u00f3mo permitir que un usuario elija el formateador que desee. El uso directo de los nombres de las clases TextTableFormatter es a menudo molesto. Por lo tanto, podr\u00eda considerar alg\u00fan enfoque simplificado. Quiz\u00e1s incruste una declaraci\u00f3n-if en el c\u00f3digo como esta: def portfolio_report(portfoliofile, pricefile, fmt='txt'): ''' Hace un informe de acciones en funci\u00f3n de los archivos de datos de precios y cartera. ''' # Lea los archivos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crea el reporte report = make_report_data(portfolio, prices) # Lo imprime if fmt == 'txt': formatter = tableformat.TextTableFormatter() elif fmt == 'csv': formatter = tableformat.CSVTableFormatter() elif fmt == 'html': formatter = tableformat.HTMLTableFormatter() else: raise RuntimeError(f'Unknown format {fmt}') print_report(report, formatter) En este c\u00f3digo, el usuario especifica un nombre simplificado como 'txt'o 'csv' para elegir un formato. Sin embargo, \u00bfes la mejor idea poner una enorme declaraci\u00f3n if en la funci\u00f3n portfolio_report() ? Podr\u00eda ser mejor mover ese c\u00f3digo a una funci\u00f3n de prop\u00f3sito general en otro lugar. En el archivo tableformat.py , agregar una funci\u00f3n create_formatter(name) que permite a un usuario crear un formateador dado un nombre de salida como 'txt', 'csv'o 'html'. Modifique portfolio_report() para que se vea as\u00ed: def portfolio_report(portfoliofile, pricefile, fmt='txt'): ''' Hace un informe de acciones en funci\u00f3n de los archivos de datos de precios y cartera. ''' # Lea los archivos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crea el reporte report = make_report_data(portfolio, prices) # Lo imprime formatter = tableformat.create_formatter(fmt) print_report(report, formatter) Intente llamar a la funci\u00f3n con diferentes formatos para asegurarse de que est\u00e9 funcionando. Ejercicio 4.8: Poniendo todo junto Modifique el programa report.py para que la funci\u00f3n portfolio_report() tome un argumento opcional que especifique el formato de salida. Por ejemplo: >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv', 'txt') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Modifique el programa principal para que se pueda dar un formato en la l\u00ednea de comando: $ python report.py Data/portfolio.csv Data/prices.csv csv Name,Shares,Price,Change AA,100,9.22,-22.98 IBM,50,106.28,15.18 CAT,150,35.46,-47.98 MSFT,200,20.89,-30.34 GE,95,13.48,-26.89 MSFT,50,20.89,-44.21 IBM,100,106.28,35.84 bash $ Discusi\u00f3n Escribir c\u00f3digo extensible es uno de los usos m\u00e1s comunes de la herencia en bibliotecas y marcos de desarrollo. Por ejemplo, un marco puede indicarle que defina su propio objeto que hereda de una clase base proporcionada. Luego se le indica que complete varios m\u00e9todos que implementan varios bits de funcionalidad. Otro concepto algo m\u00e1s profundo es la idea de \"ser due\u00f1o de sus abstracciones\". En los ejercicios, definimos nuestra propia clase para formatear una tabla. Puede mirar su c\u00f3digo y decirse a s\u00ed mismo: \"\u00a1Deber\u00eda usar una biblioteca de formato o algo que ya haya creado otra persona!\" No, debe usar AMBOS su clase y una biblioteca. El uso de su propia clase promueve un acoplamiento flexible y es m\u00e1s flexible. Siempre que su aplicaci\u00f3n utilice la interfaz de programaci\u00f3n de su clase, puede cambiar la implementaci\u00f3n interna para que funcione de la forma que desee. Puede escribir c\u00f3digo totalmente personalizado. Puede utilizar el paquete de terceros de alguien. Cambie un paquete de terceros por un paquete diferente cuando encuentre uno mejor. No importa, ninguno de los c\u00f3digos de su aplicaci\u00f3n se romper\u00e1 mientras conserve la interfaz. Esa es una idea poderosa y es una de las razones por las que podr\u00eda considerar la herencia para algo como esto. Dicho esto, dise\u00f1ar programas orientados a objetos puede ser extremadamente dif\u00edcil. Para obtener m\u00e1s informaci\u00f3n, probablemente deber\u00eda buscar libros sobre el tema de los patrones de dise\u00f1o (aunque comprender lo que sucedi\u00f3 en este ejercicio lo llevar\u00e1 bastante lejos en t\u00e9rminos de usar objetos de una manera pr\u00e1ctica e \u00fatil). 4.3 M\u00e9todos especiales Varias partes del comportamiento de Python se pueden personalizar a trav\u00e9s de m\u00e9todos especiales o llamados \"m\u00e1gicos\". Esta secci\u00f3n presenta esa idea. Adem\u00e1s, se analizan el acceso a atributos din\u00e1micos y los m\u00e9todos vinculados. 4.3.1 Introducci\u00f3n Las clases pueden definir m\u00e9todos especiales. Estos tienen un significado especial para el int\u00e9rprete de Python. Siempre van precedidos y seguidos de __ . Por ejemplo __init__ . class Stock(object): def __init__(self): ... def __repr__(self): ... Hay docenas de m\u00e9todos especiales, pero solo veremos algunos ejemplos espec\u00edficos. 4.3.2 M\u00e9todos especiales para conversiones de cadenas Los objetos tienen dos representaciones de cadenas. >>> from datetime import date >>> d = date(2012, 12, 21) >>> print(d) 2012-12-21 >>> d datetime.date(2012, 12, 21) >>> La funci\u00f3n str() se usa para crear una buena salida imprimible: >>> str(d) '2012-12-21' >>> La funci\u00f3n repr() se utiliza para crear una representaci\u00f3n m\u00e1s detallada para los programadores. >>> repr(d) 'datetime.date(2012, 12, 21)' >>> Esas funciones str() y repr() usan un par de m\u00e9todos especiales en la clase para producir la cadena que se mostrar\u00e1. class Date(object): def __init__(self, year, month, day): self.year = year self.month = month self.day = day # Utilicelo con `str()` def __str__(self): return f'{self.year}-{self.month}-{self.day}' # Utilicelo con `repr()` def __repr__(self): return f'Date({self.year},{self.month},{self.day})' Nota: La convenci\u00f3n para repr ()es devolver una cadena que, cuando se alimenta eval(), recrear\u00e1 el objeto subyacente. Si esto no es posible, se utiliza en su lugar alg\u00fan tipo de representaci\u00f3n f\u00e1cilmente legible. 4.3.3 M\u00e9todos especiales para matem\u00e1ticas Los operadores matem\u00e1ticos implican llamadas a los siguientes m\u00e9todos. a + b a.__add__(b) a - b a.__sub__(b) a * b a.__mul__(b) a / b a.__truediv__(b) a // b a.__floordiv__(b) a % b a.__mod__(b) a << b a.__lshift__(b) a >> b a.__rshift__(b) a & b a.__and__(b) a | b a.__or__(b) a ^ b a.__xor__(b) a ** b a.__pow__(b) -a a.__neg__() ~a a.__invert__() abs(a) a.__abs__() 4.3.4 M\u00e9todos especiales para acceder a los elementos Estos son los m\u00e9todos para implementar contenedores. len(x) x.__len__() x[a] x.__getitem__(a) x[a] = v x.__setitem__(a,v) del x[a] x.__delitem__(a) Puedes usarlos en tus clases. class Sequence: def __len__(self): ... def __getitem__(self,a): ... def __setitem__(self,a,v): ... def __delitem__(self,a): ... 4.3.5 Invocaci\u00f3n de m\u00e9todo Invocar un m\u00e9todo es un proceso de dos pasos. B\u00fasqueda: el .operador Llamada de m\u00e9todo: el operador () >>> s = Stock('GOOG',100,490.10) >>> c = s.cost # Lookup >>> c <bound method Stock.cost of <Stock object at 0x590d0>> >>> c() # Method call 49010.0 >>> 4.3.6 M\u00e9todos vinculados Un m\u00e9todo que a\u00fan no ha sido invocado por el operador de llamada de funci\u00f3n () se conoce como m\u00e9todo vinculado. Opera en la instancia donde se origin\u00f3. >>> s = Stock('GOOG', 100, 490.10) >>> s <Stock object at 0x590d0> >>> c = s.cost >>> c <bound method Stock.cost of <Stock object at 0x590d0>> >>> c() 49010.0 >>> Los m\u00e9todos vinculados son a menudo una fuente de errores no evidentes por descuido. Por ejemplo: >>> s = Stock('GOOG', 100, 490.10) >>> print('Cost : %0.2f' % s.cost) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: float argument required >>> O comportamiento tortuoso que es dif\u00edcil de depurar. f = open(filename, 'w') ... f.close # Oops. `f` todav\u00eda abierto. En ambos casos, el error se debe a que se olvid\u00f3 de incluir los par\u00e9ntesis finales. Por ejemplo, s.cost() o f.close() . 4.3.7 Acceso a atributos Existe una forma alternativa de acceder, manipular y gestionar atributos. getattr(obj, 'name') # Igual a obj.name setattr(obj, 'name', value) # Igual a obj.name = value delattr(obj, 'name') # Igual a del obj.name hasattr(obj, 'name') # Comprueba si el atributo existe Ejemplo: if hasattr(obj, 'x'): x = getattr(obj, 'x'): else: x = None Nota: getattr() tambi\u00e9n tiene un valor predeterminado \u00fatil *arg . x = getattr(obj, 'x', None) 4.3.8 Ejercicios Ejercicio 4.9: Mejor resultado para imprimir objetos Modifique el objeto Stock que defini\u00f3 stock.py para que el m\u00e9todo __repr__() produzca una salida m\u00e1s \u00fatil. Por ejemplo: >>> goog = Stock('GOOG', 100, 490.1) >>> goog Stock('GOOG', 100, 490.1) >>> Vea lo que sucede cuando lee una cartera de acciones y vea la lista resultante despu\u00e9s de haber realizado estos cambios. Por ejemplo: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> portfolio ... see what the output is ... >>> Ejercicio 4.10: un ejemplo de uso de getattr() getattr() es un mecanismo alternativo para leer atributos. Se puede usar para escribir c\u00f3digo extremadamente flexible. Para empezar, prueba este ejemplo: >>> import stock >>> s = stock.Stock('GOOG', 100, 490.1) >>> columns = ['name', 'shares'] >>> for colname in columns: print(colname, '=', getattr(s, colname)) name = GOOG shares = 100 >>> Observe con atenci\u00f3n que los datos de salida est\u00e1n determinados por completo por los nombres de los atributos enumerados en la variable columns . En el archivo tableformat.py , tome esta idea y ampl\u00edela en una funci\u00f3n generalizada print_table()que imprima una tabla que muestra los atributos especificados por el usuario de una lista de objetos arbitrarios. Al igual que con la funci\u00f3n print_report() anterior, print_table() tambi\u00e9n deber\u00eda aceptar una instancia de TableFormatter para controlar el formato de salida. As\u00ed es como deber\u00eda funcionar: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> from tableformat import create_formatter, print_table >>> formatter = create_formatter('txt') >>> print_table(portfolio, ['name','shares'], formatter) name shares ---------- ---------- AA 100 IBM 50 CAT 150 MSFT 200 GE 95 MSFT 50 IBM 100 >>> print_table(portfolio, ['name','shares','price'], formatter) name shares price ---------- ---------- ---------- AA 100 32.2 IBM 50 91.1 CAT 150 83.44 MSFT 200 51.23 GE 95 40.37 MSFT 50 65.1 IBM 100 70.44 >>> 4.4 Definici\u00f3n de excepciones Las excepciones definidas por el usuario se definen por clases. class NetworkError(Exception): pass Las excepciones siempre heredan de Exception . Usualmente suelen ser clases vac\u00edas. Haga uso de pass para el cuerpo. Tambi\u00e9n puede hacer una jerarqu\u00eda de sus excepciones. class AuthenticationError(NetworkError): pass class ProtocolError(NetworkError): pass 4.4.1. Ejercicios Ejercicio 4.11: Definici\u00f3n de una excepci\u00f3n personalizada A menudo, es una buena pr\u00e1ctica que las bibliotecas definan sus propias excepciones. Esto hace que sea m\u00e1s f\u00e1cil distinguir entre las excepciones de Python generadas en respuesta a errores de programaci\u00f3n comunes frente a las excepciones generadas intencionalmente por una biblioteca para se\u00f1alar un problema de uso espec\u00edfico. Modifique la funci\u00f3n create_formatter() del \u00faltimo ejercicio para que genere una excepci\u00f3n FormatError personalizada cuando el usuario proporcione un nombre de formato incorrecto. Por ejemplo: >>> from tableformat import create_formatter >>> formatter = create_formatter('xls') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"tableformat.py\", line 71, in create_formatter raise FormatError('Unknown table format %s' % name) FormatError: Unknown table format xls >>>","title":"4 Clases y Objetos"},{"location":"4/#4-clases-y-objetos","text":"Introduciremos el concepto de clases y objetos. Aprenderemos sobre la declaraci\u00f3n class que nos permite crear nuevos objetos. Tambi\u00e9n introcimos el concepto de inherencia, unaherramienta que es comunmente utilizada para construir programar extensibles. Finalmente, veremos otras caracter\u00edsticas de clases como los m\u00e9todos especiales, b\u00fasqueda dinamica de atributos, y la definici\u00f3n de nuevas excepciones.","title":"4. Clases y Objetos"},{"location":"4/#41-clases","text":"Esta secci\u00f3n presenta la declaraci\u00f3n de clase y la idea de crear nuevos objetos.","title":"4.1 Clases"},{"location":"4/#411-programacion-orientada-a-objetos-oo","text":"Una t\u00e9cnica de programaci\u00f3n en la que el c\u00f3digo se organiza como una colecci\u00f3n de objetos . Un objeto consta de: Datos. Atributos Comportamiento. M\u00e9todos que son funciones aplicadas al objeto. Ya ha estado utilizando OO durante este curso. Por ejemplo, manipular una lista. >>> nums = [1, 2, 3] >>> nums.append(4) # Metodo >>> nums.insert(1,10) # Metodo >>> nums [1, 10, 2, 3, 4] # Data >>> nums es una instancia de una lista. Los m\u00e9todos ( append() e insert() ) se adjuntan a la instancia ( nums ). La declaraci\u00f3n class Utilice la declaraci\u00f3n class para definir un nuevo objeto. class Player: def __init__(self, x, y): self.x = x self.y = y self.health = 100 def move(self, dx, dy): self.x += dx self.y += dy def damage(self, pts): self.health -= pts En pocas palabras, una clase es un conjunto de funciones que realizan varias operaciones en las denominadas instancias .","title":"4.1.1 Programaci\u00f3n orientada a objetos (OO)"},{"location":"4/#412-instancias","text":"Las instancias son los objetos reales que manipula en su programa. Se crean llamando a la clase como funci\u00f3n. >>> a = Player(2, 3) >>> b = Player(10, 20) >>> a y b son instancias de Player . Importante: La declaraci\u00f3n de clase es solo la definici\u00f3n (no hace nada por s\u00ed misma). Similar a la definici\u00f3n de una funci\u00f3n.","title":"4.1.2 Instancias"},{"location":"4/#413-datos-de-instancia","text":"Cada instancia tiene sus propios datos locales. >>> a.x 2 >>> b.x 10 Estos datos son inicializados por __init__() . class Player: def __init__(self, x, y): # Cualquier valor guardado en `self` es data de la instancia self.x = x self.y = y self.health = 100 No hay restricciones sobre el n\u00famero total o el tipo de atributos almacenados.","title":"4.1.3 Datos de instancia"},{"location":"4/#414-metodos-de-instancia","text":"Los m\u00e9todos de instancia son funciones aplicadas a instancias de un objeto. class Player: ... # `move` es un metodo def move(self, dx, dy): self.x += dx self.y += dy El objeto en s\u00ed siempre se pasa como primer argumento. >>> a.move(1, 2) # empareja `a` a `self` # empareja `1` a `dx` # empareja `2` a `dy` def move(self, dx, dy): Por convenci\u00f3n, se llama la instancia self . Sin embargo, el nombre real utilizado no es importante. El objeto siempre se pasa como primer argumento. Es simplemente estilo de programaci\u00f3n Python para llamar a este argumento self .","title":"4.1.4 M\u00e9todos de instancia"},{"location":"4/#415-alcance-de-la-clase","text":"Las clases no definen un \u00e1mbito / espacio de nombres. class Player: ... def move(self, dx, dy): self.x += dx self.y += dy def left(self, amt): move(-amt, 0) # NO. Llama funci\u00f3n global `move` self.move(-amt, 0) # SI. Llama metodo `move` de arriba. Si desea operar en una instancia, siempre se refiere a ella expl\u00edcitamente (por ejemplo, self ).","title":"4.1.5 Alcance de la clase"},{"location":"4/#416-ejercicios","text":"A partir de este conjunto de ejercicios, comenzamos a realizar una serie de cambios en el c\u00f3digo existente de las secciones anteriores. Es fundamental que tenga una versi\u00f3n funcional del ejercicio 3.18 para comenzar. Si no la tiene, trabaje con el c\u00f3digo de soluci\u00f3n que se encuentra en el directorio Solutions/3_18 . Est\u00e1 bien copiarlo.","title":"4.1.6 Ejercicios"},{"location":"4/#417-ejercicio-41-objetos-como-estructuras-de-datos","text":"En la secci\u00f3n 2 y 3, trabajamos con datos representados como tuplas y diccionarios. Por ejemplo, una tenencia de acciones podr\u00eda representarse como una tupla como esta: s = ('GOOG',100,490.10) o como un diccionario como este: s = { 'name' : 'GOOG', 'shares' : 100, 'price' : 490.10 } Incluso puede escribir funciones para manipular dichos datos. Por ejemplo: def cost(s): return s['shares'] * s['price'] Sin embargo, a medida que su programa crece, es posible que desee crear un mejor sentido de organizaci\u00f3n. Por lo tanto, otro enfoque para representar datos ser\u00eda definir una clase. Cree un archivo llamado stock.py y defina una clase Stock que represente una sola tenencia de acciones. Las instancias de Stock deben tener los atributos de name , shares y price . Por ejemplo: >>> import stock >>> a = stock.Stock('GOOG',100,490.10) >>> a.name 'GOOG' >>> a.shares 100 >>> a.price 490.1 >>> Cree algunos objetos Stock m\u00e1s y manip\u00falelos. Por ejemplo: >>> b = stock.Stock('AAPL', 50, 122.34) >>> c = stock.Stock('IBM', 75, 91.75) >>> b.shares * b.price 6117.0 >>> c.shares * c.price 6881.25 >>> stocks = [a, b, c] >>> stocks [<stock.Stock object at 0x37d0b0>, <stock.Stock object at 0x37d110>, <stock.Stock object at 0x37d050>] >>> for s in stocks: print(f'{s.name:>10s} {s.shares:>10d} {s.price:>10.2f}') ... mire la salida ... >>> Una cosa a enfatizar aqu\u00ed es que la clase Stock act\u00faa como una f\u00e1brica para crear instancias de objetos. B\u00e1sicamente, la llamas como una funci\u00f3n y crea un nuevo objeto para ti. Adem\u00e1s, debe enfatizarse que cada objeto es distinto: cada uno tiene sus propios datos que est\u00e1n separados de otros objetos que se han creado. Un objeto definido por una clase es algo similar a un diccionario, solo que con una sintaxis algo diferente. Por ejemplo, en lugar de escribir s['name'] o s['price'] , ahora escribe s.name y s.price .","title":"4.1.7 Ejercicio 4.1: Objetos como estructuras de datos"},{"location":"4/#ejercicio-42-adicion-de-algunos-metodos","text":"Con las clases, puede adjuntar funciones a sus objetos. Estos se conocen como m\u00e9todos y son funciones que operan sobre los datos almacenados dentro de un objeto. Agregue un m\u00e9todo cost() y sell() a su objeto Stock . Deber\u00edan funcionar as\u00ed: >>> import stock >>> s = stock.Stock('GOOG', 100, 490.10) >>> s.cost() 49010.0 >>> s.shares 100 >>> s.sell(25) >>> s.shares 75 >>> s.cost() 36757.5 >>>","title":"Ejercicio 4.2: Adici\u00f3n de algunos m\u00e9todos"},{"location":"4/#ejercicio-43-creando-una-lista-de-instancias","text":"Pruebe estos pasos para hacer una lista de instancias de Stock a partir de una lista de diccionarios. Luego calcule el costo total: >>> import fileparse >>> with open('Data/portfolio.csv') as lines: ... portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float]) ... >>> portfolio = [ stock.Stock(d['name'], d['shares'], d['price']) for d in portdicts] >>> portfolio [<stock.Stock object at 0x10c9e2128>, <stock.Stock object at 0x10c9e2048>, <stock.Stock object at 0x10c9e2080>, <stock.Stock object at 0x10c9e25f8>, <stock.Stock object at 0x10c9e2630>, <stock.Stock object at 0x10ca6f748>, <stock.Stock object at 0x10ca6f7b8>] >>> sum([s.cost() for s in portfolio]) 44671.15 >>>","title":"Ejercicio 4.3: Creando una lista de instancias"},{"location":"4/#ejercicio-44-usar-tu-clase","text":"Modifique la funci\u00f3n read_portfolio() en el programa report.py para que lea un portafolio en una lista de instancias Stock como se muestra en el ejercicio 4.3. Una vez que haya hecho eso, modifique todo el c\u00f3digo en report.py y pcost.py para que funcione con Stock casos en lugar de los diccionarios. Sugerencia: no deber\u00eda tener que realizar cambios importantes en el c\u00f3digo. Principalmente, cambiar\u00e1 el acceso al diccionario, como s['shares'] en s.shares . Deber\u00eda poder ejecutar sus funciones de la misma manera que antes: >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>>","title":"Ejercicio 4.4: Usar tu clase"},{"location":"4/#42-herencia","text":"La herencia es una herramienta de uso com\u00fan para escribir programas extensibles. Esta secci\u00f3n explora esa idea.","title":"4.2 Herencia"},{"location":"4/#421-introduccion","text":"La herencia se usa para especializar objetos existentes: class Parent: ... class Child(Parent): ... La nueva clase Child se denomina clase derivada o subclase. La clase Parent se conoce como clase base o superclase. Parent se especifica en () despu\u00e9s de que el nombre de la clase, class Child(Parent): .","title":"4.2.1 Introducci\u00f3n"},{"location":"4/#422-extension","text":"Con la herencia, est\u00e1s tomando una clase existente y: Agregando nuevos m\u00e9todos Redefiniendo algunos de los m\u00e9todos existentes Agregando nuevos atributos a las instancias Al final, est\u00e1 ampliando el c\u00f3digo existente.","title":"4.2.2 Extensi\u00f3n"},{"location":"4/#423-ejemplo","text":"Suponga que esta es su clase inicial: class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price def cost(self): return self.shares * self.price def sell(self, nshares): self.shares -= nshares Puede cambiar cualquier parte de esto mediante herencia.","title":"4.2.3 Ejemplo"},{"location":"4/#424-agregando-un-nuevo-metodo","text":"class MyStock(Stock): def panic(self): self.sell(self.shares) Ejemplo de uso. >>> s = MyStock('GOOG', 100, 490.1) >>> s.sell(25) >>> s.shares 75 >>> s.panic() >>> s.shares 0 >>>","title":"4.2.4 Agregando un nuevo m\u00e9todo"},{"location":"4/#425-redefiniendo-un-metodo-existente","text":"class MyStock(Stock): def cost(self): return 1.25 * self.shares * self.price Ejemplo de uso. >>> s = MyStock('GOOG', 100, 490.1) >>> s.cost() 61262.5 >>> El nuevo m\u00e9todo reemplaza al antiguo. Los otros m\u00e9todos no se ven afectados.","title":"4.2.5 Redefiniendo un m\u00e9todo existente"},{"location":"4/#426-comportamiento-primordial","text":"A veces, una clase extiende un m\u00e9todo existente, pero quiere usar la implementaci\u00f3n original dentro de la redefinici\u00f3n. Para esto, haga uso de super() : class Stock: ... def cost(self): return self.shares * self.price ... class MyStock(Stock): def cost(self): # haga la llamada a `super` actual_cost = super().cost() return 1.25 * actual_cost Haga uso de super() para llamar a la versi\u00f3n anterior. Precauci\u00f3n: en Python 2, la sintaxis era m\u00e1s detallada. actual_cost = super(MyStock, self).cost()","title":"4.2.6 Comportamiento Primordial"},{"location":"4/#427-__init__-y-herencia","text":"Si __init__ se redefine, es esencial inicializar la clase padre. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price class MyStock(Stock): def __init__(self, name, shares, price, factor): # revise el llamado a `super` y `__init__` super().__init__(name, shares, price) self.factor = factor def cost(self): return self.factor * super().cost() Debe llamar el m\u00e9todo __init__() en super cu\u00e1l es la forma de llamar a la versi\u00f3n anterior como se mostr\u00f3 anteriormente.","title":"4.2.7 __init__ y herencia"},{"location":"4/#428-usando-la-herencia","text":"La herencia se usa a veces para organizar objetos relacionados. class Shape: ... class Circle(Shape): ... class Rectangle(Shape): ... Piense en una jerarqu\u00eda l\u00f3gica o taxonom\u00eda. Sin embargo, un uso m\u00e1s com\u00fan (y pr\u00e1ctico) est\u00e1 relacionado con hacer c\u00f3digo reutilizable o extensible. Por ejemplo, un marco puede definir una clase base e indicarle que la personalice. class CustomHandler(TCPHandler): def handle_request(self): ... # Custom processing La clase base contiene alg\u00fan c\u00f3digo de prop\u00f3sito general. Tu clase hereda y personaliza partes espec\u00edficas.","title":"4.2.8 Usando la herencia"},{"location":"4/#429-relacion-es-un","text":"La herencia establece una relaci\u00f3n de tipo. class Shape: ... class Circle(Shape): ... Compruebe la instancia del objeto. >>> c = Circle(4.0) >>> isinstance(c, Shape) True >>> Importante: lo ideal es que cualquier c\u00f3digo que funcione con instancias de la clase principal tambi\u00e9n funcionar\u00e1 con instancias de la clase secundaria.","title":"4.2.9 Relaci\u00f3n \"es un\""},{"location":"4/#4210-clase-base-object","text":"Si una clase no tiene padre, a veces se usa object como base. class Shape(object): ... object es la ra\u00edz de todos los objetos en Python. Nota: no es t\u00e9cnicamente necesario, pero a menudo se lo ve especificado como una retenci\u00f3n de su uso obligatorio en Python 2. Si se omite, la clase a\u00fan hereda impl\u00edcitamente object .","title":"4.2.10 clase base object"},{"location":"4/#4211-herencia-multiple","text":"Puede heredar de varias clases especific\u00e1ndolas en la definici\u00f3n de la clase. class Mother: ... class Father: ... class Child(Mother, Father): ... La clase Child hereda caracter\u00edsticas de ambos padres. Hay algunos detalles bastante complicados. No lo haga a menos que sepa lo que est\u00e1 haciendo. Se proporcionar\u00e1 m\u00e1s informaci\u00f3n en la siguiente secci\u00f3n, pero no vamos a utilizar m\u00e1s la herencia m\u00faltiple en este curso.","title":"4.2.11 Herencia m\u00faltiple"},{"location":"4/#4212-ejercicios","text":"Un uso importante de la herencia es la escritura de c\u00f3digo que debe ampliarse o personalizarse de diversas formas, especialmente en bibliotecas o marcos de trabajo (frameworks). Para ilustrarlo, considere la print_report() funci\u00f3n en su programa report.py . Deber\u00eda verse algo como esto: def print_report(reportdata): ''' Print a nicely formated table from a list of (name, shares, price, change) tuples. ''' headers = ('Name','Shares','Price','Change') print('%10s %10s %10s %10s' % headers) print(('-'*10 + ' ')*len(headers)) for row in reportdata: print('%10s %10d %10.2f %10.2f' % row) Cuando ejecuta su programa de informes, deber\u00eda obtener un resultado como este: >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84","title":"4.2.12 Ejercicios"},{"location":"4/#ejercicio-45-un-problema-de-extensibilidad","text":"Suponga que desea modificar la funci\u00f3n print_report() para admitir una variedad de formatos de salida diferentes, como texto sin formato, HTML, CSV o XML. Para hacer esto, podr\u00eda intentar escribir una funci\u00f3n gigantesca que lo hiciera todo. Sin embargo, hacerlo probablemente conducir\u00eda a un desorden insostenible. En cambio, esta es una oportunidad perfecta para usar la herencia. Para comenzar, conc\u00e9ntrese en los pasos involucrados en la creaci\u00f3n de una tabla. En la parte superior de la tabla hay un conjunto de encabezados de tabla. Despu\u00e9s de eso, aparecen filas de datos de la tabla. Tomemos esos pasos y pong\u00e1moslos en su propia clase. Cree un archivo llamado tableformat.py y defina la siguiente clase: # tableformat.py class TableFormatter: def headings(self, headers): ''' Emite el encabezado de la tabla ''' raise NotImplementedError() def row(self, rowdata): ''' Emite una fila de data de tabla. ''' raise NotImplementedError() Esta clase no hace nada, pero sirve como una especie de especificaci\u00f3n de dise\u00f1o para clases adicionales que se definir\u00e1n en breve. Una clase como esta a veces se denomina \"clase base abstracta\". Modifique la funci\u00f3n print_report() para que acepte un objeto TableFormatter como entrada e invoque m\u00e9todos en \u00e9l para producir la salida. Por ejemplo, as\u00ed: # report.py ... def print_report(reportdata, formatter): ''' Imprima una tabla con un formato agradable a partir de una lista de tuplas (nombre, acciones, precio, cambio). ''' formatter.headings(['Name','Shares','Price','Change']) for name, shares, price, change in reportdata: rowdata = [ name, str(shares), f'{price:0.2f}', f'{change:0.2f}' ] formatter.row(rowdata) Toda vez que agreg\u00f3 un argumento a print_report() , tambi\u00e9n necesitar\u00e1 modificar la portfolio_report()funci\u00f3n. C\u00e1mbielo para que cree un aspecto TableFormatter como este: # report.py import tableformat ... def portfolio_report(portfoliofile, pricefile): ''' Make a stock report given portfolio and price data files. ''' # Read data files portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Create the report data report = make_report_data(portfolio, prices) # Print it out formatter = tableformat.TableFormatter() print_report(report, formatter) Ejecute este nuevo c\u00f3digo: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') ... el programa se bloquea ... Deber\u00eda bloquearse inmediatamente con una excepci\u00f3n NotImplementedError . Eso no es demasiado emocionante, pero es exactamente lo que esper\u00e1bamos. Contin\u00fae con la siguiente parte.","title":"Ejercicio 4.5: un problema de extensibilidad"},{"location":"4/#ejercicio-46-uso-de-la-herencia-para-producir-resultados-diferentes","text":"La clase TableFormatter que defini\u00f3 en la parte (a) est\u00e1 destinada a ampliarse mediante herencia. De hecho, esa es toda la idea. Para ilustrar, defina una clase TextTableFormatter como esta: # tableformat.py ... class TextTableFormatter(TableFormatter): ''' Emite una tabla de texto sin formato ''' def headings(self, headers): for h in headers: print(f'{h:>10s}', end=' ') print() print(('-'*10 + ' ')*len(headers)) def row(self, rowdata): for d in rowdata: print(f'{d:>10s}', end=' ') print() Modifique la funci\u00f3n portfolio_report() as\u00ed y pru\u00e9bela: # report.py ... def portfolio_report(portfoliofile, pricefile): ''' Hace un informe de acciones en funci\u00f3n de los archivos de datos de precios y cartera. ''' # Lee los archivos de data portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crea el reporte de data report = make_report_data(portfolio, prices) # Lo imprime formatter = tableformat.TextTableFormatter() print_report(report, formatter) Esto deber\u00eda producir el mismo resultado que antes: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Sin embargo, cambiemos la salida a otra cosa. Defina una nueva clase CSVTableFormatter que produzca resultados en formato CSV: # tableformat.py ... class CSVTableFormatter(TableFormatter): ''' Output de data de portfolio en formato CSV. ''' def headings(self, headers): print(','.join(headers)) def row(self, rowdata): print(','.join(rowdata)) Modifique su programa principal de la siguiente manera: def portfolio_report(portfoliofile, pricefile): ''' Hace un informe de acciones en funci\u00f3n de los archivos de datos de precios y cartera. ''' portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) report = make_report_data(portfolio, prices) formatter = tableformat.CSVTableFormatter() print_report(report, formatter) Ahora deber\u00eda ver una salida CSV como esta: >>> ================================ RESTART ================================ >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') Name,Shares,Price,Change AA,100,9.22,-22.98 IBM,50,106.28,15.18 CAT,150,35.46,-47.98 MSFT,200,20.89,-30.34 GE,95,13.48,-26.89 MSFT,50,20.89,-44.21 IBM,100,106.28,35.84 Con una idea similar, defina una clase HTMLTableFormatter que produzca una tabla con el siguiente resultado: <tr><th>Name</th><th>Shares</th><th>Price</th><th>Change</th></tr> <tr><td>AA</td><td>100</td><td>9.22</td><td>-22.98</td></tr> <tr><td>IBM</td><td>50</td><td>106.28</td><td>15.18</td></tr> <tr><td>CAT</td><td>150</td><td>35.46</td><td>-47.98</td></tr> <tr><td>MSFT</td><td>200</td><td>20.89</td><td>-30.34</td></tr> <tr><td>GE</td><td>95</td><td>13.48</td><td>-26.89</td></tr> <tr><td>MSFT</td><td>50</td><td>20.89</td><td>-44.21</td></tr> <tr><td>IBM</td><td>100</td><td>106.28</td><td>35.84</td></tr> Pruebe su c\u00f3digo modificando el programa principal para crear un objeto HTMLTableFormatter en lugar de un objeto CSVTableFormatter .","title":"Ejercicio 4.6: Uso de la herencia para producir resultados diferentes"},{"location":"4/#ejercicio-47-polimorfismo-en-accion","text":"Una caracter\u00edstica importante de la programaci\u00f3n orientada a objetos es que puede conectar un objeto a un programa y funcionar\u00e1 sin tener que cambiar el c\u00f3digo existente. Por ejemplo, si escribiera un programa que esperaba usar un objeto TableFormatter , funcionar\u00eda sin importar qu\u00e9 tipo de TableFormatter le haya dado. Este comportamiento a veces se denomina \"polimorfismo\". Un problema potencial es averiguar c\u00f3mo permitir que un usuario elija el formateador que desee. El uso directo de los nombres de las clases TextTableFormatter es a menudo molesto. Por lo tanto, podr\u00eda considerar alg\u00fan enfoque simplificado. Quiz\u00e1s incruste una declaraci\u00f3n-if en el c\u00f3digo como esta: def portfolio_report(portfoliofile, pricefile, fmt='txt'): ''' Hace un informe de acciones en funci\u00f3n de los archivos de datos de precios y cartera. ''' # Lea los archivos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crea el reporte report = make_report_data(portfolio, prices) # Lo imprime if fmt == 'txt': formatter = tableformat.TextTableFormatter() elif fmt == 'csv': formatter = tableformat.CSVTableFormatter() elif fmt == 'html': formatter = tableformat.HTMLTableFormatter() else: raise RuntimeError(f'Unknown format {fmt}') print_report(report, formatter) En este c\u00f3digo, el usuario especifica un nombre simplificado como 'txt'o 'csv' para elegir un formato. Sin embargo, \u00bfes la mejor idea poner una enorme declaraci\u00f3n if en la funci\u00f3n portfolio_report() ? Podr\u00eda ser mejor mover ese c\u00f3digo a una funci\u00f3n de prop\u00f3sito general en otro lugar. En el archivo tableformat.py , agregar una funci\u00f3n create_formatter(name) que permite a un usuario crear un formateador dado un nombre de salida como 'txt', 'csv'o 'html'. Modifique portfolio_report() para que se vea as\u00ed: def portfolio_report(portfoliofile, pricefile, fmt='txt'): ''' Hace un informe de acciones en funci\u00f3n de los archivos de datos de precios y cartera. ''' # Lea los archivos portfolio = read_portfolio(portfoliofile) prices = read_prices(pricefile) # Crea el reporte report = make_report_data(portfolio, prices) # Lo imprime formatter = tableformat.create_formatter(fmt) print_report(report, formatter) Intente llamar a la funci\u00f3n con diferentes formatos para asegurarse de que est\u00e9 funcionando.","title":"Ejercicio 4.7: Polimorfismo en acci\u00f3n"},{"location":"4/#ejercicio-48-poniendo-todo-junto","text":"Modifique el programa report.py para que la funci\u00f3n portfolio_report() tome un argumento opcional que especifique el formato de salida. Por ejemplo: >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv', 'txt') Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 >>> Modifique el programa principal para que se pueda dar un formato en la l\u00ednea de comando: $ python report.py Data/portfolio.csv Data/prices.csv csv Name,Shares,Price,Change AA,100,9.22,-22.98 IBM,50,106.28,15.18 CAT,150,35.46,-47.98 MSFT,200,20.89,-30.34 GE,95,13.48,-26.89 MSFT,50,20.89,-44.21 IBM,100,106.28,35.84 bash $","title":"Ejercicio 4.8: Poniendo todo junto"},{"location":"4/#discusion","text":"Escribir c\u00f3digo extensible es uno de los usos m\u00e1s comunes de la herencia en bibliotecas y marcos de desarrollo. Por ejemplo, un marco puede indicarle que defina su propio objeto que hereda de una clase base proporcionada. Luego se le indica que complete varios m\u00e9todos que implementan varios bits de funcionalidad. Otro concepto algo m\u00e1s profundo es la idea de \"ser due\u00f1o de sus abstracciones\". En los ejercicios, definimos nuestra propia clase para formatear una tabla. Puede mirar su c\u00f3digo y decirse a s\u00ed mismo: \"\u00a1Deber\u00eda usar una biblioteca de formato o algo que ya haya creado otra persona!\" No, debe usar AMBOS su clase y una biblioteca. El uso de su propia clase promueve un acoplamiento flexible y es m\u00e1s flexible. Siempre que su aplicaci\u00f3n utilice la interfaz de programaci\u00f3n de su clase, puede cambiar la implementaci\u00f3n interna para que funcione de la forma que desee. Puede escribir c\u00f3digo totalmente personalizado. Puede utilizar el paquete de terceros de alguien. Cambie un paquete de terceros por un paquete diferente cuando encuentre uno mejor. No importa, ninguno de los c\u00f3digos de su aplicaci\u00f3n se romper\u00e1 mientras conserve la interfaz. Esa es una idea poderosa y es una de las razones por las que podr\u00eda considerar la herencia para algo como esto. Dicho esto, dise\u00f1ar programas orientados a objetos puede ser extremadamente dif\u00edcil. Para obtener m\u00e1s informaci\u00f3n, probablemente deber\u00eda buscar libros sobre el tema de los patrones de dise\u00f1o (aunque comprender lo que sucedi\u00f3 en este ejercicio lo llevar\u00e1 bastante lejos en t\u00e9rminos de usar objetos de una manera pr\u00e1ctica e \u00fatil).","title":"Discusi\u00f3n"},{"location":"4/#43-metodos-especiales","text":"Varias partes del comportamiento de Python se pueden personalizar a trav\u00e9s de m\u00e9todos especiales o llamados \"m\u00e1gicos\". Esta secci\u00f3n presenta esa idea. Adem\u00e1s, se analizan el acceso a atributos din\u00e1micos y los m\u00e9todos vinculados.","title":"4.3 M\u00e9todos especiales"},{"location":"4/#431-introduccion","text":"Las clases pueden definir m\u00e9todos especiales. Estos tienen un significado especial para el int\u00e9rprete de Python. Siempre van precedidos y seguidos de __ . Por ejemplo __init__ . class Stock(object): def __init__(self): ... def __repr__(self): ... Hay docenas de m\u00e9todos especiales, pero solo veremos algunos ejemplos espec\u00edficos.","title":"4.3.1 Introducci\u00f3n"},{"location":"4/#432-metodos-especiales-para-conversiones-de-cadenas","text":"Los objetos tienen dos representaciones de cadenas. >>> from datetime import date >>> d = date(2012, 12, 21) >>> print(d) 2012-12-21 >>> d datetime.date(2012, 12, 21) >>> La funci\u00f3n str() se usa para crear una buena salida imprimible: >>> str(d) '2012-12-21' >>> La funci\u00f3n repr() se utiliza para crear una representaci\u00f3n m\u00e1s detallada para los programadores. >>> repr(d) 'datetime.date(2012, 12, 21)' >>> Esas funciones str() y repr() usan un par de m\u00e9todos especiales en la clase para producir la cadena que se mostrar\u00e1. class Date(object): def __init__(self, year, month, day): self.year = year self.month = month self.day = day # Utilicelo con `str()` def __str__(self): return f'{self.year}-{self.month}-{self.day}' # Utilicelo con `repr()` def __repr__(self): return f'Date({self.year},{self.month},{self.day})' Nota: La convenci\u00f3n para repr ()es devolver una cadena que, cuando se alimenta eval(), recrear\u00e1 el objeto subyacente. Si esto no es posible, se utiliza en su lugar alg\u00fan tipo de representaci\u00f3n f\u00e1cilmente legible.","title":"4.3.2 M\u00e9todos especiales para conversiones de cadenas"},{"location":"4/#433-metodos-especiales-para-matematicas","text":"Los operadores matem\u00e1ticos implican llamadas a los siguientes m\u00e9todos. a + b a.__add__(b) a - b a.__sub__(b) a * b a.__mul__(b) a / b a.__truediv__(b) a // b a.__floordiv__(b) a % b a.__mod__(b) a << b a.__lshift__(b) a >> b a.__rshift__(b) a & b a.__and__(b) a | b a.__or__(b) a ^ b a.__xor__(b) a ** b a.__pow__(b) -a a.__neg__() ~a a.__invert__() abs(a) a.__abs__()","title":"4.3.3 M\u00e9todos especiales para matem\u00e1ticas"},{"location":"4/#434-metodos-especiales-para-acceder-a-los-elementos","text":"Estos son los m\u00e9todos para implementar contenedores. len(x) x.__len__() x[a] x.__getitem__(a) x[a] = v x.__setitem__(a,v) del x[a] x.__delitem__(a) Puedes usarlos en tus clases. class Sequence: def __len__(self): ... def __getitem__(self,a): ... def __setitem__(self,a,v): ... def __delitem__(self,a): ...","title":"4.3.4 M\u00e9todos especiales para acceder a los elementos"},{"location":"4/#435-invocacion-de-metodo","text":"Invocar un m\u00e9todo es un proceso de dos pasos. B\u00fasqueda: el .operador Llamada de m\u00e9todo: el operador () >>> s = Stock('GOOG',100,490.10) >>> c = s.cost # Lookup >>> c <bound method Stock.cost of <Stock object at 0x590d0>> >>> c() # Method call 49010.0 >>>","title":"4.3.5 Invocaci\u00f3n de m\u00e9todo"},{"location":"4/#436-metodos-vinculados","text":"Un m\u00e9todo que a\u00fan no ha sido invocado por el operador de llamada de funci\u00f3n () se conoce como m\u00e9todo vinculado. Opera en la instancia donde se origin\u00f3. >>> s = Stock('GOOG', 100, 490.10) >>> s <Stock object at 0x590d0> >>> c = s.cost >>> c <bound method Stock.cost of <Stock object at 0x590d0>> >>> c() 49010.0 >>> Los m\u00e9todos vinculados son a menudo una fuente de errores no evidentes por descuido. Por ejemplo: >>> s = Stock('GOOG', 100, 490.10) >>> print('Cost : %0.2f' % s.cost) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: float argument required >>> O comportamiento tortuoso que es dif\u00edcil de depurar. f = open(filename, 'w') ... f.close # Oops. `f` todav\u00eda abierto. En ambos casos, el error se debe a que se olvid\u00f3 de incluir los par\u00e9ntesis finales. Por ejemplo, s.cost() o f.close() .","title":"4.3.6 M\u00e9todos vinculados"},{"location":"4/#437-acceso-a-atributos","text":"Existe una forma alternativa de acceder, manipular y gestionar atributos. getattr(obj, 'name') # Igual a obj.name setattr(obj, 'name', value) # Igual a obj.name = value delattr(obj, 'name') # Igual a del obj.name hasattr(obj, 'name') # Comprueba si el atributo existe Ejemplo: if hasattr(obj, 'x'): x = getattr(obj, 'x'): else: x = None Nota: getattr() tambi\u00e9n tiene un valor predeterminado \u00fatil *arg . x = getattr(obj, 'x', None)","title":"4.3.7 Acceso a atributos"},{"location":"4/#438-ejercicios","text":"","title":"4.3.8 Ejercicios"},{"location":"4/#ejercicio-49-mejor-resultado-para-imprimir-objetos","text":"Modifique el objeto Stock que defini\u00f3 stock.py para que el m\u00e9todo __repr__() produzca una salida m\u00e1s \u00fatil. Por ejemplo: >>> goog = Stock('GOOG', 100, 490.1) >>> goog Stock('GOOG', 100, 490.1) >>> Vea lo que sucede cuando lee una cartera de acciones y vea la lista resultante despu\u00e9s de haber realizado estos cambios. Por ejemplo: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> portfolio ... see what the output is ... >>>","title":"Ejercicio 4.9: Mejor resultado para imprimir objetos"},{"location":"4/#ejercicio-410-un-ejemplo-de-uso-de-getattr","text":"getattr() es un mecanismo alternativo para leer atributos. Se puede usar para escribir c\u00f3digo extremadamente flexible. Para empezar, prueba este ejemplo: >>> import stock >>> s = stock.Stock('GOOG', 100, 490.1) >>> columns = ['name', 'shares'] >>> for colname in columns: print(colname, '=', getattr(s, colname)) name = GOOG shares = 100 >>> Observe con atenci\u00f3n que los datos de salida est\u00e1n determinados por completo por los nombres de los atributos enumerados en la variable columns . En el archivo tableformat.py , tome esta idea y ampl\u00edela en una funci\u00f3n generalizada print_table()que imprima una tabla que muestra los atributos especificados por el usuario de una lista de objetos arbitrarios. Al igual que con la funci\u00f3n print_report() anterior, print_table() tambi\u00e9n deber\u00eda aceptar una instancia de TableFormatter para controlar el formato de salida. As\u00ed es como deber\u00eda funcionar: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> from tableformat import create_formatter, print_table >>> formatter = create_formatter('txt') >>> print_table(portfolio, ['name','shares'], formatter) name shares ---------- ---------- AA 100 IBM 50 CAT 150 MSFT 200 GE 95 MSFT 50 IBM 100 >>> print_table(portfolio, ['name','shares','price'], formatter) name shares price ---------- ---------- ---------- AA 100 32.2 IBM 50 91.1 CAT 150 83.44 MSFT 200 51.23 GE 95 40.37 MSFT 50 65.1 IBM 100 70.44 >>>","title":"Ejercicio 4.10: un ejemplo de uso de getattr()"},{"location":"4/#44-definicion-de-excepciones","text":"Las excepciones definidas por el usuario se definen por clases. class NetworkError(Exception): pass Las excepciones siempre heredan de Exception . Usualmente suelen ser clases vac\u00edas. Haga uso de pass para el cuerpo. Tambi\u00e9n puede hacer una jerarqu\u00eda de sus excepciones. class AuthenticationError(NetworkError): pass class ProtocolError(NetworkError): pass","title":"4.4 Definici\u00f3n de excepciones"},{"location":"4/#441-ejercicios","text":"","title":"4.4.1. Ejercicios"},{"location":"4/#ejercicio-411-definicion-de-una-excepcion-personalizada","text":"A menudo, es una buena pr\u00e1ctica que las bibliotecas definan sus propias excepciones. Esto hace que sea m\u00e1s f\u00e1cil distinguir entre las excepciones de Python generadas en respuesta a errores de programaci\u00f3n comunes frente a las excepciones generadas intencionalmente por una biblioteca para se\u00f1alar un problema de uso espec\u00edfico. Modifique la funci\u00f3n create_formatter() del \u00faltimo ejercicio para que genere una excepci\u00f3n FormatError personalizada cuando el usuario proporcione un nombre de formato incorrecto. Por ejemplo: >>> from tableformat import create_formatter >>> formatter = create_formatter('xls') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"tableformat.py\", line 71, in create_formatter raise FormatError('Unknown table format %s' % name) FormatError: Unknown table format xls >>>","title":"Ejercicio 4.11: Definici\u00f3n de una excepci\u00f3n personalizada"},{"location":"5/","text":"5. Funcionamiento interno del objeto Python En esta secci\u00f3n aprenderemos sobre el funcionamiento interno de los objetos en Python. Algunos programadores con experiencia en otros lenguajes de programaci\u00f3n a menudo encuentran que la noci\u00f3n de clases en Python carece de ciertas caracter\u00edsticas. Por ejemplo, no existe la noci\u00f3n de control de accesso (e.g. privado, protegido), el argumento self lo encuentran extra\u00f1o, y trabajar con objetos se siente como una actividad con mucho libertinaje. Conoceremos como todo funciona y algunos patrones comunes para la encapsulaci\u00f3n interna de objetos. 5.1 Diccionarios, Otra Visita El sistema de objetos de Python se basa en gran medida en una implementaci\u00f3n que incluye diccionarios. Esta secci\u00f3n trata sobre eso. 5.1.1 Diccionarios Recuerde que un diccionario es una colecci\u00f3n de valores con nombre. stock = { 'name' : 'GOOG', 'shares' : 100, 'price' : 490.1 } Los diccionarios se utilizan com\u00fanmente para estructuras de datos simples. Sin embargo, se utilizan para partes cr\u00edticas del interpretador y pueden ser el tipo de datos m\u00e1s importante en Python . 5.1.2 Dicts y Modulos Dentro de un m\u00f3dulo, un diccionario contiene todas las variables y funciones globales. # foo.py x = 42 def bar(): ... def spam(): ... Si inspecciona foo.__dict__ o globals() , ver\u00e1 el diccionario. { 'x' : 42, 'bar' : <function bar>, 'spam' : <function spam> } 5.1.3 Dicts y objetos Los objetos definidos por el usuario tambi\u00e9n utilizan diccionarios para datos de instancia y clases. De hecho, todo el sistema de objetos es principalmente una capa adicional que se coloca encima de los diccionarios. Un diccionario contiene los datos ejemplo, __dict__ . >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ {'name' : 'GOOG', 'shares' : 100, 'price': 490.1 } Popule este dict (e instancia) al asignar a self . class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Los datos de la instancia que se encuentran en self.__dict__ tienen el siguiente aspecto: { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } Cada instancia tiene su propio diccionario privado. s = Stock('GOOG', 100, 490.1) # {'name' : 'GOOG','shares' : 100, 'price': 490.1 } t = Stock('AAPL', 50, 123.45) # {'name' : 'AAPL','shares' : 50, 'price': 123.45 } Si cre\u00f3 100 instancias de alguna clase, hay 100 diccionarios que contienen datos. 5.1.4 Miembros de la clase Un diccionario separado tambi\u00e9n contiene los m\u00e9todos. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price def cost(self): return self.shares * self.price def sell(self, nshares): self.shares -= nshares El diccionario est\u00e1 en Stock.__dict__ . { 'cost': <function>, 'sell': <function>, '__init__': <function> } 5.1.5 Instancias y clases Las instancias y clases est\u00e1n vinculadas entre s\u00ed. El atributo __class__ hace referencia a la clase. >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } >>> s.__class__ <class '__main__.Stock'> >>> ```` El diccionario de instancias contiene datos \u00fanicos para cada instancia, mientras que el diccionario de clase contiene datos compartidos colectivamente por todas las instancias. ### 5.1.6 Acceso a atributos Cuando trabaja con objetos, acceda a datos y m\u00e9todos utilizando el operador `.`. ```python x = obj.name # Conseguir obj.name = value # Definir del obj.name # Remover Estas operaciones est\u00e1n directamente vinculadas al diccionario subyacente del objeto. 5.1.7 Modificar instancias Las operaciones que modifican un objeto actualizan el diccionario subyacente. >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ { 'name':'GOOG', 'shares': 100, 'price': 490.1 } >>> s.shares = 50 # Setting >>> s.date = '6/7/2007' # Setting >>> s.__dict__ { 'name': 'GOOG', 'shares': 50, 'price': 490.1, 'date': '6/7/2007' } >>> del s.shares # Deleting >>> s.__dict__ { 'name': 'GOOG', 'price': 490.1, 'date': '6/7/2007' } >>> 5.1.8 Atributos de lectura Suponga que lee un atributo en una instancia. x = obj.name El atributo puede existir en dos lugares: Diccionario de la instancia local. Diccionario de la clase. Se deben revisar ambos diccionarios. Primero, verifique en el __dict__ local. Si no se encuentra ah\u00ed, busque en el __dict__ de la clase, a trav\u00e9s de __class__ . >>> s = Stock(...) >>> s.name 'GOOG' >>> s.cost() 49010.0 >>> Este esquema de b\u00fasqueda es c\u00f3mo los miembros de una clase son compartidos por todas las instancias. 5.1.9 C\u00f3mo funciona la herencia Las clases pueden heredar de otras clases. class A(B, C): ... Las clases base se almacenan en una tupla en cada clase. >>> A.__bases__ (<class '__main__.B'>, <class '__main__.C'>) >>> Esto proporciona un enlace a las clases padres. 5.1.10 Lectura de atributos con herencia L\u00f3gicamente, el proceso de b\u00fasqueda de un atributo es el siguiente. Primero, verifique en local __dict__ . Si no lo encuentra, busque en el __dict__ de la clase. Si no se encuentra en la clase, busque en las clases base a trav\u00e9s de __bases__ . Sin embargo, hay algunos aspectos sutiles de esto que se comentan a continuaci\u00f3n. 5.1.11 Lectura de atributos con herencia \u00fanica En las jerarqu\u00edas de herencia, los atributos se encuentran subiendo por el \u00e1rbol de herencia en orden. class A: pass class B(A): pass class C(A): pass class D(B): pass class E(D): pass Con herencia \u00fanica, hay un camino \u00fanico a la cima. 5.1.12 Orden de resoluci\u00f3n de m\u00e9todos o MRO Python calcula previamente una cadena de herencia y la almacena en el atributo MRO de la clase. Puedes verlo. >>> E.__mro__ (<class '__main__.E'>, <class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <type 'object'>) >>> Esta cadena se denomina Orden de resoluci\u00f3n de m\u00e9todos . Para encontrar un atributo, Python recorre el MRO en orden. 5.1.13 MRO en herencia m\u00faltiple Con la herencia m\u00faltiple, no hay un camino \u00fanico hacia la cima. Un ejemplo: class A: pass class B: pass class C(A, B): pass class D(B): pass class E(C, D): pass \u00bfQu\u00e9 sucede cuando accedes a un atributo? e = E() e.attr Se realiza un proceso de b\u00fasqueda de atributos, pero \u00bfcu\u00e1l es el orden? Eso es un problema. Python usa herencia m\u00faltiple cooperativa que obedece a algunas reglas sobre el orden de clases. Los ni\u00f1os siempre son controlados antes que los padres Los padres (si son m\u00faltiples) siempre se marcan en el orden indicado. El MRO se calcula ordenando todas las clases en una jerarqu\u00eda de acuerdo con esas reglas. >>> E.__mro__ ( <class 'E'>, <class 'C'>, <class 'A'>, <class 'D'>, <class 'B'>, <class 'object'>) >>> El algoritmo subyacente se denomina \"Algoritmo de linealizaci\u00f3n C3\". Los detalles precisos no son importantes siempre que recuerde que una jerarqu\u00eda de clases obedece las mismas reglas de ordenamiento que podr\u00eda seguir si su casa se incendiara y tuviera que evacuar: los ni\u00f1os primero, seguidos de los padres. 5.1.14 Una reutilizaci\u00f3n de c\u00f3digo extra\u00f1o (que implica herencia m\u00faltiple) Considere dos objetos completamente no relacionados: class Dog: def noise(self): return 'Bark' def chase(self): return 'Chasing!' class LoudDog(Dog): def noise(self): # Codigo comun a LoudDog (abajo) return super().noise().upper() Y class Bike: def noise(self): return 'On Your Left' def pedal(self): return 'Pedaling!' class LoudBike(Bike): def noise(self): # Codigo comun a LoudDog (arriba) return super().noise().upper() Hay un c\u00f3digo com\u00fan en la implementaci\u00f3n de LoudDog.noise() y LoudBike.noise() . De hecho, el c\u00f3digo es exactamente el mismo. Naturalmente, un c\u00f3digo como ese seguramente atraer\u00e1 a los ingenieros de software. 5.1.15 El patr\u00f3n \"Mixin\" El patr\u00f3n Mixin es una clase con un fragmento de c\u00f3digo. class Loud: def noise(self): return super().noise().upper() Esta clase no se puede utilizar de forma aislada. Se mezcla con otras clases por herencia. class LoudDog(Loud, Dog): pass class LoudBike(Loud, Bike): pass Milagrosamente, el altavoz ahora se implement\u00f3 solo una vez y se reutiliz\u00f3 en dos clases completamente no relacionadas. Este tipo de truco es uno de los usos principales de la herencia m\u00faltiple en Python. 5.1.16 Por qu\u00e9 super() Use super() siempre que esta sobreescribiendo m\u00e9todos. class Loud: def noise(self): return super().noise().upper() super() delegates to the next class on the MRO. El truco es que no sabes qu\u00e9 es. En especial, no sabe qu\u00e9 es si se utiliza la herencia m\u00faltiple. 5.1.17 Algunas precauciones La herencia m\u00faltiple es una herramienta poderosa. Recuerde que con el poder viene la responsabilidad. Los marcos de desarrollo / bibliotecas / librerias / modulos a veces lo usan para funciones avanzadas que involucran la composici\u00f3n de componentes. Ok, ahora puedes olvidarte de que lo le\u00edste. 5.1.18 Ejercicios En la Secci\u00f3n 4, defini\u00f3 una clase Stock que representaba una tenencia de acciones. En este ejercicio usaremos esa clase. Reinicie el int\u00e9rprete y realice algunas instancias: >>> ================================ RESTART ================================ >>> from stock import Stock >>> goog = Stock('GOOG',100,490.10) >>> ibm = Stock('IBM',50, 91.23) >>> Ejercicio 5.1: Representaci\u00f3n de instancias En el shell interactivo, inspeccione los diccionarios subyacentes de las dos instancias que cre\u00f3: >>> goog.__dict__ ... mire la salida ... >>> ibm.__dict__ ... mire la salida ... >>> Ejercicio 5.2: Modificaci\u00f3n de datos de instancia Intente establecer un nuevo atributo en una de las instancias anteriores: >>> goog.date = '6/11/2007' >>> goog.__dict__ ... mire la salida ... >>> ibm.__dict__ ... mire la salida ... >>> En el resultado anterior, notar\u00e1 que la instancia goog tiene un atributo, date , mientras que la instancia ibm no. Es importante tener en cuenta que Python realmente no impone restricciones a los atributos. Por ejemplo, los atributos de una instancia no se limitan a los configurados en el m\u00e9todo __init__() . En lugar de establecer un atributo, intente colocar un nuevo valor directamente en el objeto __dict__ : >>> goog.__dict__['time'] = '9:45am' >>> goog.time '9:45am' >>> Aqu\u00ed, realmente se nota el hecho de que una instancia es solo una capa sobre un diccionario. Nota: vale destacar que la manipulaci\u00f3n directa del diccionario es poco com\u00fan; siempre debe escribir su c\u00f3digo para usar la sintaxis (.). Ejercicio 5.3: El papel de las clases Las definiciones que componen una definici\u00f3n de clase son compartidas por todas las instancias de esa clase. Tenga en cuenta que todas las instancias tienen un enlace a su clase asociada: >>> goog.__class__ ... mire la salida ... >>> ibm.__class__ ... mire la salida ... >>> Intente llamar a un m\u00e9todo en las instancias: >>> goog.cost() 49010.0 >>> ibm.cost() 4561.5 >>> Tenga en cuenta que el nombre de 'costo' no se define en cualquier goog.__dict__ o ibm.__dict__ . En cambio, lo proporciona el diccionario de la clase. Prueba esto: >>> Stock.__dict__['cost'] ... mire la salida ... >>> Intente llamar al m\u00e9todo cost() directamente a trav\u00e9s del diccionario: >>> Stock.__dict__['cost'](goog) 49010.0 >>> Stock.__dict__['cost'](ibm) 4561.5 >>> Observe c\u00f3mo est\u00e1 llamando a la funci\u00f3n definida en la definici\u00f3n de clase y c\u00f3mo el argumento self obtiene la instancia. Intente agregar un nuevo atributo a la clase Stock : >>> Stock.foo = 42 >>> Observe c\u00f3mo este nuevo atributo ahora aparece en todas las instancias: >>> goog.foo 42 >>> ibm.foo 42 >>> Sin embargo, tenga en cuenta que no forma parte del diccionario de la instancia: >>> goog.__dict__ ... mire la salida y verifique que no hay atributo 'foo' ... >>> La raz\u00f3n por la que puede acceder al atributo foo en las instancias es que Python siempre verifica el diccionario de la clase si no puede encontrar algo en la propia instancia. Nota: Esta parte del ejercicio ilustra algo conocido como variable de clase. Supongamos, por ejemplo, que tiene una clase como esta: class Foo(object): a = 13 # variable de Clase def __init__(self,b): self.b = b # variable de Instancia En esta clase, la variable a , asignada en el cuerpo de la propia clase, es una \"variable de clase\". Lo comparten todas las instancias que se crean. Por ejemplo: >>> f = Foo(10) >>> g = Foo(20) >>> f.a 13 >>> g.a 13 >>> f.b # Inspeccione la variable de instancia (difiere) 10 >>> g.b 20 >>> Foo.a = 42 # Change the value of the class variable >>> f.a 42 >>> g.a 42 >>> Ejercicio 5.4: M\u00e9todos vinculados Una caracter\u00edstica sutil de Python es que la invocaci\u00f3n de un m\u00e9todo en realidad implica dos pasos y algo conocido como m\u00e9todo vinculado. Por ejemplo: >>> s = goog.sell >>> s <bound method Stock.sell of Stock('GOOG', 100, 490.1)> >>> s(25) >>> goog.shares 75 >>> Los m\u00e9todos vinculados en realidad contienen todas las piezas necesarias para llamar a un m\u00e9todo. Por ejemplo, mantienen un registro de la funci\u00f3n que implementa el m\u00e9todo: >>> s.__func__ <function sell at 0x10049af50> >>> Este es el mismo valor que se encuentra en el diccionario Stock . >>> Stock.__dict__['sell'] <function sell at 0x10049af50> >>> Los m\u00e9todos enlazados tambi\u00e9n registran la instancia, que es el selfargumento. >>> s.__self__ Stock('GOOG',75,490.1) >>> Cuando se invoca la funci\u00f3n utilizando ()todas las piezas se unen. Por ejemplo, llamar s(25)realmente hace esto: >>> s.__func__(s.__self__, 25) # Same as s(25) >>> goog.shares 50 >>> Ejercicio 5.5: Herencia Crea una nueva clase que herede de Stock s. >>> class NewStock(Stock): ... def yow(self): ... print('Yow!') ... >>> n = NewStock('ACME', 50, 123.45) >>> n.cost() 6172.50 >>> n.yow() Yow! >>> La herencia se implementa ampliando el proceso de b\u00fasqueda de atributos. El atributo __bases__ tiene una tupla de los padres inmediatos: >>> NewStock.__bases__ (<class 'stock.Stock'>,) >>> El atributo __mro__ tiene una tupla de todos los padres, en el orden en que se buscar\u00e1n los atributos. >>> NewStock.__mro__ (<class '__main__.NewStock'>, <class 'stock.Stock'>, <class 'object'>) >>> As\u00ed es como se encontrar\u00eda el m\u00e9todo cost() de la instancia anterior: >>> for cls in n.__class__.__mro__: ... if 'cost' in cls.__dict__: ... break ... >>> cls <class '__main__.Stock'> >>> cls.__dict__['cost'] <function cost at 0x101aed598> >>> 5.2 Clases y encapsulaci\u00f3n Al escribir clases, es com\u00fan intentar encapsular detalles internos. Esta secci\u00f3n presenta algunos modismos de programaci\u00f3n de Python para esto, incluyendo propiedades y variables privadas. 5.2.1 P\u00fablico vs Privado Uno de los roles principales de una clase es encapsular datos y detalles de implementaci\u00f3n de un objeto. Sin embargo, una clase tambi\u00e9n define un Interfaz * p\u00fablica * que se supone que el mundo exterior debe usar para manipular el objeto. Esta distinci\u00f3n entre implementaci\u00f3n Los detalles y la interfaz p\u00fablica son importantes. 5.2.2 Un problema En Python, casi todo lo relacionado con clases y objetos es abierto . Puede inspeccionar f\u00e1cilmente el interior de los objetos. Puedes cambiar las cosas a su antojo. No existe una noci\u00f3n fuerte de control de acceso (es decir, miembros de clases privadas) Esto es un problema cuando intenta aislar detalles de la implementaci\u00f3n interna . 5.2.3 Encapsulaci\u00f3n de Python Python se basa en convenciones de programaci\u00f3n para indicar el uso previsto de algo. Estas convenciones se basan en la denominaci\u00f3n o nombramiento. El lenguaje no impone ciertas reglas, sino que le delega esa responsabilidad al programador. El programador debe observar y cumplir ciertas reglas, sin que el lenguaje lo obligue hacerlo. En ese sentido, Python se distingue de otros lenguajes de programaci\u00f3n que tienen reglas estrictas sobre lo que es p\u00fablico y lo que es privado. 5.2.4 Atributos privados Cualquier nombre de atributo con \"_\" inicial se considera privado . clase Persona (objeto): def __init__ (self, nombre): self._name = 0 Como se mencion\u00f3 anteriormente, este es solo un estilo de programaci\u00f3n. Todavia puede acceder y modificarlo. >>> p = Persona('Guido') >>> p._name 'Guido' >>> p._name = 'Dave' >>> Como regla general, cualquier nombre con un \"_\" inicial se considera implementaci\u00f3n interna ya sea una variable, una funci\u00f3n o un nombre de m\u00f3dulo. Si se encuentra usando tales nombres directamente, probablemente est\u00e9 haciendo algo mal. Busque una funcionalidad de nivel superior. 5.2.5 Atributos simples Considere la siguiente clase. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Una caracter\u00edstica sorprendente es que puede establecer los atributos en cualquier valor: >>> s = Stock('IBM', 50, 91.1) >>> s.shares = 100 >>> s.shares = \"hundred\" >>> s.shares = [1, 0, 0] >>> Puede mirar eso y pensar que quiere algunas verificaciones adicionales. s.shares = '50' # Alza un TypeError, esto es una cadena \u00bfComo lo harias? 5.2.6 Atributos gestionados Un enfoque: introducir m\u00e9todos de acceso. class Stock: def __init__(self, name, shares, price): self.name = name self.set_shares(shares) self.price = price # Metodo que encapa la operaci\u00f3n de acceso al atributo (get) def get_shares(self): return self._shares # Metodo que encapa la operacion de definici\u00f3n del atributo (set) def set_shares(self, value): if not isinstance(value, int): raise TypeError('Esperaba un int') self._shares = value L\u00e1stima que esto rompa todo nuestro c\u00f3digo existente. s.shares = 50 se convierte en s.set_shares(50) 5.2.7 Propiedades class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price @property def shares(self): return self._shares @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Expected int') self._shares = value El acceso normal a los atributos ahora activa los m\u00e9todos getter y setter en @propertyy @shares.setter. >>> s = Stock('IBM', 50, 91.1) >>> s.shares # Provoca @property 50 >>> s.shares = 75 # Prooca @shares.setter >>> Con este patr\u00f3n, no se necesitan cambios en el c\u00f3digo fuente. El nuevo setter tambi\u00e9n se llama cuando hay una asignaci\u00f3n dentro de la clase, incluyendo en el interior del __init__() m\u00e9todo. class Stock: def __init__(self, name, shares, price): ... # La asignaci\u00f3n usa el m\u00e9todo setter de abajo self.shares = shares ... ... @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Expected int') self._shares = value A menudo existe una confusi\u00f3n entre una propiedad y el uso de nombres privados. Aunque una propiedad usa internamente un nombre privado como _shares , el resto de la clase (no la propiedad) puede continuar usando un nombre como shares . Las propiedades tambi\u00e9n son \u00fatiles para los atributos de datos calculados. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price @property def cost(self): return self.shares * self.price ... Esto le permite eliminar los par\u00e9ntesis adicionales, ocultando el hecho de que en realidad es un m\u00e9todo: >>> s = Stock('GOOG', 100, 490.1) >>> s.shares # Instance variable 100 >>> s.cost # Computed Value 49010.0 >>> 5.2.8 Acceso uniforme El \u00faltimo ejemplo muestra c\u00f3mo poner una interfaz m\u00e1s uniforme en un objeto. Si no hace esto, un objeto puede resultar confuso de usar: >>> s = Stock('GOOG', 100, 490.1) >>> a = s.cost() # Method 49010.0 >>> b = s.shares # Data attribute 100 >>> \u00bfPor qu\u00e9 se requiere () para el costo, pero no para las acciones? Una propiedad puede arreglar esto. 5.2.9 Sintaxis del decorador La sintaxis @ se conoce como \"decoraci\u00f3n\". Especifica un modificador que se aplica a la definici\u00f3n de funci\u00f3n que sigue inmediatamente. ... @property def cost(self): return self.shares * self.price More details are given in Section 7. 5.2.10 slots Atributo Puede restringir el conjunto de nombres de atributos. class Stock: __slots__ = ('name','_shares','price') def __init__(self, name, shares, price): self.name = name ... Generar\u00e1 un error para otros atributos. >>> s.price = 385.15 >>> s.prices = 410.2 Traceback (most recent call last): File \"<stdin>\", line 1, in ? AttributeError: 'Stock' object has no attribute 'prices' Aunque esto evita errores y restringe el uso de objetos, en realidad se usa para el rendimiento y hace que Python use la memoria de manera m\u00e1s eficiente. 5.2.11 Comentarios finales sobre encapsulaci\u00f3n No se exceda con atributos privados, propiedades, espacios, etc. Sirven para un prop\u00f3sito espec\u00edfico y es posible que los vea al leer otro c\u00f3digo de Python. Sin embargo, no son necesarios para la mayor parte de la codificaci\u00f3n diaria. 5.2.12 Ejercicios Ejercicio 5.6: Propiedades simples Las propiedades son una forma \u00fatil de agregar \"atributos calculados\" a un objeto. En stock.py , creaste un objeto Stock. Observe que en su objeto hay una ligera inconsistencia en c\u00f3mo se extraen los diferentes tipos de datos: >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.1) >>> s.shares 100 >>> s.price 490.1 >>> s.cost() 49010.0 >>> Espec\u00edficamente, observe c\u00f3mo tiene que agregar extra () a cost porque es un m\u00e9todo. Puede deshacerse del extra () en cost() si lo convierte en una propiedad. Tome su clase Stock y modif\u00edquela para que el c\u00e1lculo del costo funcione as\u00ed: >>> ================================ RESTART ================================ >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.1) >>> s.cost 49010.0 >>> Intente llamar s.cost() como una funci\u00f3n y observe que no funciona ahora que cost se ha definido como una propiedad. >>> s.cost() ... fracasa ... >>> Hacer este cambio probablemente romper\u00e1 su programa pcost.py anterior . Es posible que deba volver atr\u00e1s y deshacerse del m\u00e9todo () en cost() . Ejercicio 5.7: Propiedades y establecedores Modifique el atributo shares para que el valor se almacene en un atributo privado y que se utilicen un par de funciones de propiedad para garantizar que siempre se establezca en un valor entero. A continuaci\u00f3n, se muestra un ejemplo del comportamiento esperado: >>> ================================ RESTART ================================ >>> from stock import Stock >>> s = Stock('GOOG',100,490.10) >>> s.shares = 50 >>> s.shares = 'a lot' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: expected an integer >>> Ejercicio 5.8: Agregar ranuras Modifique la clase Stock para que tenga un atributo __slots__ . Luego, verifique que no se puedan agregar nuevos atributos: >>> ================================ RESTART ================================ >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.10) >>> s.name 'GOOG' >>> s.blah = 42 ... mire lo que sucede ... >>> Cuando lo usa __slots__ , Python usa una representaci\u00f3n interna de objetos m\u00e1s eficiente. \u00bfQu\u00e9 sucede si intenta inspeccionar el diccionario subyacente de s arriba? >>> s.__dict__ ... mire lo que sucede ... >>> Cabe se\u00f1alar que __slots__ se usa m\u00e1s com\u00fanmente como optimizaci\u00f3n en clases que sirven como estructuras de datos. El uso de ranuras har\u00e1 que dichos programas usen mucha menos memoria y se ejecuten un poco m\u00e1s r\u00e1pido. Sin embargo , probablemente deber\u00eda evitar el uso de __slots__ en la mayor\u00eda de las otras clases.","title":"5 Entra\u00f1as del Objeto"},{"location":"5/#5-funcionamiento-interno-del-objeto-python","text":"En esta secci\u00f3n aprenderemos sobre el funcionamiento interno de los objetos en Python. Algunos programadores con experiencia en otros lenguajes de programaci\u00f3n a menudo encuentran que la noci\u00f3n de clases en Python carece de ciertas caracter\u00edsticas. Por ejemplo, no existe la noci\u00f3n de control de accesso (e.g. privado, protegido), el argumento self lo encuentran extra\u00f1o, y trabajar con objetos se siente como una actividad con mucho libertinaje. Conoceremos como todo funciona y algunos patrones comunes para la encapsulaci\u00f3n interna de objetos.","title":"5. Funcionamiento interno del objeto Python"},{"location":"5/#51-diccionarios-otra-visita","text":"El sistema de objetos de Python se basa en gran medida en una implementaci\u00f3n que incluye diccionarios. Esta secci\u00f3n trata sobre eso.","title":"5.1 Diccionarios, Otra Visita"},{"location":"5/#511-diccionarios","text":"Recuerde que un diccionario es una colecci\u00f3n de valores con nombre. stock = { 'name' : 'GOOG', 'shares' : 100, 'price' : 490.1 } Los diccionarios se utilizan com\u00fanmente para estructuras de datos simples. Sin embargo, se utilizan para partes cr\u00edticas del interpretador y pueden ser el tipo de datos m\u00e1s importante en Python .","title":"5.1.1 Diccionarios"},{"location":"5/#512-dicts-y-modulos","text":"Dentro de un m\u00f3dulo, un diccionario contiene todas las variables y funciones globales. # foo.py x = 42 def bar(): ... def spam(): ... Si inspecciona foo.__dict__ o globals() , ver\u00e1 el diccionario. { 'x' : 42, 'bar' : <function bar>, 'spam' : <function spam> }","title":"5.1.2 Dicts y Modulos"},{"location":"5/#513-dicts-y-objetos","text":"Los objetos definidos por el usuario tambi\u00e9n utilizan diccionarios para datos de instancia y clases. De hecho, todo el sistema de objetos es principalmente una capa adicional que se coloca encima de los diccionarios. Un diccionario contiene los datos ejemplo, __dict__ . >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ {'name' : 'GOOG', 'shares' : 100, 'price': 490.1 } Popule este dict (e instancia) al asignar a self . class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Los datos de la instancia que se encuentran en self.__dict__ tienen el siguiente aspecto: { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } Cada instancia tiene su propio diccionario privado. s = Stock('GOOG', 100, 490.1) # {'name' : 'GOOG','shares' : 100, 'price': 490.1 } t = Stock('AAPL', 50, 123.45) # {'name' : 'AAPL','shares' : 50, 'price': 123.45 } Si cre\u00f3 100 instancias de alguna clase, hay 100 diccionarios que contienen datos.","title":"5.1.3 Dicts y objetos"},{"location":"5/#514-miembros-de-la-clase","text":"Un diccionario separado tambi\u00e9n contiene los m\u00e9todos. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price def cost(self): return self.shares * self.price def sell(self, nshares): self.shares -= nshares El diccionario est\u00e1 en Stock.__dict__ . { 'cost': <function>, 'sell': <function>, '__init__': <function> }","title":"5.1.4 Miembros de la clase"},{"location":"5/#515-instancias-y-clases","text":"Las instancias y clases est\u00e1n vinculadas entre s\u00ed. El atributo __class__ hace referencia a la clase. >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } >>> s.__class__ <class '__main__.Stock'> >>> ```` El diccionario de instancias contiene datos \u00fanicos para cada instancia, mientras que el diccionario de clase contiene datos compartidos colectivamente por todas las instancias. ### 5.1.6 Acceso a atributos Cuando trabaja con objetos, acceda a datos y m\u00e9todos utilizando el operador `.`. ```python x = obj.name # Conseguir obj.name = value # Definir del obj.name # Remover Estas operaciones est\u00e1n directamente vinculadas al diccionario subyacente del objeto.","title":"5.1.5 Instancias y clases"},{"location":"5/#517-modificar-instancias","text":"Las operaciones que modifican un objeto actualizan el diccionario subyacente. >>> s = Stock('GOOG', 100, 490.1) >>> s.__dict__ { 'name':'GOOG', 'shares': 100, 'price': 490.1 } >>> s.shares = 50 # Setting >>> s.date = '6/7/2007' # Setting >>> s.__dict__ { 'name': 'GOOG', 'shares': 50, 'price': 490.1, 'date': '6/7/2007' } >>> del s.shares # Deleting >>> s.__dict__ { 'name': 'GOOG', 'price': 490.1, 'date': '6/7/2007' } >>>","title":"5.1.7 Modificar instancias"},{"location":"5/#518-atributos-de-lectura","text":"Suponga que lee un atributo en una instancia. x = obj.name El atributo puede existir en dos lugares: Diccionario de la instancia local. Diccionario de la clase. Se deben revisar ambos diccionarios. Primero, verifique en el __dict__ local. Si no se encuentra ah\u00ed, busque en el __dict__ de la clase, a trav\u00e9s de __class__ . >>> s = Stock(...) >>> s.name 'GOOG' >>> s.cost() 49010.0 >>> Este esquema de b\u00fasqueda es c\u00f3mo los miembros de una clase son compartidos por todas las instancias.","title":"5.1.8 Atributos de lectura"},{"location":"5/#519-como-funciona-la-herencia","text":"Las clases pueden heredar de otras clases. class A(B, C): ... Las clases base se almacenan en una tupla en cada clase. >>> A.__bases__ (<class '__main__.B'>, <class '__main__.C'>) >>> Esto proporciona un enlace a las clases padres.","title":"5.1.9 C\u00f3mo funciona la herencia"},{"location":"5/#5110-lectura-de-atributos-con-herencia","text":"L\u00f3gicamente, el proceso de b\u00fasqueda de un atributo es el siguiente. Primero, verifique en local __dict__ . Si no lo encuentra, busque en el __dict__ de la clase. Si no se encuentra en la clase, busque en las clases base a trav\u00e9s de __bases__ . Sin embargo, hay algunos aspectos sutiles de esto que se comentan a continuaci\u00f3n.","title":"5.1.10 Lectura de atributos con herencia"},{"location":"5/#5111-lectura-de-atributos-con-herencia-unica","text":"En las jerarqu\u00edas de herencia, los atributos se encuentran subiendo por el \u00e1rbol de herencia en orden. class A: pass class B(A): pass class C(A): pass class D(B): pass class E(D): pass Con herencia \u00fanica, hay un camino \u00fanico a la cima.","title":"5.1.11 Lectura de atributos con herencia \u00fanica"},{"location":"5/#5112-orden-de-resolucion-de-metodos-o-mro","text":"Python calcula previamente una cadena de herencia y la almacena en el atributo MRO de la clase. Puedes verlo. >>> E.__mro__ (<class '__main__.E'>, <class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <type 'object'>) >>> Esta cadena se denomina Orden de resoluci\u00f3n de m\u00e9todos . Para encontrar un atributo, Python recorre el MRO en orden.","title":"5.1.12 Orden de resoluci\u00f3n de m\u00e9todos o MRO"},{"location":"5/#5113-mro-en-herencia-multiple","text":"Con la herencia m\u00faltiple, no hay un camino \u00fanico hacia la cima. Un ejemplo: class A: pass class B: pass class C(A, B): pass class D(B): pass class E(C, D): pass \u00bfQu\u00e9 sucede cuando accedes a un atributo? e = E() e.attr Se realiza un proceso de b\u00fasqueda de atributos, pero \u00bfcu\u00e1l es el orden? Eso es un problema. Python usa herencia m\u00faltiple cooperativa que obedece a algunas reglas sobre el orden de clases. Los ni\u00f1os siempre son controlados antes que los padres Los padres (si son m\u00faltiples) siempre se marcan en el orden indicado. El MRO se calcula ordenando todas las clases en una jerarqu\u00eda de acuerdo con esas reglas. >>> E.__mro__ ( <class 'E'>, <class 'C'>, <class 'A'>, <class 'D'>, <class 'B'>, <class 'object'>) >>> El algoritmo subyacente se denomina \"Algoritmo de linealizaci\u00f3n C3\". Los detalles precisos no son importantes siempre que recuerde que una jerarqu\u00eda de clases obedece las mismas reglas de ordenamiento que podr\u00eda seguir si su casa se incendiara y tuviera que evacuar: los ni\u00f1os primero, seguidos de los padres.","title":"5.1.13 MRO en herencia m\u00faltiple"},{"location":"5/#5114-una-reutilizacion-de-codigo-extrano-que-implica-herencia-multiple","text":"Considere dos objetos completamente no relacionados: class Dog: def noise(self): return 'Bark' def chase(self): return 'Chasing!' class LoudDog(Dog): def noise(self): # Codigo comun a LoudDog (abajo) return super().noise().upper() Y class Bike: def noise(self): return 'On Your Left' def pedal(self): return 'Pedaling!' class LoudBike(Bike): def noise(self): # Codigo comun a LoudDog (arriba) return super().noise().upper() Hay un c\u00f3digo com\u00fan en la implementaci\u00f3n de LoudDog.noise() y LoudBike.noise() . De hecho, el c\u00f3digo es exactamente el mismo. Naturalmente, un c\u00f3digo como ese seguramente atraer\u00e1 a los ingenieros de software.","title":"5.1.14 Una reutilizaci\u00f3n de c\u00f3digo extra\u00f1o (que implica herencia m\u00faltiple)"},{"location":"5/#5115-el-patron-mixin","text":"El patr\u00f3n Mixin es una clase con un fragmento de c\u00f3digo. class Loud: def noise(self): return super().noise().upper() Esta clase no se puede utilizar de forma aislada. Se mezcla con otras clases por herencia. class LoudDog(Loud, Dog): pass class LoudBike(Loud, Bike): pass Milagrosamente, el altavoz ahora se implement\u00f3 solo una vez y se reutiliz\u00f3 en dos clases completamente no relacionadas. Este tipo de truco es uno de los usos principales de la herencia m\u00faltiple en Python.","title":"5.1.15 El patr\u00f3n \"Mixin\""},{"location":"5/#5116-por-que-super","text":"Use super() siempre que esta sobreescribiendo m\u00e9todos. class Loud: def noise(self): return super().noise().upper() super() delegates to the next class on the MRO. El truco es que no sabes qu\u00e9 es. En especial, no sabe qu\u00e9 es si se utiliza la herencia m\u00faltiple.","title":"5.1.16 Por qu\u00e9 super()"},{"location":"5/#5117-algunas-precauciones","text":"La herencia m\u00faltiple es una herramienta poderosa. Recuerde que con el poder viene la responsabilidad. Los marcos de desarrollo / bibliotecas / librerias / modulos a veces lo usan para funciones avanzadas que involucran la composici\u00f3n de componentes. Ok, ahora puedes olvidarte de que lo le\u00edste.","title":"5.1.17 Algunas precauciones"},{"location":"5/#5118-ejercicios","text":"En la Secci\u00f3n 4, defini\u00f3 una clase Stock que representaba una tenencia de acciones. En este ejercicio usaremos esa clase. Reinicie el int\u00e9rprete y realice algunas instancias: >>> ================================ RESTART ================================ >>> from stock import Stock >>> goog = Stock('GOOG',100,490.10) >>> ibm = Stock('IBM',50, 91.23) >>>","title":"5.1.18 Ejercicios"},{"location":"5/#ejercicio-51-representacion-de-instancias","text":"En el shell interactivo, inspeccione los diccionarios subyacentes de las dos instancias que cre\u00f3: >>> goog.__dict__ ... mire la salida ... >>> ibm.__dict__ ... mire la salida ... >>>","title":"Ejercicio 5.1: Representaci\u00f3n de instancias"},{"location":"5/#ejercicio-52-modificacion-de-datos-de-instancia","text":"Intente establecer un nuevo atributo en una de las instancias anteriores: >>> goog.date = '6/11/2007' >>> goog.__dict__ ... mire la salida ... >>> ibm.__dict__ ... mire la salida ... >>> En el resultado anterior, notar\u00e1 que la instancia goog tiene un atributo, date , mientras que la instancia ibm no. Es importante tener en cuenta que Python realmente no impone restricciones a los atributos. Por ejemplo, los atributos de una instancia no se limitan a los configurados en el m\u00e9todo __init__() . En lugar de establecer un atributo, intente colocar un nuevo valor directamente en el objeto __dict__ : >>> goog.__dict__['time'] = '9:45am' >>> goog.time '9:45am' >>> Aqu\u00ed, realmente se nota el hecho de que una instancia es solo una capa sobre un diccionario. Nota: vale destacar que la manipulaci\u00f3n directa del diccionario es poco com\u00fan; siempre debe escribir su c\u00f3digo para usar la sintaxis (.).","title":"Ejercicio 5.2: Modificaci\u00f3n de datos de instancia"},{"location":"5/#ejercicio-53-el-papel-de-las-clases","text":"Las definiciones que componen una definici\u00f3n de clase son compartidas por todas las instancias de esa clase. Tenga en cuenta que todas las instancias tienen un enlace a su clase asociada: >>> goog.__class__ ... mire la salida ... >>> ibm.__class__ ... mire la salida ... >>> Intente llamar a un m\u00e9todo en las instancias: >>> goog.cost() 49010.0 >>> ibm.cost() 4561.5 >>> Tenga en cuenta que el nombre de 'costo' no se define en cualquier goog.__dict__ o ibm.__dict__ . En cambio, lo proporciona el diccionario de la clase. Prueba esto: >>> Stock.__dict__['cost'] ... mire la salida ... >>> Intente llamar al m\u00e9todo cost() directamente a trav\u00e9s del diccionario: >>> Stock.__dict__['cost'](goog) 49010.0 >>> Stock.__dict__['cost'](ibm) 4561.5 >>> Observe c\u00f3mo est\u00e1 llamando a la funci\u00f3n definida en la definici\u00f3n de clase y c\u00f3mo el argumento self obtiene la instancia. Intente agregar un nuevo atributo a la clase Stock : >>> Stock.foo = 42 >>> Observe c\u00f3mo este nuevo atributo ahora aparece en todas las instancias: >>> goog.foo 42 >>> ibm.foo 42 >>> Sin embargo, tenga en cuenta que no forma parte del diccionario de la instancia: >>> goog.__dict__ ... mire la salida y verifique que no hay atributo 'foo' ... >>> La raz\u00f3n por la que puede acceder al atributo foo en las instancias es que Python siempre verifica el diccionario de la clase si no puede encontrar algo en la propia instancia. Nota: Esta parte del ejercicio ilustra algo conocido como variable de clase. Supongamos, por ejemplo, que tiene una clase como esta: class Foo(object): a = 13 # variable de Clase def __init__(self,b): self.b = b # variable de Instancia En esta clase, la variable a , asignada en el cuerpo de la propia clase, es una \"variable de clase\". Lo comparten todas las instancias que se crean. Por ejemplo: >>> f = Foo(10) >>> g = Foo(20) >>> f.a 13 >>> g.a 13 >>> f.b # Inspeccione la variable de instancia (difiere) 10 >>> g.b 20 >>> Foo.a = 42 # Change the value of the class variable >>> f.a 42 >>> g.a 42 >>>","title":"Ejercicio 5.3: El papel de las clases"},{"location":"5/#ejercicio-54-metodos-vinculados","text":"Una caracter\u00edstica sutil de Python es que la invocaci\u00f3n de un m\u00e9todo en realidad implica dos pasos y algo conocido como m\u00e9todo vinculado. Por ejemplo: >>> s = goog.sell >>> s <bound method Stock.sell of Stock('GOOG', 100, 490.1)> >>> s(25) >>> goog.shares 75 >>> Los m\u00e9todos vinculados en realidad contienen todas las piezas necesarias para llamar a un m\u00e9todo. Por ejemplo, mantienen un registro de la funci\u00f3n que implementa el m\u00e9todo: >>> s.__func__ <function sell at 0x10049af50> >>> Este es el mismo valor que se encuentra en el diccionario Stock . >>> Stock.__dict__['sell'] <function sell at 0x10049af50> >>> Los m\u00e9todos enlazados tambi\u00e9n registran la instancia, que es el selfargumento. >>> s.__self__ Stock('GOOG',75,490.1) >>> Cuando se invoca la funci\u00f3n utilizando ()todas las piezas se unen. Por ejemplo, llamar s(25)realmente hace esto: >>> s.__func__(s.__self__, 25) # Same as s(25) >>> goog.shares 50 >>>","title":"Ejercicio 5.4: M\u00e9todos vinculados"},{"location":"5/#ejercicio-55-herencia","text":"Crea una nueva clase que herede de Stock s. >>> class NewStock(Stock): ... def yow(self): ... print('Yow!') ... >>> n = NewStock('ACME', 50, 123.45) >>> n.cost() 6172.50 >>> n.yow() Yow! >>> La herencia se implementa ampliando el proceso de b\u00fasqueda de atributos. El atributo __bases__ tiene una tupla de los padres inmediatos: >>> NewStock.__bases__ (<class 'stock.Stock'>,) >>> El atributo __mro__ tiene una tupla de todos los padres, en el orden en que se buscar\u00e1n los atributos. >>> NewStock.__mro__ (<class '__main__.NewStock'>, <class 'stock.Stock'>, <class 'object'>) >>> As\u00ed es como se encontrar\u00eda el m\u00e9todo cost() de la instancia anterior: >>> for cls in n.__class__.__mro__: ... if 'cost' in cls.__dict__: ... break ... >>> cls <class '__main__.Stock'> >>> cls.__dict__['cost'] <function cost at 0x101aed598> >>>","title":"Ejercicio 5.5: Herencia"},{"location":"5/#52-clases-y-encapsulacion","text":"Al escribir clases, es com\u00fan intentar encapsular detalles internos. Esta secci\u00f3n presenta algunos modismos de programaci\u00f3n de Python para esto, incluyendo propiedades y variables privadas.","title":"5.2 Clases y encapsulaci\u00f3n"},{"location":"5/#521-publico-vs-privado","text":"Uno de los roles principales de una clase es encapsular datos y detalles de implementaci\u00f3n de un objeto. Sin embargo, una clase tambi\u00e9n define un Interfaz * p\u00fablica * que se supone que el mundo exterior debe usar para manipular el objeto. Esta distinci\u00f3n entre implementaci\u00f3n Los detalles y la interfaz p\u00fablica son importantes.","title":"5.2.1 P\u00fablico vs Privado"},{"location":"5/#522-un-problema","text":"En Python, casi todo lo relacionado con clases y objetos es abierto . Puede inspeccionar f\u00e1cilmente el interior de los objetos. Puedes cambiar las cosas a su antojo. No existe una noci\u00f3n fuerte de control de acceso (es decir, miembros de clases privadas) Esto es un problema cuando intenta aislar detalles de la implementaci\u00f3n interna .","title":"5.2.2 Un problema"},{"location":"5/#523-encapsulacion-de-python","text":"Python se basa en convenciones de programaci\u00f3n para indicar el uso previsto de algo. Estas convenciones se basan en la denominaci\u00f3n o nombramiento. El lenguaje no impone ciertas reglas, sino que le delega esa responsabilidad al programador. El programador debe observar y cumplir ciertas reglas, sin que el lenguaje lo obligue hacerlo. En ese sentido, Python se distingue de otros lenguajes de programaci\u00f3n que tienen reglas estrictas sobre lo que es p\u00fablico y lo que es privado.","title":"5.2.3 Encapsulaci\u00f3n de Python"},{"location":"5/#524-atributos-privados","text":"Cualquier nombre de atributo con \"_\" inicial se considera privado . clase Persona (objeto): def __init__ (self, nombre): self._name = 0 Como se mencion\u00f3 anteriormente, este es solo un estilo de programaci\u00f3n. Todavia puede acceder y modificarlo. >>> p = Persona('Guido') >>> p._name 'Guido' >>> p._name = 'Dave' >>> Como regla general, cualquier nombre con un \"_\" inicial se considera implementaci\u00f3n interna ya sea una variable, una funci\u00f3n o un nombre de m\u00f3dulo. Si se encuentra usando tales nombres directamente, probablemente est\u00e9 haciendo algo mal. Busque una funcionalidad de nivel superior.","title":"5.2.4 Atributos privados"},{"location":"5/#525-atributos-simples","text":"Considere la siguiente clase. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Una caracter\u00edstica sorprendente es que puede establecer los atributos en cualquier valor: >>> s = Stock('IBM', 50, 91.1) >>> s.shares = 100 >>> s.shares = \"hundred\" >>> s.shares = [1, 0, 0] >>> Puede mirar eso y pensar que quiere algunas verificaciones adicionales. s.shares = '50' # Alza un TypeError, esto es una cadena \u00bfComo lo harias?","title":"5.2.5 Atributos simples"},{"location":"5/#526-atributos-gestionados","text":"Un enfoque: introducir m\u00e9todos de acceso. class Stock: def __init__(self, name, shares, price): self.name = name self.set_shares(shares) self.price = price # Metodo que encapa la operaci\u00f3n de acceso al atributo (get) def get_shares(self): return self._shares # Metodo que encapa la operacion de definici\u00f3n del atributo (set) def set_shares(self, value): if not isinstance(value, int): raise TypeError('Esperaba un int') self._shares = value L\u00e1stima que esto rompa todo nuestro c\u00f3digo existente. s.shares = 50 se convierte en s.set_shares(50)","title":"5.2.6 Atributos gestionados"},{"location":"5/#527-propiedades","text":"class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price @property def shares(self): return self._shares @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Expected int') self._shares = value El acceso normal a los atributos ahora activa los m\u00e9todos getter y setter en @propertyy @shares.setter. >>> s = Stock('IBM', 50, 91.1) >>> s.shares # Provoca @property 50 >>> s.shares = 75 # Prooca @shares.setter >>> Con este patr\u00f3n, no se necesitan cambios en el c\u00f3digo fuente. El nuevo setter tambi\u00e9n se llama cuando hay una asignaci\u00f3n dentro de la clase, incluyendo en el interior del __init__() m\u00e9todo. class Stock: def __init__(self, name, shares, price): ... # La asignaci\u00f3n usa el m\u00e9todo setter de abajo self.shares = shares ... ... @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Expected int') self._shares = value A menudo existe una confusi\u00f3n entre una propiedad y el uso de nombres privados. Aunque una propiedad usa internamente un nombre privado como _shares , el resto de la clase (no la propiedad) puede continuar usando un nombre como shares . Las propiedades tambi\u00e9n son \u00fatiles para los atributos de datos calculados. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price @property def cost(self): return self.shares * self.price ... Esto le permite eliminar los par\u00e9ntesis adicionales, ocultando el hecho de que en realidad es un m\u00e9todo: >>> s = Stock('GOOG', 100, 490.1) >>> s.shares # Instance variable 100 >>> s.cost # Computed Value 49010.0 >>>","title":"5.2.7 Propiedades"},{"location":"5/#528-acceso-uniforme","text":"El \u00faltimo ejemplo muestra c\u00f3mo poner una interfaz m\u00e1s uniforme en un objeto. Si no hace esto, un objeto puede resultar confuso de usar: >>> s = Stock('GOOG', 100, 490.1) >>> a = s.cost() # Method 49010.0 >>> b = s.shares # Data attribute 100 >>> \u00bfPor qu\u00e9 se requiere () para el costo, pero no para las acciones? Una propiedad puede arreglar esto.","title":"5.2.8 Acceso uniforme"},{"location":"5/#529-sintaxis-del-decorador","text":"La sintaxis @ se conoce como \"decoraci\u00f3n\". Especifica un modificador que se aplica a la definici\u00f3n de funci\u00f3n que sigue inmediatamente. ... @property def cost(self): return self.shares * self.price More details are given in Section 7.","title":"5.2.9 Sintaxis del decorador"},{"location":"5/#5210-slots-atributo","text":"Puede restringir el conjunto de nombres de atributos. class Stock: __slots__ = ('name','_shares','price') def __init__(self, name, shares, price): self.name = name ... Generar\u00e1 un error para otros atributos. >>> s.price = 385.15 >>> s.prices = 410.2 Traceback (most recent call last): File \"<stdin>\", line 1, in ? AttributeError: 'Stock' object has no attribute 'prices' Aunque esto evita errores y restringe el uso de objetos, en realidad se usa para el rendimiento y hace que Python use la memoria de manera m\u00e1s eficiente.","title":"5.2.10 slots Atributo"},{"location":"5/#5211-comentarios-finales-sobre-encapsulacion","text":"No se exceda con atributos privados, propiedades, espacios, etc. Sirven para un prop\u00f3sito espec\u00edfico y es posible que los vea al leer otro c\u00f3digo de Python. Sin embargo, no son necesarios para la mayor parte de la codificaci\u00f3n diaria.","title":"5.2.11 Comentarios finales sobre encapsulaci\u00f3n"},{"location":"5/#5212-ejercicios","text":"","title":"5.2.12 Ejercicios"},{"location":"5/#ejercicio-56-propiedades-simples","text":"Las propiedades son una forma \u00fatil de agregar \"atributos calculados\" a un objeto. En stock.py , creaste un objeto Stock. Observe que en su objeto hay una ligera inconsistencia en c\u00f3mo se extraen los diferentes tipos de datos: >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.1) >>> s.shares 100 >>> s.price 490.1 >>> s.cost() 49010.0 >>> Espec\u00edficamente, observe c\u00f3mo tiene que agregar extra () a cost porque es un m\u00e9todo. Puede deshacerse del extra () en cost() si lo convierte en una propiedad. Tome su clase Stock y modif\u00edquela para que el c\u00e1lculo del costo funcione as\u00ed: >>> ================================ RESTART ================================ >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.1) >>> s.cost 49010.0 >>> Intente llamar s.cost() como una funci\u00f3n y observe que no funciona ahora que cost se ha definido como una propiedad. >>> s.cost() ... fracasa ... >>> Hacer este cambio probablemente romper\u00e1 su programa pcost.py anterior . Es posible que deba volver atr\u00e1s y deshacerse del m\u00e9todo () en cost() .","title":"Ejercicio 5.6: Propiedades simples"},{"location":"5/#ejercicio-57-propiedades-y-establecedores","text":"Modifique el atributo shares para que el valor se almacene en un atributo privado y que se utilicen un par de funciones de propiedad para garantizar que siempre se establezca en un valor entero. A continuaci\u00f3n, se muestra un ejemplo del comportamiento esperado: >>> ================================ RESTART ================================ >>> from stock import Stock >>> s = Stock('GOOG',100,490.10) >>> s.shares = 50 >>> s.shares = 'a lot' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: expected an integer >>>","title":"Ejercicio 5.7: Propiedades y establecedores"},{"location":"5/#ejercicio-58-agregar-ranuras","text":"Modifique la clase Stock para que tenga un atributo __slots__ . Luego, verifique que no se puedan agregar nuevos atributos: >>> ================================ RESTART ================================ >>> from stock import Stock >>> s = Stock('GOOG', 100, 490.10) >>> s.name 'GOOG' >>> s.blah = 42 ... mire lo que sucede ... >>> Cuando lo usa __slots__ , Python usa una representaci\u00f3n interna de objetos m\u00e1s eficiente. \u00bfQu\u00e9 sucede si intenta inspeccionar el diccionario subyacente de s arriba? >>> s.__dict__ ... mire lo que sucede ... >>> Cabe se\u00f1alar que __slots__ se usa m\u00e1s com\u00fanmente como optimizaci\u00f3n en clases que sirven como estructuras de datos. El uso de ranuras har\u00e1 que dichos programas usen mucha menos memoria y se ejecuten un poco m\u00e1s r\u00e1pido. Sin embargo , probablemente deber\u00eda evitar el uso de __slots__ en la mayor\u00eda de las otras clases.","title":"Ejercicio 5.8: Agregar ranuras"},{"location":"6/","text":"6. Generadores La iteraci\u00f3n es uno de los m\u00e1s comunes patrones de programaci\u00f3n en Python. Los programas hacen mucha iteraci\u00f3n para procesar listas, leer archivos, consultar una base de datos, y m\u00e1s. Una de las caracter\u00edsticas mas poderosas de Python es la habilidad de costumizar y redefinir la iteraci\u00f3n en una funci\u00f3n generadora. Al final de la secci\u00f3n, escribiremos algunos programas que procesan datos en tiempo real en una manera interesante. 6.1 Protocolo de iteraci\u00f3n Esta secci\u00f3n analiza el proceso subyacente de iteraci\u00f3n. 6.1.1 Iteraci\u00f3n en todas partes Muchos objetos diferentes admiten la iteraci\u00f3n. a = 'hello' for c in a: # cicla sobre los caracteres en a ... b = { 'name': 'Dave', 'password':'foo'} for k in b: # cicla sobre las claves del diccionario ... c = [1,2,3,4] for i in c: # cicla sobre los elementos en una lista/tupla ... f = open('foo.txt') for x in f: # cicla sobre las lineas en un archivo ... 6.1.2 Iteraci\u00f3n: Protocolo Considere la forafirmaci\u00f3n. for x in obj: # declaraciones \u00bfQu\u00e9 pasa debajo del cap\u00f3? _iter = obj.__iter__() # consigue el objeto iterador while True: try: x = _iter.__next__() # consigue el pr\u00f3ximo elemento # statements ... except StopIteration: # no hay m\u00e1s elementos break Todos los objetos que trabajan con el for-loopimplementan este protocolo de iteraci\u00f3n de bajo nivel. Ejemplo: iteraci\u00f3n manual sobre una lista. >>> x = [1,2,3] >>> iterador = x.__iter__() >>> iterador <listiterator object at 0x590b0> >>> iterador.__next__() 1 >>> iterador.__next__() 2 >>> iterador.__next__() 3 >>> iterador.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> 6.1.3 Apoyo a la iteraci\u00f3n Knowing about iteration is useful if you want to add it to your own objects. For example, making a custom container. class Portfolio: def __init__(self): self.holdings = [] def __iter__(self): return self.holdings.__iter__() ... port = Portfolio() for s in port: ... 6.1.4 Ejercicios Ejercicio 6.1: Iteraci\u00f3n ilustrada Crea la siguiente lista: a = [1,9,4,25,16] Repetir manualmente esta lista. Llame __iter__() para obtener un iterador y llame al m\u00e9todo __next__() para obtener elementos sucesivos. >>> i = a.__iter__() >>> i <listiterator object at 0x64c10> >>> i.__next__() 1 >>> i.__next__() 9 >>> i.__next__() 4 >>> i.__next__() 25 >>> i.__next__() 16 >>> i.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> StopIteration >>> La funci\u00f3n next() incorporada es un atajo para llamar al m\u00e9todo __next__() de un iterador. Intente usarlo en un archivo: >>> f = open('Data/portfolio.csv') >>> f.__iter__() # Nota: Esto retorna el archivo mismo <_io.TextIOWrapper name='Data/portfolio.csv' mode='r' encoding='UTF-8'> >>> next(f) 'name,shares,price\\n' >>> next(f) '\"AA\",100,32.20\\n' >>> next(f) '\"IBM\",50,91.10\\n' >>> Sigue llamando next(f) hasta que llegues al final del archivo. Mira lo que pasa. Ejercicio 6.2: Apoyo a la iteraci\u00f3n En ocasiones, es posible que desee hacer que uno de sus propios objetos admita la iteraci\u00f3n, especialmente si su objeto se ajusta a una lista existente u otra iterable. En un archivo nuevo portfolio.py , defina la siguiente clase: # portfolio.py class Portfolio: def __init__(self, holdings): self._holdings = holdings @property def total_cost(self): return sum([s.cost for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Esta clase est\u00e1 destinada a ser una capa alrededor de una lista, pero con algunos m\u00e9todos adicionales como la total_costpropiedad. Modifique la funci\u00f3n read_portfolio() en report.py para que cree una instancia de Portfolio como esta: # report.py ... import fileparse from stock import Stock from portfolio import Portfolio def read_portfolio(filename): ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. ''' with open(filename) as file: portdicts = fileparse.parse_csv(file, select=['name','shares','price'], types=[str,int,float]) portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ] return Portfolio(portfolio) ... Intente ejecutar el report.pyprograma. Descubrir\u00e1 que falla espectacularmente debido al hecho de que las Portfolioinstancias no son iterables. >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') ... falla ... Solucione esto modificando la Portfolioclase para admitir la iteraci\u00f3n: class Portfolio: def __init__(self, holdings): self._holdings = holdings def __iter__(self): return self._holdings.__iter__() @property def total_cost(self): return sum([s.shares*s.price for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Una vez que haya realizado este cambio, su report.pyprograma deber\u00eda funcionar nuevamente. Mientras lo hace, arregle su programa pcost.py para usar el nuevo objeto Portfolio . Me gusta esto: # pcost.py import report def portfolio_cost(filename): ''' Computes the total cost (shares*price) of a portfolio file ''' portfolio = report.read_portfolio(filename) return portfolio.total_cost Pru\u00e9belo para asegurarse de que funcione: >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>> Ejercicio 6.3: Hacer un recipiente m\u00e1s adecuado Si crea una clase de contenedor, a menudo desea hacer m\u00e1s que solo iterar. Modifique la Portfolioclase para que tenga otros m\u00e9todos especiales como este: class Portfolio: def __init__(self, holdings): self._holdings = holdings def __iter__(self): return self._holdings.__iter__() def __len__(self): return len(self._holdings) def __getitem__(self, index): return self._holdings[index] def __contains__(self, name): return any([s.name == name for s in self._holdings]) @property def total_cost(self): return sum([s.shares*s.price for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Ahora, pruebe algunos experimentos con esta nueva clase: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> len(portfolio) 7 >>> portfolio[0] Stock('AA', 100, 32.2) >>> portfolio[1] Stock('IBM', 50, 91.1) >>> portfolio[0:3] [Stock('AA', 100, 32.2), Stock('IBM', 50, 91.1), Stock('CAT', 150, 83.44)] >>> 'IBM' in portfolio True >>> 'AAPL' in portfolio False >>> Una observaci\u00f3n importante acerca de esto: generalmente, el c\u00f3digo se considera \u201cPythonic\u201d si habla el vocabulario com\u00fan de c\u00f3mo funcionan normalmente otras partes de Python. Para los objetos de contenedor, el soporte de iteraci\u00f3n, indexaci\u00f3n, contenci\u00f3n y otros tipos de operadores es una parte importante de esto. 6.2 Personalizaci\u00f3n de la iteraci\u00f3n con generadores Esta secci\u00f3n analiza c\u00f3mo se puede personalizar la iteraci\u00f3n utilizando una funci\u00f3n de generador. 6.2.1 Un problema Suponga que desea crear su propio patr\u00f3n de iteraci\u00f3n personalizado. Por ejemplo, una cuenta atr\u00e1s. >>> for x in countdown(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Hay una forma sencilla de hacer esto. 6.2.2 Generadores Un generador es una funci\u00f3n que define la iteraci\u00f3n. def countdown(n): while n > 0: yield n n -= 1 Por ejemplo: >>> for x in countdown(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Un generador es cualquier funci\u00f3n que usa la declaraci\u00f3n yield . El comportamiento de los generadores es diferente al de una funci\u00f3n normal. Llamar a una funci\u00f3n generadora crea un objeto generador. No ejecuta la funci\u00f3n de inmediato. def countdown(n): # agregando sdeclaracion de impresion print('Cuenta hacia abajo desde', n) while n > 0: yield n n -= 1 >>> x = countdown(10) # There is NO PRINT STATEMENT >>> x # x is a generator object <generator object at 0x58490> >>> La funci\u00f3n solo se ejecuta en llamada a __next__() . >>> x = countdown(10) >>> x <generator object at 0x58490> >>> x.__next__() Counting down from 10 10 >>> yield produce un valor, pero suspende la ejecuci\u00f3n de la funci\u00f3n. La funci\u00f3n se reanuda en la pr\u00f3xima llamada a __next__() . >>> x.__next__() 9 >>> x.__next__() 8 Cuando el generador finalmente regresa, la iteraci\u00f3n genera un error. >>> x.__next__() 1 >>> x.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Observaci\u00f3n: Una funci\u00f3n generadora implementa el mismo protocolo de bajo nivel que las declaraciones for usan en listas, tuplas, dictados, archivos, etc. 6.2.3 Ejercicios Ejercicio 6.4: Un generador simple Si alguna vez desea personalizar la iteraci\u00f3n, siempre debe pensar en las funciones del generador. Son f\u00e1ciles de escribir: cree una funci\u00f3n que lleve a cabo la l\u00f3gica de iteraci\u00f3n deseada y util\u00edce yield para emitir valores. Por ejemplo, pruebe este generador que busca en un archivo l\u00edneas que contengan una subcadena coincidente: >>> def filematch(filename, substr): with open(filename, 'r') as f: for line in f: if substr in line: yield line >>> for line in open('Data/portfolio.csv'): print(line, end='') name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 \"CAT\",150,83.44 \"MSFT\",200,51.23 \"GE\",95,40.37 \"MSFT\",50,65.10 \"IBM\",100,70.44 >>> for line in filematch('Data/portfolio.csv', 'IBM'): print(line, end='') \"IBM\",50,91.10 \"IBM\",100,70.44 >>> Esto es algo interesante: la idea de que puede ocultar un mont\u00f3n de procesamiento personalizado en una funci\u00f3n y usarlo para alimentar un ciclo for . El siguiente ejemplo analiza un caso m\u00e1s inusual. Ejercicio 6.5: Supervisi\u00f3n de una fuente de datos de transmisi\u00f3n Los generadores pueden ser una forma interesante de monitorear fuentes de datos en tiempo real, como archivos de registro o feeds del mercado de valores. En esta parte, exploraremos esta idea. Para comenzar, siga cuidadosamente las siguientes instrucciones. El programa Data/stocksim.pyes un programa que simula datos del mercado de valores. Como salida, el programa escribe constantemente datos en tiempo real en un archivo Data/stocklog.csv. En una ventana de comando separada, vaya al Data/directorio y ejecute este programa: bash % python3 stocksim.py Si est\u00e1 en Windows, simplemente ubique el stocksim.pyprograma y haga doble clic en \u00e9l para ejecutarlo. Ahora, olv\u00eddese de este programa (d\u00e9jelo correr). Usando otra ventana, mire el archivo que Data/stocklog.csvest\u00e1 escribiendo el simulador. Deber\u00eda ver que se agregan nuevas l\u00edneas de texto al archivo cada pocos segundos. Nuevamente, deje que este programa se ejecute en segundo plano; se ejecutar\u00e1 durante varias horas (no deber\u00eda tener que preocuparse por ello). Una vez que el programa anterior se est\u00e9 ejecutando, escribamos un peque\u00f1o programa para abrir el archivo, buscar el final y esperar una nueva salida. Cree un archivo follow.pyy coloque este c\u00f3digo en \u00e9l: # follow.py import os import time f = open('Data/stocklog.csv') f.seek(0, os.SEEK_END) # Move file pointer 0 bytes from end of file while True: line = f.readline() if line == '': time.sleep(0.1) # Sleep briefly and retry continue fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if change < 0: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Si ejecuta el programa, ver\u00e1 un indicador de cotizaci\u00f3n en tiempo real. Bajo el cap\u00f3, este c\u00f3digo es como el comando tail -f de Unix que se usa para ver un archivo de registro. Nota: El uso del m\u00e9todo readline() en este ejemplo es algo inusual en el sentido de que no es la forma habitual de leer l\u00edneas de un archivo (normalmente solo usar\u00eda un for-loop). Sin embargo, en este caso, lo estamos usando para sondear repetidamente el final del archivo para ver si se han agregado m\u00e1s datos ( readline() devolver\u00e1 nuevos datos o una cadena vac\u00eda). Ejercicio 6.6: uso de un generador para producir datos Si observa el c\u00f3digo del ejercicio 6.5, la primera parte del c\u00f3digo produce l\u00edneas de datos, mientras que las declaraciones al final del whileciclo consumen los datos. Una caracter\u00edstica importante de las funciones del generador es que puede mover todo el c\u00f3digo de producci\u00f3n de datos a una funci\u00f3n reutilizable. Modifique el c\u00f3digo del ejercicio 6.5 para que la lectura del archivo sea realizada por una funci\u00f3n generadora follow(filename) . Haga que funcione el siguiente c\u00f3digo: >>> for line in follow('Data/stocklog.csv'): print(line, end='') ... Deber\u00eda ver lineas de salida producidas aqu\u00ed ... Modifique el c\u00f3digo de cotizaci\u00f3n burs\u00e1til para que se vea as\u00ed: if __name__ == '__main__': for line in follow('Data/stocklog.csv'): fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if change < 0: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Ejercicio 6.7: Observando tu portafolio Modifique el programa follow.py para que observe el flujo de datos de acciones e imprima un ticker que muestre informaci\u00f3n solo para las acciones de una cartera. Por ejemplo: if __name__ == '__main__': import report portfolio = report.read_portfolio('Data/portfolio.csv') for line in follow('Data/stocklog.csv'): fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if name in portfolio: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Nota: Para que esto funcione, su Portfolioclase debe ser compatible con el inoperador. Vea el ejercicio 6.3 y aseg\u00farese de implementar el operador __contains__() . Discusi\u00f3n Algo muy poderoso acaba de ocurrir aqu\u00ed. Movi\u00f3 un patr\u00f3n de iteraci\u00f3n interesante (l\u00edneas de lectura al final de un archivo) a su propia peque\u00f1a funci\u00f3n. La funci\u00f3n follow() es ahora esta utilidad de prop\u00f3sito completamente general que puede usar en cualquier programa. Por ejemplo, puede usarlo para ver registros del servidor, registros de depuraci\u00f3n y otras fuentes de datos similares. Eso es algo genial. 6.3 Productores, consumidores y oleoductos Los generadores son una herramienta \u00fatil para establecer varios tipos de problemas de productores / consumidores y tuber\u00edas de flujo de datos. Esta secci\u00f3n trata sobre eso. 6.3.1 Problemas entre productores y consumidores Los generadores est\u00e1n estrechamente relacionados con diversas formas de problemas entre productores y consumidoress. # Producer def follow(f): ... while True: ... yield line # Produces value in `line` below ... # Consumer for line in follow(f): # Consumes value from `yield` above ... yield produce valores que for consume. 6.3.2 Tuber\u00edas de generador Puede utilizar este aspecto de los generadores para configurar tuber\u00edas de procesamiento (como las tuber\u00edas Unix). productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor Las tuber\u00edas de procesamiento tienen un productor de datos inicial, un conjunto de etapas de procesamiento intermedias y un consumidor final. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def productor(): ... yield item ... El productor suele ser un generador. Aunque tambi\u00e9n podr\u00eda ser una lista de alguna otra secuencia. yield alimenta datos en la canalizaci\u00f3n. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def consumidor(s): for item in s: ... El consumidor es un bucle for-loop. Obtiene art\u00edculos y hace algo con ellos. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def procesando(s): for item in s: ... yield newitem ... Las etapas intermedias de procesamiento consumen y producen art\u00edculos simult\u00e1neamente. Pueden modificar el flujo de datos. Tambi\u00e9n pueden filtrar (descartar elementos). productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def productor(): ... yield item # entrega el elemento que es recibido por `procesando` ... def procesando(s): for item in s: # Viene del `productor` ... yield newitem # entrega el nuevo elemento ... def consumidor(s): for item in s: # Viene del `procesando` ... C\u00f3digo para configurar la canalizaci\u00f3n a = productor() b = procesando(a) c = consumidor(b) Notar\u00e1 que los datos fluyen gradualmente a trav\u00e9s de las diferentes funciones. 6.3.4 Ejercicios Para este ejercicio, el programa stocksim.py debe seguir ejecut\u00e1ndose en segundo plano. Utilizar\u00e1 la funci\u00f3n follow() que escribi\u00f3 en el ejercicio anterior. Ejercicio 6.8: Configurar una canalizaci\u00f3n simple Veamos la idea de la canalizaci\u00f3n en acci\u00f3n. Escribe la siguiente funci\u00f3n: >>> def filematch(lines, substr): for line in lines: if substr in line: yield line >>> Esta funci\u00f3n es casi exactamente la misma que en el primer ejemplo de generador del ejercicio anterior, excepto que ya no abre un archivo, simplemente opera en una secuencia de l\u00edneas que se le da como argumento. Ahora, intente esto: >>> from follow import follow >>> lines = follow('Data/stocklog.csv') >>> ibm = filematch(lines, 'IBM') >>> for line in ibm: print(line) ... espera por la salida ... La salida puede tardar un poco en aparecer, pero eventualmente deber\u00eda ver algunas l\u00edneas que contienen datos para IBM. Ejercicio 6.9: configurar una canalizaci\u00f3n m\u00e1s compleja Lleve la idea de canalizaci\u00f3n unos pasos m\u00e1s all\u00e1 realizando m\u00e1s acciones. >>> from follow import follow >>> import csv >>> lines = follow('Data/stocklog.csv') >>> rows = csv.reader(lines) >>> for row in rows: print(row) ['BA', '98.35', '6/11/2007', '09:41.07', '0.16', '98.25', '98.35', '98.31', '158148'] ['AA', '39.63', '6/11/2007', '09:41.07', '-0.03', '39.67', '39.63', '39.31', '270224'] ['XOM', '82.45', '6/11/2007', '09:41.07', '-0.23', '82.68', '82.64', '82.41', '748062'] ['PG', '62.95', '6/11/2007', '09:41.08', '-0.12', '62.80', '62.97', '62.61', '454327'] ... Bueno, eso es interesante. Lo que est\u00e1 viendo aqu\u00ed es que la salida de la funci\u00f3n follow() se ha canalizado a la funci\u00f3n csv.reader() y ahora estamos obteniendo una secuencia de filas divididas. Ejercicio 6.10: creaci\u00f3n de m\u00e1s componentes de canalizaci\u00f3n Extendamos toda la idea a una tuber\u00eda m\u00e1s amplia. En un archivo separado ticker.py , comience creando una funci\u00f3n que lea un archivo CSV como lo hizo anteriormente: # ticker.py from follow import follow import csv def parse_stock_data(lines): rows = csv.reader(lines) return rows if __name__ == '__main__': lines = follow('Data/stocklog.csv') rows = parse_stock_data(lines) for row in rows: print(row) Escribe una nueva funci\u00f3n que seleccione columnas espec\u00edficas: # ticker.py ... def select_columns(rows, indices): for row in rows: yield [row[index] for index in indices] ... def parse_stock_data(lines): rows = csv.reader(lines) rows = select_columns(rows, [0, 1, 4]) return rows Ejecute su programa nuevamente. Deber\u00eda ver la salida reducida as\u00ed: ['BA', '98.35', '0.16'] ['AA', '39.63', '-0.03'] ['XOM', '82.45','-0.23'] ['PG', '62.95', '-0.12'] ... Escriba funciones generadoras que conviertan tipos de datos y cree diccionarios. Por ejemplo: ```python # ticker.py ... def convert_types(rows, types): for row in rows: yield [func(val) for func, val in zip(types, row)] def make_dicts(rows, headers): for row in rows: yield dict(zip(headers, row)) ... def parse_stock_data(lines): rows = csv.reader(lines) rows = select_columns(rows, [0, 1, 4]) rows = convert_types(rows, [str, float, float]) rows = make_dicts(rows, ['name', 'price', 'change']) return rows ... Ejecute su programa nuevamente. Ahora deber\u00eda tener un flujo de diccionarios como este: { 'name':'BA', 'price':98.35, 'change':0.16 } { 'name':'AA', 'price':39.63, 'change':-0.03 } { 'name':'XOM', 'price':82.45, 'change': -0.23 } { 'name':'PG', 'price':62.95, 'change':-0.12 } ... Ejercicio 6.11: filtrado de datos Escribe una funci\u00f3n que filtre datos. Por ejemplo: # ticker.py ... def filter_symbols(rows, names): for row in rows: if row['name'] in names: yield row Use esto para filtrar acciones solo para aquellas en su cartera: import report portfolio = report.read_portfolio('Data/portfolio.csv') rows = parse_stock_data(follow('Data/stocklog.csv')) rows = filter_symbols(rows, portfolio) for row in rows: print(row) Ejercicio 6.12: Poni\u00e9ndolo todo junto En el programa ticker.py , escriba una funci\u00f3n ticker(portfile, logfile, fmt) que cree un ticker de acciones en tiempo real a partir de un portafolio, archivo de registro y formato de tabla determinados. Por ejemplo: >>> from ticker import ticker >>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'txt') Name Price Change ---------- ---------- ---------- GE 37.14 -0.18 MSFT 29.96 -0.09 CAT 78.03 -0.49 AA 39.34 -0.32 ... >>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'csv') Name,Price,Change IBM,102.79,-0.28 CAT,78.04,-0.48 AA,39.35,-0.31 CAT,78.05,-0.47 ... Discusi\u00f3n Algunas lecciones aprendidas: puede crear varias funciones de generador y encadenarlas para realizar el procesamiento que involucre tuber\u00edas de flujo de datos. Adem\u00e1s, puede crear funciones que empaqueten una serie de etapas de canalizaci\u00f3n en una sola llamada de funci\u00f3n (por ejemplo, la funci\u00f3n parse_stock_data() ). 6.4 Expresiones generadoras Esta secci\u00f3n presenta algunos temas adicionales relacionados con el generador, incluidas las expresiones del generador y el m\u00f3dulo itertools. 6.4.1 Expresiones generadoras Una versi\u00f3n generadora de una lista de comprensi\u00f3n. >>> a = [1,2,3,4] >>> b = (2*x for x in a) >>> b <generator object at 0x58760> >>> for i in b: ... print(i, end=' ') ... 2 4 6 8 >>> Diferencias con las comprensiones de listas. No construye una lista. El \u00fanico prop\u00f3sito \u00fatil es la iteraci\u00f3n. Una vez consumido, no se puede reutilizar. Sintaxis general. (<expression> for i in s if <conditional>) Tambi\u00e9n puede servir como argumento de funci\u00f3n. sum(x*x for x in a) Se puede aplicar a cualquier iterable. >>> a = [1,2,3,4] >>> b = (x*x for x in a) >>> c = (-x for x in b) >>> for i in c: ... print(i, end=' ') ... -1 -4 -9 -16 >>> El uso principal de las expresiones generadoras es el c\u00f3digo que realiza algunos c\u00e1lculos en una secuencia, pero solo usa el resultado una vez. Por ejemplo, elimine todos los comentarios de un archivo. f = open('somefile.txt') lines = (line for line in f if not line.startswith('#')) for line in lines: ... f.close() Con los generadores, el c\u00f3digo se ejecuta m\u00e1s r\u00e1pido y usa poca memoria. Es como un filtro aplicado a una corriente. 6.4.2 \u00bfPor qu\u00e9 generadores? Muchos problemas se expresan mucho m\u00e1s claramente en t\u00e9rminos de iteraci\u00f3n. Recorrer una colecci\u00f3n de elementos y realizar alg\u00fan tipo de operaci\u00f3n (buscar, reemplazar, modificar, etc.). Las canalizaciones de procesamiento se pueden aplicar a una amplia gama de problemas de procesamiento de datos. Mejor eficiencia de la memoria. Produzca valores solo cuando sea necesario. Contraste con la construcci\u00f3n de listas gigantes. Puede operar en transmisi\u00f3n de datos Los generadores fomentan la reutilizaci\u00f3n del c\u00f3digo Separa la iteraci\u00f3n del c\u00f3digo que usa la iteraci\u00f3n Puede crear una caja de herramientas de funciones de iteraci\u00f3n interesantes y mezclar y combinar . 6.4.3 El m\u00f3dulo itertools El itertoolses un m\u00f3dulo de biblioteca con varias funciones dise\u00f1adas para ayudar con iteradores / generadores. itertools.chain(s1,s2) itertools.count(n) itertools.cycle(s) itertools.dropwhile(predicate, s) itertools.groupby(s) itertools.ifilter(predicate, s) itertools.imap(function, s1, ... sN) itertools.repeat(s, n) itertools.tee(s, ncopies) itertools.izip(s1, ... , sN) Todas las funciones procesan datos de forma iterativa. Implementan varios tipos de patrones de iteraci\u00f3n. M\u00e1s informaci\u00f3n en el tutorial de Trucos de generador para programadores de sistemas de PyCon '08. 6.4.4 Ejercicios En los ejercicios anteriores, escribi\u00f3 un c\u00f3digo que sigui\u00f3 a las l\u00edneas que se escribieron en un archivo de registro y las analiz\u00f3 en una secuencia de filas. Este ejercicio contin\u00faa bas\u00e1ndose en eso. Aseg\u00farese de que Data/stocksim.py a\u00fan se est\u00e9 ejecutando. Ejercicio 6.13: Expresiones generadoras Las expresiones generadoras son una versi\u00f3n generadora de una lista de comprensi\u00f3n. Por ejemplo: >>> nums = [1, 2, 3, 4, 5] >>> squares = (x*x for x in nums) >>> squares <generator object <genexpr> at 0x109207e60> >>> for n in squares: ... print(n) ... 1 4 9 16 25 A diferencia de una lista de comprensi\u00f3n, una expresi\u00f3n generadora solo se puede usar una vez. Por lo tanto, si prueba otro ciclo for, no obtiene nada: >>> for n in squares: ... print(n) ... >>> Ejercicio 6.14: Expresiones generadoras en argumentos de funciones Las expresiones generadoras a veces se colocan en argumentos de funci\u00f3n. Parece un poco extra\u00f1o al principio, pero prueba este experimento: >>> nums = [1,2,3,4,5] >>> sum([x*x for x in nums]) # comprension de lista 55 >>> sum(x*x for x in nums) # una expresi\u00f3n generadora 55 >>> En el ejemplo anterior, la segunda versi\u00f3n que usa generadores usar\u00eda significativamente menos memoria si se manipulara una lista grande. En su portfolio.pyarchivo, realiz\u00f3 algunos c\u00e1lculos relacionados con listas por comprensi\u00f3n. Intente reemplazarlos con expresiones generadoras. Ejercicio 6.15: simplificaci\u00f3n de c\u00f3digo Las expresiones de generadores son a menudo un reemplazo \u00fatil para las funciones de peque\u00f1os generadores. Por ejemplo, en lugar de escribir una funci\u00f3n como esta: def filter_symbols(rows, names): for row in rows: if row['name'] in names: yield row Podr\u00edas escribir algo como esto: rows = (row for row in rows if row['name'] in names) Modifique el programa ticker.py para usar expresiones generadoras seg\u00fan corresponda.","title":"6 Generadores"},{"location":"6/#6-generadores","text":"La iteraci\u00f3n es uno de los m\u00e1s comunes patrones de programaci\u00f3n en Python. Los programas hacen mucha iteraci\u00f3n para procesar listas, leer archivos, consultar una base de datos, y m\u00e1s. Una de las caracter\u00edsticas mas poderosas de Python es la habilidad de costumizar y redefinir la iteraci\u00f3n en una funci\u00f3n generadora. Al final de la secci\u00f3n, escribiremos algunos programas que procesan datos en tiempo real en una manera interesante.","title":"6. Generadores"},{"location":"6/#61-protocolo-de-iteracion","text":"Esta secci\u00f3n analiza el proceso subyacente de iteraci\u00f3n.","title":"6.1 Protocolo de iteraci\u00f3n"},{"location":"6/#611-iteracion-en-todas-partes","text":"Muchos objetos diferentes admiten la iteraci\u00f3n. a = 'hello' for c in a: # cicla sobre los caracteres en a ... b = { 'name': 'Dave', 'password':'foo'} for k in b: # cicla sobre las claves del diccionario ... c = [1,2,3,4] for i in c: # cicla sobre los elementos en una lista/tupla ... f = open('foo.txt') for x in f: # cicla sobre las lineas en un archivo ...","title":"6.1.1 Iteraci\u00f3n en todas partes"},{"location":"6/#612-iteracion-protocolo","text":"Considere la forafirmaci\u00f3n. for x in obj: # declaraciones \u00bfQu\u00e9 pasa debajo del cap\u00f3? _iter = obj.__iter__() # consigue el objeto iterador while True: try: x = _iter.__next__() # consigue el pr\u00f3ximo elemento # statements ... except StopIteration: # no hay m\u00e1s elementos break Todos los objetos que trabajan con el for-loopimplementan este protocolo de iteraci\u00f3n de bajo nivel. Ejemplo: iteraci\u00f3n manual sobre una lista. >>> x = [1,2,3] >>> iterador = x.__iter__() >>> iterador <listiterator object at 0x590b0> >>> iterador.__next__() 1 >>> iterador.__next__() 2 >>> iterador.__next__() 3 >>> iterador.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>>","title":"6.1.2 Iteraci\u00f3n: Protocolo"},{"location":"6/#613-apoyo-a-la-iteracion","text":"Knowing about iteration is useful if you want to add it to your own objects. For example, making a custom container. class Portfolio: def __init__(self): self.holdings = [] def __iter__(self): return self.holdings.__iter__() ... port = Portfolio() for s in port: ...","title":"6.1.3 Apoyo a la iteraci\u00f3n"},{"location":"6/#614-ejercicios","text":"","title":"6.1.4 Ejercicios"},{"location":"6/#ejercicio-61-iteracion-ilustrada","text":"Crea la siguiente lista: a = [1,9,4,25,16] Repetir manualmente esta lista. Llame __iter__() para obtener un iterador y llame al m\u00e9todo __next__() para obtener elementos sucesivos. >>> i = a.__iter__() >>> i <listiterator object at 0x64c10> >>> i.__next__() 1 >>> i.__next__() 9 >>> i.__next__() 4 >>> i.__next__() 25 >>> i.__next__() 16 >>> i.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> StopIteration >>> La funci\u00f3n next() incorporada es un atajo para llamar al m\u00e9todo __next__() de un iterador. Intente usarlo en un archivo: >>> f = open('Data/portfolio.csv') >>> f.__iter__() # Nota: Esto retorna el archivo mismo <_io.TextIOWrapper name='Data/portfolio.csv' mode='r' encoding='UTF-8'> >>> next(f) 'name,shares,price\\n' >>> next(f) '\"AA\",100,32.20\\n' >>> next(f) '\"IBM\",50,91.10\\n' >>> Sigue llamando next(f) hasta que llegues al final del archivo. Mira lo que pasa.","title":"Ejercicio 6.1: Iteraci\u00f3n ilustrada"},{"location":"6/#ejercicio-62-apoyo-a-la-iteracion","text":"En ocasiones, es posible que desee hacer que uno de sus propios objetos admita la iteraci\u00f3n, especialmente si su objeto se ajusta a una lista existente u otra iterable. En un archivo nuevo portfolio.py , defina la siguiente clase: # portfolio.py class Portfolio: def __init__(self, holdings): self._holdings = holdings @property def total_cost(self): return sum([s.cost for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Esta clase est\u00e1 destinada a ser una capa alrededor de una lista, pero con algunos m\u00e9todos adicionales como la total_costpropiedad. Modifique la funci\u00f3n read_portfolio() en report.py para que cree una instancia de Portfolio como esta: # report.py ... import fileparse from stock import Stock from portfolio import Portfolio def read_portfolio(filename): ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. ''' with open(filename) as file: portdicts = fileparse.parse_csv(file, select=['name','shares','price'], types=[str,int,float]) portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ] return Portfolio(portfolio) ... Intente ejecutar el report.pyprograma. Descubrir\u00e1 que falla espectacularmente debido al hecho de que las Portfolioinstancias no son iterables. >>> import report >>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv') ... falla ... Solucione esto modificando la Portfolioclase para admitir la iteraci\u00f3n: class Portfolio: def __init__(self, holdings): self._holdings = holdings def __iter__(self): return self._holdings.__iter__() @property def total_cost(self): return sum([s.shares*s.price for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Una vez que haya realizado este cambio, su report.pyprograma deber\u00eda funcionar nuevamente. Mientras lo hace, arregle su programa pcost.py para usar el nuevo objeto Portfolio . Me gusta esto: # pcost.py import report def portfolio_cost(filename): ''' Computes the total cost (shares*price) of a portfolio file ''' portfolio = report.read_portfolio(filename) return portfolio.total_cost Pru\u00e9belo para asegurarse de que funcione: >>> import pcost >>> pcost.portfolio_cost('Data/portfolio.csv') 44671.15 >>>","title":"Ejercicio 6.2: Apoyo a la iteraci\u00f3n"},{"location":"6/#ejercicio-63-hacer-un-recipiente-mas-adecuado","text":"Si crea una clase de contenedor, a menudo desea hacer m\u00e1s que solo iterar. Modifique la Portfolioclase para que tenga otros m\u00e9todos especiales como este: class Portfolio: def __init__(self, holdings): self._holdings = holdings def __iter__(self): return self._holdings.__iter__() def __len__(self): return len(self._holdings) def __getitem__(self, index): return self._holdings[index] def __contains__(self, name): return any([s.name == name for s in self._holdings]) @property def total_cost(self): return sum([s.shares*s.price for s in self._holdings]) def tabulate_shares(self): from collections import Counter total_shares = Counter() for s in self._holdings: total_shares[s.name] += s.shares return total_shares Ahora, pruebe algunos experimentos con esta nueva clase: >>> import report >>> portfolio = report.read_portfolio('Data/portfolio.csv') >>> len(portfolio) 7 >>> portfolio[0] Stock('AA', 100, 32.2) >>> portfolio[1] Stock('IBM', 50, 91.1) >>> portfolio[0:3] [Stock('AA', 100, 32.2), Stock('IBM', 50, 91.1), Stock('CAT', 150, 83.44)] >>> 'IBM' in portfolio True >>> 'AAPL' in portfolio False >>> Una observaci\u00f3n importante acerca de esto: generalmente, el c\u00f3digo se considera \u201cPythonic\u201d si habla el vocabulario com\u00fan de c\u00f3mo funcionan normalmente otras partes de Python. Para los objetos de contenedor, el soporte de iteraci\u00f3n, indexaci\u00f3n, contenci\u00f3n y otros tipos de operadores es una parte importante de esto.","title":"Ejercicio 6.3: Hacer un recipiente m\u00e1s adecuado"},{"location":"6/#62-personalizacion-de-la-iteracion-con-generadores","text":"Esta secci\u00f3n analiza c\u00f3mo se puede personalizar la iteraci\u00f3n utilizando una funci\u00f3n de generador.","title":"6.2 Personalizaci\u00f3n de la iteraci\u00f3n con generadores"},{"location":"6/#621-un-problema","text":"Suponga que desea crear su propio patr\u00f3n de iteraci\u00f3n personalizado. Por ejemplo, una cuenta atr\u00e1s. >>> for x in countdown(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Hay una forma sencilla de hacer esto.","title":"6.2.1 Un problema"},{"location":"6/#622-generadores","text":"Un generador es una funci\u00f3n que define la iteraci\u00f3n. def countdown(n): while n > 0: yield n n -= 1 Por ejemplo: >>> for x in countdown(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Un generador es cualquier funci\u00f3n que usa la declaraci\u00f3n yield . El comportamiento de los generadores es diferente al de una funci\u00f3n normal. Llamar a una funci\u00f3n generadora crea un objeto generador. No ejecuta la funci\u00f3n de inmediato. def countdown(n): # agregando sdeclaracion de impresion print('Cuenta hacia abajo desde', n) while n > 0: yield n n -= 1 >>> x = countdown(10) # There is NO PRINT STATEMENT >>> x # x is a generator object <generator object at 0x58490> >>> La funci\u00f3n solo se ejecuta en llamada a __next__() . >>> x = countdown(10) >>> x <generator object at 0x58490> >>> x.__next__() Counting down from 10 10 >>> yield produce un valor, pero suspende la ejecuci\u00f3n de la funci\u00f3n. La funci\u00f3n se reanuda en la pr\u00f3xima llamada a __next__() . >>> x.__next__() 9 >>> x.__next__() 8 Cuando el generador finalmente regresa, la iteraci\u00f3n genera un error. >>> x.__next__() 1 >>> x.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Observaci\u00f3n: Una funci\u00f3n generadora implementa el mismo protocolo de bajo nivel que las declaraciones for usan en listas, tuplas, dictados, archivos, etc.","title":"6.2.2 Generadores"},{"location":"6/#623-ejercicios","text":"","title":"6.2.3 Ejercicios"},{"location":"6/#ejercicio-64-un-generador-simple","text":"Si alguna vez desea personalizar la iteraci\u00f3n, siempre debe pensar en las funciones del generador. Son f\u00e1ciles de escribir: cree una funci\u00f3n que lleve a cabo la l\u00f3gica de iteraci\u00f3n deseada y util\u00edce yield para emitir valores. Por ejemplo, pruebe este generador que busca en un archivo l\u00edneas que contengan una subcadena coincidente: >>> def filematch(filename, substr): with open(filename, 'r') as f: for line in f: if substr in line: yield line >>> for line in open('Data/portfolio.csv'): print(line, end='') name,shares,price \"AA\",100,32.20 \"IBM\",50,91.10 \"CAT\",150,83.44 \"MSFT\",200,51.23 \"GE\",95,40.37 \"MSFT\",50,65.10 \"IBM\",100,70.44 >>> for line in filematch('Data/portfolio.csv', 'IBM'): print(line, end='') \"IBM\",50,91.10 \"IBM\",100,70.44 >>> Esto es algo interesante: la idea de que puede ocultar un mont\u00f3n de procesamiento personalizado en una funci\u00f3n y usarlo para alimentar un ciclo for . El siguiente ejemplo analiza un caso m\u00e1s inusual.","title":"Ejercicio 6.4: Un generador simple"},{"location":"6/#ejercicio-65-supervision-de-una-fuente-de-datos-de-transmision","text":"Los generadores pueden ser una forma interesante de monitorear fuentes de datos en tiempo real, como archivos de registro o feeds del mercado de valores. En esta parte, exploraremos esta idea. Para comenzar, siga cuidadosamente las siguientes instrucciones. El programa Data/stocksim.pyes un programa que simula datos del mercado de valores. Como salida, el programa escribe constantemente datos en tiempo real en un archivo Data/stocklog.csv. En una ventana de comando separada, vaya al Data/directorio y ejecute este programa: bash % python3 stocksim.py Si est\u00e1 en Windows, simplemente ubique el stocksim.pyprograma y haga doble clic en \u00e9l para ejecutarlo. Ahora, olv\u00eddese de este programa (d\u00e9jelo correr). Usando otra ventana, mire el archivo que Data/stocklog.csvest\u00e1 escribiendo el simulador. Deber\u00eda ver que se agregan nuevas l\u00edneas de texto al archivo cada pocos segundos. Nuevamente, deje que este programa se ejecute en segundo plano; se ejecutar\u00e1 durante varias horas (no deber\u00eda tener que preocuparse por ello). Una vez que el programa anterior se est\u00e9 ejecutando, escribamos un peque\u00f1o programa para abrir el archivo, buscar el final y esperar una nueva salida. Cree un archivo follow.pyy coloque este c\u00f3digo en \u00e9l: # follow.py import os import time f = open('Data/stocklog.csv') f.seek(0, os.SEEK_END) # Move file pointer 0 bytes from end of file while True: line = f.readline() if line == '': time.sleep(0.1) # Sleep briefly and retry continue fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if change < 0: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Si ejecuta el programa, ver\u00e1 un indicador de cotizaci\u00f3n en tiempo real. Bajo el cap\u00f3, este c\u00f3digo es como el comando tail -f de Unix que se usa para ver un archivo de registro. Nota: El uso del m\u00e9todo readline() en este ejemplo es algo inusual en el sentido de que no es la forma habitual de leer l\u00edneas de un archivo (normalmente solo usar\u00eda un for-loop). Sin embargo, en este caso, lo estamos usando para sondear repetidamente el final del archivo para ver si se han agregado m\u00e1s datos ( readline() devolver\u00e1 nuevos datos o una cadena vac\u00eda).","title":"Ejercicio 6.5: Supervisi\u00f3n de una fuente de datos de transmisi\u00f3n"},{"location":"6/#ejercicio-66-uso-de-un-generador-para-producir-datos","text":"Si observa el c\u00f3digo del ejercicio 6.5, la primera parte del c\u00f3digo produce l\u00edneas de datos, mientras que las declaraciones al final del whileciclo consumen los datos. Una caracter\u00edstica importante de las funciones del generador es que puede mover todo el c\u00f3digo de producci\u00f3n de datos a una funci\u00f3n reutilizable. Modifique el c\u00f3digo del ejercicio 6.5 para que la lectura del archivo sea realizada por una funci\u00f3n generadora follow(filename) . Haga que funcione el siguiente c\u00f3digo: >>> for line in follow('Data/stocklog.csv'): print(line, end='') ... Deber\u00eda ver lineas de salida producidas aqu\u00ed ... Modifique el c\u00f3digo de cotizaci\u00f3n burs\u00e1til para que se vea as\u00ed: if __name__ == '__main__': for line in follow('Data/stocklog.csv'): fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if change < 0: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}')","title":"Ejercicio 6.6: uso de un generador para producir datos"},{"location":"6/#ejercicio-67-observando-tu-portafolio","text":"Modifique el programa follow.py para que observe el flujo de datos de acciones e imprima un ticker que muestre informaci\u00f3n solo para las acciones de una cartera. Por ejemplo: if __name__ == '__main__': import report portfolio = report.read_portfolio('Data/portfolio.csv') for line in follow('Data/stocklog.csv'): fields = line.split(',') name = fields[0].strip('\"') price = float(fields[1]) change = float(fields[4]) if name in portfolio: print(f'{name:>10s} {price:>10.2f} {change:>10.2f}') Nota: Para que esto funcione, su Portfolioclase debe ser compatible con el inoperador. Vea el ejercicio 6.3 y aseg\u00farese de implementar el operador __contains__() .","title":"Ejercicio 6.7: Observando tu portafolio"},{"location":"6/#discusion","text":"Algo muy poderoso acaba de ocurrir aqu\u00ed. Movi\u00f3 un patr\u00f3n de iteraci\u00f3n interesante (l\u00edneas de lectura al final de un archivo) a su propia peque\u00f1a funci\u00f3n. La funci\u00f3n follow() es ahora esta utilidad de prop\u00f3sito completamente general que puede usar en cualquier programa. Por ejemplo, puede usarlo para ver registros del servidor, registros de depuraci\u00f3n y otras fuentes de datos similares. Eso es algo genial.","title":"Discusi\u00f3n"},{"location":"6/#63-productores-consumidores-y-oleoductos","text":"Los generadores son una herramienta \u00fatil para establecer varios tipos de problemas de productores / consumidores y tuber\u00edas de flujo de datos. Esta secci\u00f3n trata sobre eso.","title":"6.3 Productores, consumidores y oleoductos"},{"location":"6/#631-problemas-entre-productores-y-consumidores","text":"Los generadores est\u00e1n estrechamente relacionados con diversas formas de problemas entre productores y consumidoress. # Producer def follow(f): ... while True: ... yield line # Produces value in `line` below ... # Consumer for line in follow(f): # Consumes value from `yield` above ... yield produce valores que for consume.","title":"6.3.1 Problemas entre productores y consumidores"},{"location":"6/#632-tuberias-de-generador","text":"Puede utilizar este aspecto de los generadores para configurar tuber\u00edas de procesamiento (como las tuber\u00edas Unix). productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor Las tuber\u00edas de procesamiento tienen un productor de datos inicial, un conjunto de etapas de procesamiento intermedias y un consumidor final. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def productor(): ... yield item ... El productor suele ser un generador. Aunque tambi\u00e9n podr\u00eda ser una lista de alguna otra secuencia. yield alimenta datos en la canalizaci\u00f3n. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def consumidor(s): for item in s: ... El consumidor es un bucle for-loop. Obtiene art\u00edculos y hace algo con ellos. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def procesando(s): for item in s: ... yield newitem ... Las etapas intermedias de procesamiento consumen y producen art\u00edculos simult\u00e1neamente. Pueden modificar el flujo de datos. Tambi\u00e9n pueden filtrar (descartar elementos). productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def productor(): ... yield item # entrega el elemento que es recibido por `procesando` ... def procesando(s): for item in s: # Viene del `productor` ... yield newitem # entrega el nuevo elemento ... def consumidor(s): for item in s: # Viene del `procesando` ... C\u00f3digo para configurar la canalizaci\u00f3n a = productor() b = procesando(a) c = consumidor(b) Notar\u00e1 que los datos fluyen gradualmente a trav\u00e9s de las diferentes funciones.","title":"6.3.2 Tuber\u00edas de generador"},{"location":"6/#634-ejercicios","text":"Para este ejercicio, el programa stocksim.py debe seguir ejecut\u00e1ndose en segundo plano. Utilizar\u00e1 la funci\u00f3n follow() que escribi\u00f3 en el ejercicio anterior.","title":"6.3.4 Ejercicios"},{"location":"6/#ejercicio-68-configurar-una-canalizacion-simple","text":"Veamos la idea de la canalizaci\u00f3n en acci\u00f3n. Escribe la siguiente funci\u00f3n: >>> def filematch(lines, substr): for line in lines: if substr in line: yield line >>> Esta funci\u00f3n es casi exactamente la misma que en el primer ejemplo de generador del ejercicio anterior, excepto que ya no abre un archivo, simplemente opera en una secuencia de l\u00edneas que se le da como argumento. Ahora, intente esto: >>> from follow import follow >>> lines = follow('Data/stocklog.csv') >>> ibm = filematch(lines, 'IBM') >>> for line in ibm: print(line) ... espera por la salida ... La salida puede tardar un poco en aparecer, pero eventualmente deber\u00eda ver algunas l\u00edneas que contienen datos para IBM.","title":"Ejercicio 6.8: Configurar una canalizaci\u00f3n simple"},{"location":"6/#ejercicio-69-configurar-una-canalizacion-mas-compleja","text":"Lleve la idea de canalizaci\u00f3n unos pasos m\u00e1s all\u00e1 realizando m\u00e1s acciones. >>> from follow import follow >>> import csv >>> lines = follow('Data/stocklog.csv') >>> rows = csv.reader(lines) >>> for row in rows: print(row) ['BA', '98.35', '6/11/2007', '09:41.07', '0.16', '98.25', '98.35', '98.31', '158148'] ['AA', '39.63', '6/11/2007', '09:41.07', '-0.03', '39.67', '39.63', '39.31', '270224'] ['XOM', '82.45', '6/11/2007', '09:41.07', '-0.23', '82.68', '82.64', '82.41', '748062'] ['PG', '62.95', '6/11/2007', '09:41.08', '-0.12', '62.80', '62.97', '62.61', '454327'] ... Bueno, eso es interesante. Lo que est\u00e1 viendo aqu\u00ed es que la salida de la funci\u00f3n follow() se ha canalizado a la funci\u00f3n csv.reader() y ahora estamos obteniendo una secuencia de filas divididas.","title":"Ejercicio 6.9: configurar una canalizaci\u00f3n m\u00e1s compleja"},{"location":"6/#ejercicio-610-creacion-de-mas-componentes-de-canalizacion","text":"Extendamos toda la idea a una tuber\u00eda m\u00e1s amplia. En un archivo separado ticker.py , comience creando una funci\u00f3n que lea un archivo CSV como lo hizo anteriormente: # ticker.py from follow import follow import csv def parse_stock_data(lines): rows = csv.reader(lines) return rows if __name__ == '__main__': lines = follow('Data/stocklog.csv') rows = parse_stock_data(lines) for row in rows: print(row) Escribe una nueva funci\u00f3n que seleccione columnas espec\u00edficas: # ticker.py ... def select_columns(rows, indices): for row in rows: yield [row[index] for index in indices] ... def parse_stock_data(lines): rows = csv.reader(lines) rows = select_columns(rows, [0, 1, 4]) return rows Ejecute su programa nuevamente. Deber\u00eda ver la salida reducida as\u00ed: ['BA', '98.35', '0.16'] ['AA', '39.63', '-0.03'] ['XOM', '82.45','-0.23'] ['PG', '62.95', '-0.12'] ... Escriba funciones generadoras que conviertan tipos de datos y cree diccionarios. Por ejemplo: ```python # ticker.py ... def convert_types(rows, types): for row in rows: yield [func(val) for func, val in zip(types, row)] def make_dicts(rows, headers): for row in rows: yield dict(zip(headers, row)) ... def parse_stock_data(lines): rows = csv.reader(lines) rows = select_columns(rows, [0, 1, 4]) rows = convert_types(rows, [str, float, float]) rows = make_dicts(rows, ['name', 'price', 'change']) return rows ... Ejecute su programa nuevamente. Ahora deber\u00eda tener un flujo de diccionarios como este: { 'name':'BA', 'price':98.35, 'change':0.16 } { 'name':'AA', 'price':39.63, 'change':-0.03 } { 'name':'XOM', 'price':82.45, 'change': -0.23 } { 'name':'PG', 'price':62.95, 'change':-0.12 } ...","title":"Ejercicio 6.10: creaci\u00f3n de m\u00e1s componentes de canalizaci\u00f3n"},{"location":"6/#ejercicio-611-filtrado-de-datos","text":"Escribe una funci\u00f3n que filtre datos. Por ejemplo: # ticker.py ... def filter_symbols(rows, names): for row in rows: if row['name'] in names: yield row Use esto para filtrar acciones solo para aquellas en su cartera: import report portfolio = report.read_portfolio('Data/portfolio.csv') rows = parse_stock_data(follow('Data/stocklog.csv')) rows = filter_symbols(rows, portfolio) for row in rows: print(row)","title":"Ejercicio 6.11: filtrado de datos"},{"location":"6/#ejercicio-612-poniendolo-todo-junto","text":"En el programa ticker.py , escriba una funci\u00f3n ticker(portfile, logfile, fmt) que cree un ticker de acciones en tiempo real a partir de un portafolio, archivo de registro y formato de tabla determinados. Por ejemplo: >>> from ticker import ticker >>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'txt') Name Price Change ---------- ---------- ---------- GE 37.14 -0.18 MSFT 29.96 -0.09 CAT 78.03 -0.49 AA 39.34 -0.32 ... >>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'csv') Name,Price,Change IBM,102.79,-0.28 CAT,78.04,-0.48 AA,39.35,-0.31 CAT,78.05,-0.47 ...","title":"Ejercicio 6.12: Poni\u00e9ndolo todo junto"},{"location":"6/#discusion_1","text":"Algunas lecciones aprendidas: puede crear varias funciones de generador y encadenarlas para realizar el procesamiento que involucre tuber\u00edas de flujo de datos. Adem\u00e1s, puede crear funciones que empaqueten una serie de etapas de canalizaci\u00f3n en una sola llamada de funci\u00f3n (por ejemplo, la funci\u00f3n parse_stock_data() ).","title":"Discusi\u00f3n"},{"location":"6/#64-expresiones-generadoras","text":"Esta secci\u00f3n presenta algunos temas adicionales relacionados con el generador, incluidas las expresiones del generador y el m\u00f3dulo itertools.","title":"6.4 Expresiones generadoras"},{"location":"6/#641-expresiones-generadoras","text":"Una versi\u00f3n generadora de una lista de comprensi\u00f3n. >>> a = [1,2,3,4] >>> b = (2*x for x in a) >>> b <generator object at 0x58760> >>> for i in b: ... print(i, end=' ') ... 2 4 6 8 >>> Diferencias con las comprensiones de listas. No construye una lista. El \u00fanico prop\u00f3sito \u00fatil es la iteraci\u00f3n. Una vez consumido, no se puede reutilizar. Sintaxis general. (<expression> for i in s if <conditional>) Tambi\u00e9n puede servir como argumento de funci\u00f3n. sum(x*x for x in a) Se puede aplicar a cualquier iterable. >>> a = [1,2,3,4] >>> b = (x*x for x in a) >>> c = (-x for x in b) >>> for i in c: ... print(i, end=' ') ... -1 -4 -9 -16 >>> El uso principal de las expresiones generadoras es el c\u00f3digo que realiza algunos c\u00e1lculos en una secuencia, pero solo usa el resultado una vez. Por ejemplo, elimine todos los comentarios de un archivo. f = open('somefile.txt') lines = (line for line in f if not line.startswith('#')) for line in lines: ... f.close() Con los generadores, el c\u00f3digo se ejecuta m\u00e1s r\u00e1pido y usa poca memoria. Es como un filtro aplicado a una corriente.","title":"6.4.1 Expresiones generadoras"},{"location":"6/#642-por-que-generadores","text":"Muchos problemas se expresan mucho m\u00e1s claramente en t\u00e9rminos de iteraci\u00f3n. Recorrer una colecci\u00f3n de elementos y realizar alg\u00fan tipo de operaci\u00f3n (buscar, reemplazar, modificar, etc.). Las canalizaciones de procesamiento se pueden aplicar a una amplia gama de problemas de procesamiento de datos. Mejor eficiencia de la memoria. Produzca valores solo cuando sea necesario. Contraste con la construcci\u00f3n de listas gigantes. Puede operar en transmisi\u00f3n de datos Los generadores fomentan la reutilizaci\u00f3n del c\u00f3digo Separa la iteraci\u00f3n del c\u00f3digo que usa la iteraci\u00f3n Puede crear una caja de herramientas de funciones de iteraci\u00f3n interesantes y mezclar y combinar .","title":"6.4.2 \u00bfPor qu\u00e9 generadores?"},{"location":"6/#643-el-modulo-itertools","text":"El itertoolses un m\u00f3dulo de biblioteca con varias funciones dise\u00f1adas para ayudar con iteradores / generadores. itertools.chain(s1,s2) itertools.count(n) itertools.cycle(s) itertools.dropwhile(predicate, s) itertools.groupby(s) itertools.ifilter(predicate, s) itertools.imap(function, s1, ... sN) itertools.repeat(s, n) itertools.tee(s, ncopies) itertools.izip(s1, ... , sN) Todas las funciones procesan datos de forma iterativa. Implementan varios tipos de patrones de iteraci\u00f3n. M\u00e1s informaci\u00f3n en el tutorial de Trucos de generador para programadores de sistemas de PyCon '08.","title":"6.4.3 El m\u00f3dulo itertools"},{"location":"6/#644-ejercicios","text":"En los ejercicios anteriores, escribi\u00f3 un c\u00f3digo que sigui\u00f3 a las l\u00edneas que se escribieron en un archivo de registro y las analiz\u00f3 en una secuencia de filas. Este ejercicio contin\u00faa bas\u00e1ndose en eso. Aseg\u00farese de que Data/stocksim.py a\u00fan se est\u00e9 ejecutando.","title":"6.4.4 Ejercicios"},{"location":"6/#ejercicio-613-expresiones-generadoras","text":"Las expresiones generadoras son una versi\u00f3n generadora de una lista de comprensi\u00f3n. Por ejemplo: >>> nums = [1, 2, 3, 4, 5] >>> squares = (x*x for x in nums) >>> squares <generator object <genexpr> at 0x109207e60> >>> for n in squares: ... print(n) ... 1 4 9 16 25 A diferencia de una lista de comprensi\u00f3n, una expresi\u00f3n generadora solo se puede usar una vez. Por lo tanto, si prueba otro ciclo for, no obtiene nada: >>> for n in squares: ... print(n) ... >>>","title":"Ejercicio 6.13: Expresiones generadoras"},{"location":"6/#ejercicio-614-expresiones-generadoras-en-argumentos-de-funciones","text":"Las expresiones generadoras a veces se colocan en argumentos de funci\u00f3n. Parece un poco extra\u00f1o al principio, pero prueba este experimento: >>> nums = [1,2,3,4,5] >>> sum([x*x for x in nums]) # comprension de lista 55 >>> sum(x*x for x in nums) # una expresi\u00f3n generadora 55 >>> En el ejemplo anterior, la segunda versi\u00f3n que usa generadores usar\u00eda significativamente menos memoria si se manipulara una lista grande. En su portfolio.pyarchivo, realiz\u00f3 algunos c\u00e1lculos relacionados con listas por comprensi\u00f3n. Intente reemplazarlos con expresiones generadoras.","title":"Ejercicio 6.14: Expresiones generadoras en argumentos de funciones"},{"location":"6/#ejercicio-615-simplificacion-de-codigo","text":"Las expresiones de generadores son a menudo un reemplazo \u00fatil para las funciones de peque\u00f1os generadores. Por ejemplo, en lugar de escribir una funci\u00f3n como esta: def filter_symbols(rows, names): for row in rows: if row['name'] in names: yield row Podr\u00edas escribir algo como esto: rows = (row for row in rows if row['name'] in names) Modifique el programa ticker.py para usar expresiones generadoras seg\u00fan corresponda.","title":"Ejercicio 6.15: simplificaci\u00f3n de c\u00f3digo"},{"location":"7/","text":"7. Temas Avanzados En esta secci\u00f3n, veremos una peque\u00f1a colecci\u00f3n de algunas caracter\u00edsticas avanzadas de Python que posiblemente encontremos en nuestra programaci\u00f3n cotidiana. Los temas en esta secci\u00f3n son s\u00f3lo una introducci\u00f3n a estas ideas. 7.1 Argumentos variables Esta secci\u00f3n cubre los argumentos de funciones variadas, a veces descritos como argsy *kwargs. 7.1.1 Argumentos de variables posicionales ( *args ) Se dice que una funci\u00f3n que acepta cualquier n\u00famero de argumentos usa argumentos variables. Por ejemplo: def f(x, *args): ... Llamada de funci\u00f3n. f(1,2,3,4,5) Los argumentos adicionales se pasan como una tupla. def f(x, *args): # x -> 1 # args -> (2,3,4,5) 7.1.2 Argumentos de variables de palabra clave ( **kwargs ) Una funci\u00f3n tambi\u00e9n puede aceptar cualquier n\u00famero de argumentos de palabras clave. Por ejemplo: def f(x, y, **kwargs): ... Llamada de funci\u00f3n. f(2, 3, flag=True, mode='fast', header='debug') Las palabras clave adicionales se pasan en un diccionario. def f(x, y, **kwargs): # x -> 2 # y -> 3 # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' } 7.1.3 Combinando ambos Una funci\u00f3n tambi\u00e9n puede aceptar cualquier n\u00famero de argumentos variables de palabras clave y no palabras clave. def f(*args, **kwargs): ... Llamada de funci\u00f3n. f(2, 3, flag=True, mode='fast', header='debug') Los argumentos se separan en componentes posicionales y de palabras clave def f(*args, **kwargs): # args = (2, 3) # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' } ... Esta funci\u00f3n toma cualquier combinaci\u00f3n de argumentos posicionales o de palabras clave. A veces se usa al escribir envoltorios o cuando desea pasar argumentos a otra funci\u00f3n. 7.1.4 Pasar tuplas y dictados Las tuplas se pueden expandir en argumentos variables. numbers = (2,3,4) f(1, *numbers) # Same as f(1,2,3,4) Los diccionarios tambi\u00e9n se pueden expandir a argumentos de palabras clave. options = { 'color' : 'red', 'delimiter' : ',', 'width' : 400 } f(data, **options) # Same as f(data, color='red', delimiter=',', width=400) 7.1.5 Ejercicios Ejercicio 7.1: un ejemplo simple de argumentos variables Intente definir la siguiente funci\u00f3n: >>> def avg(x,*more): return float(x+sum(more))/(1+len(more)) >>> avg(10,11) 10.5 >>> avg(3,4,5) 4.0 >>> avg(1,2,3,4,5,6) 3.5 >>> Observe c\u00f3mo el par\u00e1metro *morerecopila todos los argumentos adicionales. Ejercicio 7.2: Pasar tuplas y dictados como argumentos Suponga que lee algunos datos de un archivo y obtiene una tupla como esta: >>> data = ('GOOG', 100, 490.1) >>> Ahora, suponga que desea crear un objeto Stock a partir de estos datos. Si intenta pasar data directamente, no funciona: >>> from stock import Stock >>> s = Stock(data) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: __init__() takes exactly 4 arguments (2 given) >>> Esto se soluciona f\u00e1cilmente usando *data en su lugar. Prueba esto: >>> s = Stock(*data) >>> s Stock('GOOG', 100, 490.1) >>> Si tiene un diccionario, puede utilizar ** en su lugar. Por ejemplo: >>> data = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } >>> s = Stock(**data) Stock('GOOG', 100, 490.1) >>> Ejercicio 7.3: Crear una lista de instancias En su programa report.py , cre\u00f3 una lista de instancias usando un c\u00f3digo como este: def read_portfolio(filename): ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float]) portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ] return Portfolio(portfolio) Puede simplificar ese c\u00f3digo usando Stock(**d) . Haz ese cambio. Ejercicio 7.4: Transferencia de argumentos La funci\u00f3n fileparse.parse_csv() tiene algunas opciones para cambiar el delimitador de archivos y para informar de errores. Tal vez le gustar\u00eda exponer esas opciones a la funci\u00f3n read_portfolio() anterior. Haz este cambio: def read_portfolio(filename, **opts): ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) portfolio = [ Stock(**d) for d in portdicts ] return Portfolio(portfolio) Una vez que haya realizado el cambio, intente leer un archivo con algunos errores: >>> import report >>> port = report.read_portfolio('Data/missing.csv') Row 4: Couldn't convert ['MSFT', '', '51.23'] Row 4: Reason invalid literal for int() with base 10: '' Row 7: Couldn't convert ['IBM', '', '70.44'] Row 7: Reason invalid literal for int() with base 10: '' >>> Ahora, intente silenciar los errores: >>> import report >>> port = report.read_portfolio('Data/missing.csv', silence_errors=True) >>> 7.2 Funciones an\u00f3nimas y lambda 7.2.1 Clasificaci\u00f3n de listas revisada Las listas se pueden ordenar in situ . Usando el sortm\u00e9todo. s = [10,1,7,3] s.sort() # s = [1,3,7,10] Puede ordenar en orden inverso. s = [10,1,7,3] s.sort(reverse=True) # s = [10,7,3,1] Parece bastante simple. Sin embargo, \u00bfc\u00f3mo ordenamos una lista de dictados? [{'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'MSFT', 'price': 65.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}] \u00bfCon qu\u00e9 criterios? Puede guiar la clasificaci\u00f3n utilizando una funci\u00f3n clave . La funci\u00f3n clave es una funci\u00f3n que recibe el diccionario y devuelve el valor de inter\u00e9s para ordenar. def stock_name(s): return s['name'] portfolio.sort(key=stock_name) Aqu\u00ed est\u00e1 el resultado. # Check how the dictionaries are sorted by the `name` key [ {'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'MSFT', 'price': 65.1, 'shares': 50} ] 7.2.2 Funciones de devoluci\u00f3n de llamada En el ejemplo anterior, la funci\u00f3n de tecla es un ejemplo de funci\u00f3n de devoluci\u00f3n de llamada. El m\u00e9todo sort() \"vuelve a llamar\" a una funci\u00f3n que usted proporciona. Las funciones de devoluci\u00f3n de llamada suelen ser funciones breves de una l\u00ednea que solo se utilizan para esa operaci\u00f3n. Los programadores a menudo piden un atajo para especificar este procesamiento adicional. 7.2.3 Lambda: funciones an\u00f3nimas Utilice una lambda en lugar de crear la funci\u00f3n. En nuestro ejemplo de clasificaci\u00f3n anterior. portfolio.sort(key=lambda s: s['name']) Esto crea una funci\u00f3n sin nombre que eval\u00faa una sola expresi\u00f3n. El c\u00f3digo anterior es mucho m\u00e1s corto que el c\u00f3digo inicial. def stock_name(s): return s['name'] portfolio.sort(key=stock_name) # vs lambda portfolio.sort(key=lambda s: s['name']) 7.2.4 Usando lambda lambda est\u00e1 muy restringido. Solo se permite una expresi\u00f3n. No hay declaraciones como if, while, etc. El uso m\u00e1s com\u00fan es con funciones como sort(). 7.2.5 Ejercicios Lea algunos datos de la cartera de acciones y convi\u00e9rtalos en una lista: >>> import report >>> portfolio = list(report.read_portfolio('Data/portfolio.csv')) >>> for s in portfolio: print(s) Stock('AA', 100, 32.2) Stock('IBM', 50, 91.1) Stock('CAT', 150, 83.44) Stock('MSFT', 200, 51.23) Stock('GE', 95, 40.37) Stock('MSFT', 50, 65.1) Stock('IBM', 100, 70.44) >>> Ejercicio 7.5: ordenar en un campo Pruebe las siguientes afirmaciones que ordenan los datos de la cartera alfab\u00e9ticamente por nombre de la acci\u00f3n. >>> def stock_name(s): return s.name >>> portfolio.sort(key=stock_name) >>> for s in portfolio: print(s) ... inspeccione los resultados ... >>> En esta parte, la stock_name()funci\u00f3n extrae el nombre de una acci\u00f3n de una sola entrada en la portfoliolista. sort() usa el resultado de esta funci\u00f3n para hacer la comparaci\u00f3n. Ejercicio 7.6: ordenar en un campo con lambda Intente ordenar la cartera de acuerdo con la cantidad de acciones usando una lambdaexpresi\u00f3n: >>> portfolio.sort(key=lambda s: s.shares) >>> for s in portfolio: print(s) ... inspeccione los resultados ... >>> Intente ordenar la cartera seg\u00fan el precio de cada acci\u00f3n >>> portfolio.sort(key=lambda s: s.price) >>> for s in portfolio: print(s) ... inspeccione los resultados ... >>> Nota: lambdaes un atajo \u00fatil porque le permite definir una funci\u00f3n de procesamiento especial directamente en la llamada a sort() en lugar de tener que definir primero una funci\u00f3n separada. 7.3 Funci\u00f3n de retorno y cierres Esta secci\u00f3n presenta la idea de usar funciones para crear otras funciones. 7.3.1 Introducci\u00f3n Considere la siguiente funci\u00f3n. def add(x, y): def do_add(): print('Adding', x, y) return x + y return do_add Esta es una funci\u00f3n que devuelve otra funci\u00f3n. >>> a = add(3,4) >>> a <function do_add at 0x6a670> >>> a() Adding 3 4 7 7.3.2 Variables locales Observe c\u00f3mo la funci\u00f3n interna se refiere a variables definidas por la funci\u00f3n externa. def add(x, y): def do_add(): # `x` and `y` are defined above `add(x, y)` print('Adding', x, y) return x + y return do_add Observe adem\u00e1s que esas variables se mantienen vivas de alguna manera despu\u00e9s de que add()ha terminado. >>> a = add(3,4) >>> a <function do_add at 0x6a670> >>> a() Adding 3 4 # Where are these values coming from? 7 7.3.3 Cierres Cuando se devuelve una funci\u00f3n interna como resultado, esa funci\u00f3n interna se conoce como cierre . def add(x, y): # `do_add` is a closure def do_add(): print('Adding', x, y) return x + y return do_add Caracter\u00edstica esencial: un cierre conserva los valores de todas las variables necesarias para que la funci\u00f3n se ejecute correctamente m\u00e1s adelante. Piense en un cierre como una funci\u00f3n m\u00e1s un entorno adicional que contiene los valores de las variables de las que depende. 7.3.4 Usando cierres El cierre es una caracter\u00edstica esencial de Python. Sin embargo, su uso suele ser sutil. Aplicaciones habituales: Utilizar en funciones de devoluci\u00f3n de llamada. Evaluaci\u00f3n retrasada. Funciones de decorador (m\u00e1s tarde). 7.3.5 Evaluaci\u00f3n retrasada Considere una funci\u00f3n como esta: def after(seconds, func): import time time.sleep(seconds) func() Ejemplo de uso: def greeting(): print('Hello Guido') after(30, greeting) after ejecuta la funci\u00f3n proporcionada m\u00e1s tarde. Los cierres llevan informaci\u00f3n adicional. def add(x, y): def do_add(): print(f'Adding {x} + {y} -> {x+y}') return do_add def after(seconds, func): import time time.sleep(seconds) func() after(30, add(2, 3)) # `do_add` has the references x -> 2 and y -> 3 7.3.6 Repetici\u00f3n de c\u00f3digo Los cierres tambi\u00e9n se pueden utilizar como t\u00e9cnica para evitar la repetici\u00f3n excesiva de c\u00f3digo. Puede escribir funciones que hacen c\u00f3digo. 7.3.7 Ejercicios Ejercicio 7.7: Uso de cierres para evitar la repetici\u00f3n Una de las caracter\u00edsticas m\u00e1s poderosas de los cierres es su uso para generar c\u00f3digo repetitivo. Si vuelve a consultar el ejercicio 5.7 , recuerde el c\u00f3digo para definir una propiedad con verificaci\u00f3n de tipos. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price ... @property def shares(self): return self._shares @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Expected int') self._shares = value ... En lugar de escribir ese c\u00f3digo repetidamente una y otra vez, puede crearlo autom\u00e1ticamente usando un cierre. Haga un archivo typedproperty.pyy coloque el siguiente c\u00f3digo en \u00e9l: # typedproperty.py def typedproperty(name, expected_type): private_name = '_' + name @property def prop(self): return getattr(self, private_name) @prop.setter def prop(self, value): if not isinstance(value, expected_type): raise TypeError(f'Expected {expected_type}') setattr(self, private_name, value) return prop Ahora, pru\u00e9belo definiendo una clase como esta: from typedproperty import typedproperty class Stock: name = typedproperty('name', str) shares = typedproperty('shares', int) price = typedproperty('price', float) def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Intente crear una instancia y verificar que la verificaci\u00f3n de tipos funcione. >>> s = Stock('IBM', 50, 91.1) >>> s.name 'IBM' >>> s.shares = '100' ... should get a TypeError ... >>> Ejercicio 7.8: Simplificaci\u00f3n de llamadas a funciones En el ejemplo anterior, los usuarios pueden encontrar llamadas typedproperty('shares', int)un poco detalladas para escribir, especialmente si se repiten mucho. Agregue las siguientes definiciones al typedproperty.pyarchivo: String = lambda name: typedproperty(name, str) Integer = lambda name: typedproperty(name, int) Float = lambda name: typedproperty(name, float) Ahora, reescribe la Stockclase para usar estas funciones en su lugar: class Stock: name = String('name') shares = Integer('shares') price = Float('price') def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Ah, eso es un poco mejor. La principal conclusi\u00f3n aqu\u00ed es que los cierres y lambda, a menudo, se pueden usar para simplificar el c\u00f3digo y eliminar la repetici\u00f3n molesta. Suele ser bueno. Ejercicio 7.9: Poni\u00e9ndolo en pr\u00e1ctica Vuelva a escribir la clase Stock en el archivo stock.py para que utilice propiedades escritas como se muestra. 7.4 Decoradores de funciones Esta secci\u00f3n presenta el concepto de decorador. Este es un tema avanzado para el que solo ara\u00f1amos la superficie. 7.4.1 Ejemplo de registro Considere una funci\u00f3n. def add(x, y): return x + y Ahora, considere la funci\u00f3n con algunos registros agregados. def add(x, y): print('Calling add') return x + y Ahora una segunda funci\u00f3n tambi\u00e9n con algunos registros. def sub(x, y): print('Calling sub') return x - y 7.4.2 Observaci\u00f3n Observaci\u00f3n: es algo repetitivo. Escribir programas donde hay mucha replicaci\u00f3n de c\u00f3digo a menudo es realmente molesto. Son tediosos de escribir y dif\u00edciles de mantener. Especialmente si decide que desea cambiar c\u00f3mo funciona (es decir, quiz\u00e1s un tipo diferente de registro). 7.4.3 C\u00f3digo que hace el registro Quiz\u00e1s pueda crear una funci\u00f3n que haga funciones con registro agregado a ellas. Una envoltura. def logged(func): def wrapper(*args, **kwargs): print('Calling', func.__name__) return func(*args, **kwargs) return wrapper Ahora \u00fasalo. def add(x, y): return x + y logged_add = logged(add) \u00bfQu\u00e9 sucede cuando llamas a la funci\u00f3n devuelta por logged? logged_add(3, 4) # Usted ve que el mensaje aparece Este ejemplo ilustra el proceso de creaci\u00f3n de la denominada funci\u00f3n contenedora . Una envoltura es una funci\u00f3n que envuelve otra funci\u00f3n con algunos bits adicionales de procesamiento, pero por lo dem\u00e1s funciona exactamente de la misma manera que la funci\u00f3n original. >>> logged_add(3, 4) Calling add # Extra output. Added by the wrapper 7 >>> Nota: La logged() funci\u00f3n crea el contenedor y lo devuelve como resultado. 7.4.4 Decoradores Poner envoltorios alrededor de funciones es extremadamente com\u00fan en Python. Tan com\u00fan que tiene una sintaxis especial. def add(x, y): return x + y add = logged(add) # Sintaxis especial @logged def add(x, y): return x + y La sintaxis especial realiza exactamente los mismos pasos que se muestran arriba. Un decorador es solo una nueva sintaxis. Se dice que decora la funci\u00f3n. Comentario Hay muchos m\u00e1s detalles sutiles para los decoradores de los que se han presentado aqu\u00ed. Por ejemplo, us\u00e1ndolos en clases. O usando m\u00faltiples decoradores con una funci\u00f3n. Sin embargo, el ejemplo anterior es una buena ilustraci\u00f3n de c\u00f3mo tiende a surgir su uso. Por lo general, es en respuesta al c\u00f3digo repetitivo que aparece en una amplia gama de definiciones de funciones. Un decorador puede mover ese c\u00f3digo a una definici\u00f3n central. 7.4.5 Ejercicios Ejercicio 7.10: un decorador de tiempos Si define una funci\u00f3n, su nombre y m\u00f3dulo se almacenan en los atributos __name__ y __module__ . Por ejemplo: >>> def add(x,y): return x+y >>> add.__name__ 'add' >>> add.__module__ '__main__' >>> En un archivo timethis.py , escriba una funci\u00f3n decoradora timethis(func) que envuelva una funci\u00f3n con una capa adicional de l\u00f3gica que imprima cu\u00e1nto tarda en ejecutarse una funci\u00f3n. Para hacer esto, rodear\u00e1 la funci\u00f3n con llamadas de tiempo como esta: start = time.time() r = func(*args,**kwargs) end = time.time() print('%s.%s: %f' % (func.__module__, func.__name__, end-start)) Aqu\u00ed tienes un ejemplo de c\u00f3mo deber\u00eda funcionar tu decorador: >>> from timethis import timethis >>> @timethis def countdown(n): while n > 0: n -= 1 >>> countdown(10000000) __main__.countdown : 0.076562 >>> Discusi\u00f3n: Este decorador @timethis se puede colocar delante de cualquier definici\u00f3n de funci\u00f3n. Por lo tanto, puede usarlo como una herramienta de diagn\u00f3stico para ajustar el rendimiento. 7.5 M\u00e9todos est\u00e1ticos y de clase En esta secci\u00f3n se analizan algunos decoradores integrados que se utilizan en combinaci\u00f3n con definiciones de m\u00e9todos. 7.5.1 Decoradores predefinidos Hay decoradores predefinidos que se utilizan para especificar tipos especiales de m\u00e9todos en las definiciones de clases. class Foo: def bar(self,a): ... @staticmethod def spam(a): ... @classmethod def grok(cls,a): ... @property def name(self): ... Vayamos uno por uno. 7.5.2 M\u00e9todos est\u00e1ticos @staticmethod se utiliza para definir los llamados m\u00e9todos de clase est\u00e1tica (de C ++ / Java). Un m\u00e9todo est\u00e1tico es una funci\u00f3n que forma parte de la clase, pero que no opera en instancias. class Foo(object): @staticmethod def bar(x): print('x =', x) >>> Foo.bar(2) x=2 >>> Los m\u00e9todos est\u00e1ticos se utilizan a veces para implementar c\u00f3digo de soporte interno para una clase. Por ejemplo, c\u00f3digo para ayudar a administrar las instancias creadas (administraci\u00f3n de memoria, recursos del sistema, persistencia, bloqueo, etc.). Tambi\u00e9n son utilizados por ciertos patrones de dise\u00f1o (no discutidos aqu\u00ed). 7.5.3 M\u00e9todos de clase @classmethod se utiliza para definir m\u00e9todos de clase. Un m\u00e9todo de clase es un m\u00e9todo que recibe el objeto de clase como primer par\u00e1metro en lugar de la instancia. class Foo: def bar(self): print(self) @classmethod def spam(cls): print(cls) >>> f = Foo() >>> f.bar() <__main__.Foo object at 0x971690> # La instancia `f` >>> Foo.spam() <class '__main__.Foo'> # La clase `Foo` >>> Los m\u00e9todos de clase se utilizan con mayor frecuencia como una herramienta para definir constructores alternativos. class Date: def __init__(self,year,month,day): self.year = year self.month = month self.day = day @classmethod def today(cls): # Notice how the class is passed as an argument tm = time.localtime() # And used to create a new instance return cls(tm.tm_year, tm.tm_mon, tm.tm_mday) d = Date.today() Los m\u00e9todos de clase resuelven algunos problemas complicados con caracter\u00edsticas como la herencia. class Date: ... @classmethod def today(cls): # Gets the correct class (e.g. `NewDate`) tm = time.localtime() return cls(tm.tm_year, tm.tm_mon, tm.tm_mday) class NewDate(Date): ... d = NewDate.today() 7.5.4 Ejercicios Ejercicio 7.11: M\u00e9todos de clase en la pr\u00e1ctica En sus archivos report.py y portfolio.py , la creaci\u00f3n de un objeto Portfolio es un poco confusa. Por ejemplo, el programa report.py tiene un c\u00f3digo como este: def read_portfolio(filename, **opts): ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) portfolio = [ Stock(**d) for d in portdicts ] return Portfolio(portfolio) y el archivo portfolio.py se define Portfolio() con un inicializador extra\u00f1o como este: class Portfolio: def __init__(self, holdings): self.holdings = holdings ... Francamente, la cadena de responsabilidad es un poco confusa porque el c\u00f3digo est\u00e1 disperso. Si Portfolio se supone que una clase contiene una lista de instancias Stock , tal vez deber\u00eda cambiar la clase para que sea un poco m\u00e1s clara. Me gusta esto: # portfolio.py import stock class Portfolio: def __init__(self): self.holdings = [] def append(self, holding): if not isinstance(holding, stock.Stock): raise TypeError('Expected a Stock instance') self.holdings.append(holding) ... Si desea leer un portafolio de un archivo CSV, tal vez deber\u00eda crear un m\u00e9todo de clase para \u00e9l: # portfolio.py import fileparse import stock class Portfolio: def __init__(self): self.holdings = [] def append(self, holding): if not isinstance(holding, stock.Stock): raise TypeError('Expected a Stock instance') self.holdings.append(holding) @classmethod def from_csv(cls, lines, **opts): self = cls() portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) for d in portdicts: self.append(stock.Stock(**d)) return self Para usar esta nueva clase Portfolio , ahora puede escribir c\u00f3digo como este: >>> from portfolio import Portfolio >>> with open('Data/portfolio.csv') as lines: ... port = Portfolio.from_csv(lines) ... >>> Realice estos cambios en la clase Portfolio y modifique el c\u00f3digo report.py para usar el m\u00e9todo de la clase.","title":"7 Temas avanzados"},{"location":"7/#7-temas-avanzados","text":"En esta secci\u00f3n, veremos una peque\u00f1a colecci\u00f3n de algunas caracter\u00edsticas avanzadas de Python que posiblemente encontremos en nuestra programaci\u00f3n cotidiana. Los temas en esta secci\u00f3n son s\u00f3lo una introducci\u00f3n a estas ideas.","title":"7. Temas Avanzados"},{"location":"7/#71-argumentos-variables","text":"Esta secci\u00f3n cubre los argumentos de funciones variadas, a veces descritos como argsy *kwargs.","title":"7.1 Argumentos variables"},{"location":"7/#711-argumentos-de-variables-posicionales-args","text":"Se dice que una funci\u00f3n que acepta cualquier n\u00famero de argumentos usa argumentos variables. Por ejemplo: def f(x, *args): ... Llamada de funci\u00f3n. f(1,2,3,4,5) Los argumentos adicionales se pasan como una tupla. def f(x, *args): # x -> 1 # args -> (2,3,4,5)","title":"7.1.1 Argumentos de variables posicionales (*args)"},{"location":"7/#712-argumentos-de-variables-de-palabra-clave-kwargs","text":"Una funci\u00f3n tambi\u00e9n puede aceptar cualquier n\u00famero de argumentos de palabras clave. Por ejemplo: def f(x, y, **kwargs): ... Llamada de funci\u00f3n. f(2, 3, flag=True, mode='fast', header='debug') Las palabras clave adicionales se pasan en un diccionario. def f(x, y, **kwargs): # x -> 2 # y -> 3 # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' }","title":"7.1.2 Argumentos de variables de palabra clave (**kwargs)"},{"location":"7/#713-combinando-ambos","text":"Una funci\u00f3n tambi\u00e9n puede aceptar cualquier n\u00famero de argumentos variables de palabras clave y no palabras clave. def f(*args, **kwargs): ... Llamada de funci\u00f3n. f(2, 3, flag=True, mode='fast', header='debug') Los argumentos se separan en componentes posicionales y de palabras clave def f(*args, **kwargs): # args = (2, 3) # kwargs -> { 'flag': True, 'mode': 'fast', 'header': 'debug' } ... Esta funci\u00f3n toma cualquier combinaci\u00f3n de argumentos posicionales o de palabras clave. A veces se usa al escribir envoltorios o cuando desea pasar argumentos a otra funci\u00f3n.","title":"7.1.3 Combinando ambos"},{"location":"7/#714-pasar-tuplas-y-dictados","text":"Las tuplas se pueden expandir en argumentos variables. numbers = (2,3,4) f(1, *numbers) # Same as f(1,2,3,4) Los diccionarios tambi\u00e9n se pueden expandir a argumentos de palabras clave. options = { 'color' : 'red', 'delimiter' : ',', 'width' : 400 } f(data, **options) # Same as f(data, color='red', delimiter=',', width=400)","title":"7.1.4 Pasar tuplas y dictados"},{"location":"7/#715-ejercicios","text":"","title":"7.1.5 Ejercicios"},{"location":"7/#ejercicio-71-un-ejemplo-simple-de-argumentos-variables","text":"Intente definir la siguiente funci\u00f3n: >>> def avg(x,*more): return float(x+sum(more))/(1+len(more)) >>> avg(10,11) 10.5 >>> avg(3,4,5) 4.0 >>> avg(1,2,3,4,5,6) 3.5 >>> Observe c\u00f3mo el par\u00e1metro *morerecopila todos los argumentos adicionales.","title":"Ejercicio 7.1: un ejemplo simple de argumentos variables"},{"location":"7/#ejercicio-72-pasar-tuplas-y-dictados-como-argumentos","text":"Suponga que lee algunos datos de un archivo y obtiene una tupla como esta: >>> data = ('GOOG', 100, 490.1) >>> Ahora, suponga que desea crear un objeto Stock a partir de estos datos. Si intenta pasar data directamente, no funciona: >>> from stock import Stock >>> s = Stock(data) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: __init__() takes exactly 4 arguments (2 given) >>> Esto se soluciona f\u00e1cilmente usando *data en su lugar. Prueba esto: >>> s = Stock(*data) >>> s Stock('GOOG', 100, 490.1) >>> Si tiene un diccionario, puede utilizar ** en su lugar. Por ejemplo: >>> data = { 'name': 'GOOG', 'shares': 100, 'price': 490.1 } >>> s = Stock(**data) Stock('GOOG', 100, 490.1) >>>","title":"Ejercicio 7.2: Pasar tuplas y dictados como argumentos"},{"location":"7/#ejercicio-73-crear-una-lista-de-instancias","text":"En su programa report.py , cre\u00f3 una lista de instancias usando un c\u00f3digo como este: def read_portfolio(filename): ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float]) portfolio = [ Stock(d['name'], d['shares'], d['price']) for d in portdicts ] return Portfolio(portfolio) Puede simplificar ese c\u00f3digo usando Stock(**d) . Haz ese cambio.","title":"Ejercicio 7.3: Crear una lista de instancias"},{"location":"7/#ejercicio-74-transferencia-de-argumentos","text":"La funci\u00f3n fileparse.parse_csv() tiene algunas opciones para cambiar el delimitador de archivos y para informar de errores. Tal vez le gustar\u00eda exponer esas opciones a la funci\u00f3n read_portfolio() anterior. Haz este cambio: def read_portfolio(filename, **opts): ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) portfolio = [ Stock(**d) for d in portdicts ] return Portfolio(portfolio) Una vez que haya realizado el cambio, intente leer un archivo con algunos errores: >>> import report >>> port = report.read_portfolio('Data/missing.csv') Row 4: Couldn't convert ['MSFT', '', '51.23'] Row 4: Reason invalid literal for int() with base 10: '' Row 7: Couldn't convert ['IBM', '', '70.44'] Row 7: Reason invalid literal for int() with base 10: '' >>> Ahora, intente silenciar los errores: >>> import report >>> port = report.read_portfolio('Data/missing.csv', silence_errors=True) >>>","title":"Ejercicio 7.4: Transferencia de argumentos"},{"location":"7/#72-funciones-anonimas-y-lambda","text":"","title":"7.2 Funciones an\u00f3nimas y lambda"},{"location":"7/#721-clasificacion-de-listas-revisada","text":"Las listas se pueden ordenar in situ . Usando el sortm\u00e9todo. s = [10,1,7,3] s.sort() # s = [1,3,7,10] Puede ordenar en orden inverso. s = [10,1,7,3] s.sort(reverse=True) # s = [10,7,3,1] Parece bastante simple. Sin embargo, \u00bfc\u00f3mo ordenamos una lista de dictados? [{'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'MSFT', 'price': 65.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}] \u00bfCon qu\u00e9 criterios? Puede guiar la clasificaci\u00f3n utilizando una funci\u00f3n clave . La funci\u00f3n clave es una funci\u00f3n que recibe el diccionario y devuelve el valor de inter\u00e9s para ordenar. def stock_name(s): return s['name'] portfolio.sort(key=stock_name) Aqu\u00ed est\u00e1 el resultado. # Check how the dictionaries are sorted by the `name` key [ {'name': 'AA', 'price': 32.2, 'shares': 100}, {'name': 'CAT', 'price': 83.44, 'shares': 150}, {'name': 'GE', 'price': 40.37, 'shares': 95}, {'name': 'IBM', 'price': 91.1, 'shares': 50}, {'name': 'IBM', 'price': 70.44, 'shares': 100}, {'name': 'MSFT', 'price': 51.23, 'shares': 200}, {'name': 'MSFT', 'price': 65.1, 'shares': 50} ]","title":"7.2.1 Clasificaci\u00f3n de listas revisada"},{"location":"7/#722-funciones-de-devolucion-de-llamada","text":"En el ejemplo anterior, la funci\u00f3n de tecla es un ejemplo de funci\u00f3n de devoluci\u00f3n de llamada. El m\u00e9todo sort() \"vuelve a llamar\" a una funci\u00f3n que usted proporciona. Las funciones de devoluci\u00f3n de llamada suelen ser funciones breves de una l\u00ednea que solo se utilizan para esa operaci\u00f3n. Los programadores a menudo piden un atajo para especificar este procesamiento adicional.","title":"7.2.2 Funciones de devoluci\u00f3n de llamada"},{"location":"7/#723-lambda-funciones-anonimas","text":"Utilice una lambda en lugar de crear la funci\u00f3n. En nuestro ejemplo de clasificaci\u00f3n anterior. portfolio.sort(key=lambda s: s['name']) Esto crea una funci\u00f3n sin nombre que eval\u00faa una sola expresi\u00f3n. El c\u00f3digo anterior es mucho m\u00e1s corto que el c\u00f3digo inicial. def stock_name(s): return s['name'] portfolio.sort(key=stock_name) # vs lambda portfolio.sort(key=lambda s: s['name'])","title":"7.2.3 Lambda: funciones an\u00f3nimas"},{"location":"7/#724-usando-lambda","text":"lambda est\u00e1 muy restringido. Solo se permite una expresi\u00f3n. No hay declaraciones como if, while, etc. El uso m\u00e1s com\u00fan es con funciones como sort().","title":"7.2.4 Usando lambda"},{"location":"7/#725-ejercicios","text":"Lea algunos datos de la cartera de acciones y convi\u00e9rtalos en una lista: >>> import report >>> portfolio = list(report.read_portfolio('Data/portfolio.csv')) >>> for s in portfolio: print(s) Stock('AA', 100, 32.2) Stock('IBM', 50, 91.1) Stock('CAT', 150, 83.44) Stock('MSFT', 200, 51.23) Stock('GE', 95, 40.37) Stock('MSFT', 50, 65.1) Stock('IBM', 100, 70.44) >>>","title":"7.2.5 Ejercicios"},{"location":"7/#ejercicio-75-ordenar-en-un-campo","text":"Pruebe las siguientes afirmaciones que ordenan los datos de la cartera alfab\u00e9ticamente por nombre de la acci\u00f3n. >>> def stock_name(s): return s.name >>> portfolio.sort(key=stock_name) >>> for s in portfolio: print(s) ... inspeccione los resultados ... >>> En esta parte, la stock_name()funci\u00f3n extrae el nombre de una acci\u00f3n de una sola entrada en la portfoliolista. sort() usa el resultado de esta funci\u00f3n para hacer la comparaci\u00f3n.","title":"Ejercicio 7.5: ordenar en un campo"},{"location":"7/#ejercicio-76-ordenar-en-un-campo-con-lambda","text":"Intente ordenar la cartera de acuerdo con la cantidad de acciones usando una lambdaexpresi\u00f3n: >>> portfolio.sort(key=lambda s: s.shares) >>> for s in portfolio: print(s) ... inspeccione los resultados ... >>> Intente ordenar la cartera seg\u00fan el precio de cada acci\u00f3n >>> portfolio.sort(key=lambda s: s.price) >>> for s in portfolio: print(s) ... inspeccione los resultados ... >>> Nota: lambdaes un atajo \u00fatil porque le permite definir una funci\u00f3n de procesamiento especial directamente en la llamada a sort() en lugar de tener que definir primero una funci\u00f3n separada.","title":"Ejercicio 7.6: ordenar en un campo con lambda"},{"location":"7/#73-funcion-de-retorno-y-cierres","text":"Esta secci\u00f3n presenta la idea de usar funciones para crear otras funciones.","title":"7.3 Funci\u00f3n de retorno y cierres"},{"location":"7/#731-introduccion","text":"Considere la siguiente funci\u00f3n. def add(x, y): def do_add(): print('Adding', x, y) return x + y return do_add Esta es una funci\u00f3n que devuelve otra funci\u00f3n. >>> a = add(3,4) >>> a <function do_add at 0x6a670> >>> a() Adding 3 4 7","title":"7.3.1 Introducci\u00f3n"},{"location":"7/#732-variables-locales","text":"Observe c\u00f3mo la funci\u00f3n interna se refiere a variables definidas por la funci\u00f3n externa. def add(x, y): def do_add(): # `x` and `y` are defined above `add(x, y)` print('Adding', x, y) return x + y return do_add Observe adem\u00e1s que esas variables se mantienen vivas de alguna manera despu\u00e9s de que add()ha terminado. >>> a = add(3,4) >>> a <function do_add at 0x6a670> >>> a() Adding 3 4 # Where are these values coming from? 7","title":"7.3.2 Variables locales"},{"location":"7/#733-cierres","text":"Cuando se devuelve una funci\u00f3n interna como resultado, esa funci\u00f3n interna se conoce como cierre . def add(x, y): # `do_add` is a closure def do_add(): print('Adding', x, y) return x + y return do_add Caracter\u00edstica esencial: un cierre conserva los valores de todas las variables necesarias para que la funci\u00f3n se ejecute correctamente m\u00e1s adelante. Piense en un cierre como una funci\u00f3n m\u00e1s un entorno adicional que contiene los valores de las variables de las que depende.","title":"7.3.3 Cierres"},{"location":"7/#734-usando-cierres","text":"El cierre es una caracter\u00edstica esencial de Python. Sin embargo, su uso suele ser sutil. Aplicaciones habituales: Utilizar en funciones de devoluci\u00f3n de llamada. Evaluaci\u00f3n retrasada. Funciones de decorador (m\u00e1s tarde).","title":"7.3.4 Usando cierres"},{"location":"7/#735-evaluacion-retrasada","text":"Considere una funci\u00f3n como esta: def after(seconds, func): import time time.sleep(seconds) func() Ejemplo de uso: def greeting(): print('Hello Guido') after(30, greeting) after ejecuta la funci\u00f3n proporcionada m\u00e1s tarde. Los cierres llevan informaci\u00f3n adicional. def add(x, y): def do_add(): print(f'Adding {x} + {y} -> {x+y}') return do_add def after(seconds, func): import time time.sleep(seconds) func() after(30, add(2, 3)) # `do_add` has the references x -> 2 and y -> 3","title":"7.3.5 Evaluaci\u00f3n retrasada"},{"location":"7/#736-repeticion-de-codigo","text":"Los cierres tambi\u00e9n se pueden utilizar como t\u00e9cnica para evitar la repetici\u00f3n excesiva de c\u00f3digo. Puede escribir funciones que hacen c\u00f3digo.","title":"7.3.6 Repetici\u00f3n de c\u00f3digo"},{"location":"7/#737-ejercicios","text":"","title":"7.3.7 Ejercicios"},{"location":"7/#ejercicio-77-uso-de-cierres-para-evitar-la-repeticion","text":"Una de las caracter\u00edsticas m\u00e1s poderosas de los cierres es su uso para generar c\u00f3digo repetitivo. Si vuelve a consultar el ejercicio 5.7 , recuerde el c\u00f3digo para definir una propiedad con verificaci\u00f3n de tipos. class Stock: def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price ... @property def shares(self): return self._shares @shares.setter def shares(self, value): if not isinstance(value, int): raise TypeError('Expected int') self._shares = value ... En lugar de escribir ese c\u00f3digo repetidamente una y otra vez, puede crearlo autom\u00e1ticamente usando un cierre. Haga un archivo typedproperty.pyy coloque el siguiente c\u00f3digo en \u00e9l: # typedproperty.py def typedproperty(name, expected_type): private_name = '_' + name @property def prop(self): return getattr(self, private_name) @prop.setter def prop(self, value): if not isinstance(value, expected_type): raise TypeError(f'Expected {expected_type}') setattr(self, private_name, value) return prop Ahora, pru\u00e9belo definiendo una clase como esta: from typedproperty import typedproperty class Stock: name = typedproperty('name', str) shares = typedproperty('shares', int) price = typedproperty('price', float) def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Intente crear una instancia y verificar que la verificaci\u00f3n de tipos funcione. >>> s = Stock('IBM', 50, 91.1) >>> s.name 'IBM' >>> s.shares = '100' ... should get a TypeError ... >>>","title":"Ejercicio 7.7: Uso de cierres para evitar la repetici\u00f3n"},{"location":"7/#ejercicio-78-simplificacion-de-llamadas-a-funciones","text":"En el ejemplo anterior, los usuarios pueden encontrar llamadas typedproperty('shares', int)un poco detalladas para escribir, especialmente si se repiten mucho. Agregue las siguientes definiciones al typedproperty.pyarchivo: String = lambda name: typedproperty(name, str) Integer = lambda name: typedproperty(name, int) Float = lambda name: typedproperty(name, float) Ahora, reescribe la Stockclase para usar estas funciones en su lugar: class Stock: name = String('name') shares = Integer('shares') price = Float('price') def __init__(self, name, shares, price): self.name = name self.shares = shares self.price = price Ah, eso es un poco mejor. La principal conclusi\u00f3n aqu\u00ed es que los cierres y lambda, a menudo, se pueden usar para simplificar el c\u00f3digo y eliminar la repetici\u00f3n molesta. Suele ser bueno.","title":"Ejercicio 7.8: Simplificaci\u00f3n de llamadas a funciones"},{"location":"7/#ejercicio-79-poniendolo-en-practica","text":"Vuelva a escribir la clase Stock en el archivo stock.py para que utilice propiedades escritas como se muestra.","title":"Ejercicio 7.9: Poni\u00e9ndolo en pr\u00e1ctica"},{"location":"7/#74-decoradores-de-funciones","text":"Esta secci\u00f3n presenta el concepto de decorador. Este es un tema avanzado para el que solo ara\u00f1amos la superficie.","title":"7.4 Decoradores de funciones"},{"location":"7/#741-ejemplo-de-registro","text":"Considere una funci\u00f3n. def add(x, y): return x + y Ahora, considere la funci\u00f3n con algunos registros agregados. def add(x, y): print('Calling add') return x + y Ahora una segunda funci\u00f3n tambi\u00e9n con algunos registros. def sub(x, y): print('Calling sub') return x - y","title":"7.4.1 Ejemplo de registro"},{"location":"7/#742-observacion","text":"Observaci\u00f3n: es algo repetitivo. Escribir programas donde hay mucha replicaci\u00f3n de c\u00f3digo a menudo es realmente molesto. Son tediosos de escribir y dif\u00edciles de mantener. Especialmente si decide que desea cambiar c\u00f3mo funciona (es decir, quiz\u00e1s un tipo diferente de registro).","title":"7.4.2 Observaci\u00f3n"},{"location":"7/#743-codigo-que-hace-el-registro","text":"Quiz\u00e1s pueda crear una funci\u00f3n que haga funciones con registro agregado a ellas. Una envoltura. def logged(func): def wrapper(*args, **kwargs): print('Calling', func.__name__) return func(*args, **kwargs) return wrapper Ahora \u00fasalo. def add(x, y): return x + y logged_add = logged(add) \u00bfQu\u00e9 sucede cuando llamas a la funci\u00f3n devuelta por logged? logged_add(3, 4) # Usted ve que el mensaje aparece Este ejemplo ilustra el proceso de creaci\u00f3n de la denominada funci\u00f3n contenedora . Una envoltura es una funci\u00f3n que envuelve otra funci\u00f3n con algunos bits adicionales de procesamiento, pero por lo dem\u00e1s funciona exactamente de la misma manera que la funci\u00f3n original. >>> logged_add(3, 4) Calling add # Extra output. Added by the wrapper 7 >>> Nota: La logged() funci\u00f3n crea el contenedor y lo devuelve como resultado.","title":"7.4.3 C\u00f3digo que hace el registro"},{"location":"7/#744-decoradores","text":"Poner envoltorios alrededor de funciones es extremadamente com\u00fan en Python. Tan com\u00fan que tiene una sintaxis especial. def add(x, y): return x + y add = logged(add) # Sintaxis especial @logged def add(x, y): return x + y La sintaxis especial realiza exactamente los mismos pasos que se muestran arriba. Un decorador es solo una nueva sintaxis. Se dice que decora la funci\u00f3n.","title":"7.4.4 Decoradores"},{"location":"7/#comentario","text":"Hay muchos m\u00e1s detalles sutiles para los decoradores de los que se han presentado aqu\u00ed. Por ejemplo, us\u00e1ndolos en clases. O usando m\u00faltiples decoradores con una funci\u00f3n. Sin embargo, el ejemplo anterior es una buena ilustraci\u00f3n de c\u00f3mo tiende a surgir su uso. Por lo general, es en respuesta al c\u00f3digo repetitivo que aparece en una amplia gama de definiciones de funciones. Un decorador puede mover ese c\u00f3digo a una definici\u00f3n central.","title":"Comentario"},{"location":"7/#745-ejercicios","text":"","title":"7.4.5 Ejercicios"},{"location":"7/#ejercicio-710-un-decorador-de-tiempos","text":"Si define una funci\u00f3n, su nombre y m\u00f3dulo se almacenan en los atributos __name__ y __module__ . Por ejemplo: >>> def add(x,y): return x+y >>> add.__name__ 'add' >>> add.__module__ '__main__' >>> En un archivo timethis.py , escriba una funci\u00f3n decoradora timethis(func) que envuelva una funci\u00f3n con una capa adicional de l\u00f3gica que imprima cu\u00e1nto tarda en ejecutarse una funci\u00f3n. Para hacer esto, rodear\u00e1 la funci\u00f3n con llamadas de tiempo como esta: start = time.time() r = func(*args,**kwargs) end = time.time() print('%s.%s: %f' % (func.__module__, func.__name__, end-start)) Aqu\u00ed tienes un ejemplo de c\u00f3mo deber\u00eda funcionar tu decorador: >>> from timethis import timethis >>> @timethis def countdown(n): while n > 0: n -= 1 >>> countdown(10000000) __main__.countdown : 0.076562 >>> Discusi\u00f3n: Este decorador @timethis se puede colocar delante de cualquier definici\u00f3n de funci\u00f3n. Por lo tanto, puede usarlo como una herramienta de diagn\u00f3stico para ajustar el rendimiento.","title":"Ejercicio 7.10: un decorador de tiempos"},{"location":"7/#75-metodos-estaticos-y-de-clase","text":"En esta secci\u00f3n se analizan algunos decoradores integrados que se utilizan en combinaci\u00f3n con definiciones de m\u00e9todos.","title":"7.5 M\u00e9todos est\u00e1ticos y de clase"},{"location":"7/#751-decoradores-predefinidos","text":"Hay decoradores predefinidos que se utilizan para especificar tipos especiales de m\u00e9todos en las definiciones de clases. class Foo: def bar(self,a): ... @staticmethod def spam(a): ... @classmethod def grok(cls,a): ... @property def name(self): ... Vayamos uno por uno.","title":"7.5.1 Decoradores predefinidos"},{"location":"7/#752-metodos-estaticos","text":"@staticmethod se utiliza para definir los llamados m\u00e9todos de clase est\u00e1tica (de C ++ / Java). Un m\u00e9todo est\u00e1tico es una funci\u00f3n que forma parte de la clase, pero que no opera en instancias. class Foo(object): @staticmethod def bar(x): print('x =', x) >>> Foo.bar(2) x=2 >>> Los m\u00e9todos est\u00e1ticos se utilizan a veces para implementar c\u00f3digo de soporte interno para una clase. Por ejemplo, c\u00f3digo para ayudar a administrar las instancias creadas (administraci\u00f3n de memoria, recursos del sistema, persistencia, bloqueo, etc.). Tambi\u00e9n son utilizados por ciertos patrones de dise\u00f1o (no discutidos aqu\u00ed).","title":"7.5.2 M\u00e9todos est\u00e1ticos"},{"location":"7/#753-metodos-de-clase","text":"@classmethod se utiliza para definir m\u00e9todos de clase. Un m\u00e9todo de clase es un m\u00e9todo que recibe el objeto de clase como primer par\u00e1metro en lugar de la instancia. class Foo: def bar(self): print(self) @classmethod def spam(cls): print(cls) >>> f = Foo() >>> f.bar() <__main__.Foo object at 0x971690> # La instancia `f` >>> Foo.spam() <class '__main__.Foo'> # La clase `Foo` >>> Los m\u00e9todos de clase se utilizan con mayor frecuencia como una herramienta para definir constructores alternativos. class Date: def __init__(self,year,month,day): self.year = year self.month = month self.day = day @classmethod def today(cls): # Notice how the class is passed as an argument tm = time.localtime() # And used to create a new instance return cls(tm.tm_year, tm.tm_mon, tm.tm_mday) d = Date.today() Los m\u00e9todos de clase resuelven algunos problemas complicados con caracter\u00edsticas como la herencia. class Date: ... @classmethod def today(cls): # Gets the correct class (e.g. `NewDate`) tm = time.localtime() return cls(tm.tm_year, tm.tm_mon, tm.tm_mday) class NewDate(Date): ... d = NewDate.today()","title":"7.5.3 M\u00e9todos de clase"},{"location":"7/#754-ejercicios","text":"","title":"7.5.4 Ejercicios"},{"location":"7/#ejercicio-711-metodos-de-clase-en-la-practica","text":"En sus archivos report.py y portfolio.py , la creaci\u00f3n de un objeto Portfolio es un poco confusa. Por ejemplo, el programa report.py tiene un c\u00f3digo como este: def read_portfolio(filename, **opts): ''' Read a stock portfolio file into a list of dictionaries with keys name, shares, and price. ''' with open(filename) as lines: portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) portfolio = [ Stock(**d) for d in portdicts ] return Portfolio(portfolio) y el archivo portfolio.py se define Portfolio() con un inicializador extra\u00f1o como este: class Portfolio: def __init__(self, holdings): self.holdings = holdings ... Francamente, la cadena de responsabilidad es un poco confusa porque el c\u00f3digo est\u00e1 disperso. Si Portfolio se supone que una clase contiene una lista de instancias Stock , tal vez deber\u00eda cambiar la clase para que sea un poco m\u00e1s clara. Me gusta esto: # portfolio.py import stock class Portfolio: def __init__(self): self.holdings = [] def append(self, holding): if not isinstance(holding, stock.Stock): raise TypeError('Expected a Stock instance') self.holdings.append(holding) ... Si desea leer un portafolio de un archivo CSV, tal vez deber\u00eda crear un m\u00e9todo de clase para \u00e9l: # portfolio.py import fileparse import stock class Portfolio: def __init__(self): self.holdings = [] def append(self, holding): if not isinstance(holding, stock.Stock): raise TypeError('Expected a Stock instance') self.holdings.append(holding) @classmethod def from_csv(cls, lines, **opts): self = cls() portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float], **opts) for d in portdicts: self.append(stock.Stock(**d)) return self Para usar esta nueva clase Portfolio , ahora puede escribir c\u00f3digo como este: >>> from portfolio import Portfolio >>> with open('Data/portfolio.csv') as lines: ... port = Portfolio.from_csv(lines) ... >>> Realice estos cambios en la clase Portfolio y modifique el c\u00f3digo report.py para usar el m\u00e9todo de la clase.","title":"Ejercicio 7.11: M\u00e9todos de clase en la pr\u00e1ctica"},{"location":"8/","text":"8. Prueba y Depuraci\u00f3n Esta secci\u00f3n introduce unos tem\u00e1s b\u00e1sicas en relaci\u00f3n a pruebas, reporter\u00eda y depuraci\u00f3n. 8.1 Prueba 8.1.1 Las pruebas son buenas, la depuraci\u00f3n apesta La naturaleza din\u00e1mica de Python hace que las pruebas sean de vital importancia para la mayor\u00eda de las aplicaciones. No hay un compilador para encontrar sus errores. La \u00fanica forma de encontrar errores es ejecutar el c\u00f3digo y asegurarse de probar todas sus funciones. 8.1.2 Afirmaciones La assertdeclaraci\u00f3n es una verificaci\u00f3n interna del programa. Si una expresi\u00f3n no es verdadera, genera una AssertionErrorexcepci\u00f3n. assert sintaxis de declaraci\u00f3n. assert <expression> [, 'Mensaje de diagnostico'] Por ejemplo. assert isinstance(10, int), 'Esperaba int' No debe usarse para verificar la entrada del usuario (es decir, datos ingresados \u200b\u200ben un formulario web o algo as\u00ed). Su prop\u00f3sito es m\u00e1s para controles internos e invariantes (condiciones que siempre deben ser verdaderas). 8.1.3 Programaci\u00f3n por contrato Tambi\u00e9n conocido como Dise\u00f1o por contrato, el uso liberal de afirmaciones es un enfoque para dise\u00f1ar software. Prescribe que los dise\u00f1adores de software deben definir especificaciones de interfaz precisas para los componentes del software. Por ejemplo, puede poner aserciones en todas las entradas de una funci\u00f3n. def add(x, y): assert isinstance(x, int), 'Esperaba int' assert isinstance(y, int), 'Esperaba int' return x + y La verificaci\u00f3n de las entradas detectar\u00e1 inmediatamente a las personas que llaman que no est\u00e9n usando los argumentos adecuados. >>> add(2, 3) 5 >>> add('2', '3') Traceback (most recent call last): ... AssertionError: Expected int >>> 8.1.4 Pruebas en l\u00ednea Las afirmaciones tambi\u00e9n se pueden utilizar para pruebas sencillas. def add(x, y): return x + y assert add(2,2) == 4 De esta manera, est\u00e1 incluyendo la prueba en el mismo m\u00f3dulo que su c\u00f3digo. Beneficio: si el c\u00f3digo est\u00e1 claramente roto, los intentos de importar el m\u00f3dulo fallar\u00e1n. Esto no se recomienda para pruebas exhaustivas. Es m\u00e1s una \"prueba de humo\" b\u00e1sica. \u00bfLa funci\u00f3n funciona en alg\u00fan ejemplo? Si no es as\u00ed, definitivamente algo est\u00e1 roto. 8.1.5 M\u00f3dulo unittest Suponga que tiene alg\u00fan c\u00f3digo. # simple.py def add(x, y): return x + y Ahora, suponga que quiere probarlo. Cree un archivo de prueba separado como este. # test_simple.py import simple import unittest Luego defina una clase de prueba. # test_simple.py import simple import unittest # Notice that it inherits from unittest.TestCase class TestAdd(unittest.TestCase): ... La clase de prueba debe heredar unittest.TestCase . En la clase de prueba, define los m\u00e9todos de prueba. # test_simple.py import simple import unittest # Notice that it inherits from unittest.TestCase class TestAdd(unittest.TestCase): def test_simple(self): # Test with simple integer arguments r = simple.add(2, 2) self.assertEqual(r, 5) def test_str(self): # Test with strings r = simple.add('hello', 'world') self.assertEqual(r, 'helloworld') Importante: Cada m\u00e9todo debe comenzar con test . 8.1.6 Utilizando unittest Hay varias afirmaciones integradas que vienen con unittest. Cada uno de ellos afirma algo diferente. # Afirme que expr es True self.assertTrue(expr) # Afirme que x == y self.assertEqual(x,y) # Afirme que x != y self.assertNotEqual(x,y) # Afirme que x est\u00e1 cerca de y self.assertAlmostEqual(x,y,places) # Afirme que callable(arg1,arg2,...) alza una excepcion self.assertRaises(exc, callable, arg1, arg2, ...) Esta no es una lista exhaustiva. Hay otras afirmaciones en el m\u00f3dulo. 8.1.7 Corriendo unittest Para ejecutar las pruebas, convierta el c\u00f3digo en un script. # test_simple.py ... if __name__ == '__main__': unittest.main() Luego, ejecute Python en el archivo de prueba. bash % python3 test_simple.py F. ======================================================== FAIL: test_simple (__main__.TestAdd) -------------------------------------------------------- Traceback (most recent call last): File \"testsimple.py\", line 8, in test_simple self.assertEqual(r, 5) AssertionError: 4 != 5 -------------------------------------------------------- Ran 2 tests in 0.000s FAILED (failures=1) 8.1.8 Comentario Las pruebas unitarias efectivas son un arte y pueden volverse bastante complicadas para aplicaciones grandes. El unittest m\u00f3dulo tiene una gran cantidad de opciones relacionadas con los corredores de pruebas, la recopilaci\u00f3n de resultados y otros aspectos de las pruebas. Consulte la documentaci\u00f3n para obtener m\u00e1s detalles. 8.1.9 Herramientas de prueba de terceros El unittest m\u00f3dulo integrado tiene la ventaja de estar disponible en todas partes: es parte de Python. Sin embargo, a muchos programadores tambi\u00e9n les parece bastante detallado. Una alternativa popular es pytest . Con pytest , su archivo de prueba se simplifica a algo como lo siguiente: # test_simple.py import simple def test_simple(): assert simple.add(2,2) == 4 def test_str(): assert simple.add('hello','world') == 'helloworld' Para ejecutar las pruebas, simplemente escriba un comando como python -m pytest. Descubrir\u00e1 todas las pruebas y las ejecutar\u00e1. Hay mucho m\u00e1s pytestque este ejemplo, pero por lo general es bastante f\u00e1cil comenzar si decides probarlo. 8.1.10 Ejercicios En este ejercicio, explorar\u00e1 la mec\u00e1nica b\u00e1sica del uso del unittestm\u00f3dulo de Python . En ejercicios anteriores, escribi\u00f3 un archivo stock.py que conten\u00eda una clase Stock . Para este ejercicio, asumi\u00f3 que est\u00e1 usando el c\u00f3digo escrito para el Ejercicio 7.9 que involucra propiedades con tipo. Si, por alguna raz\u00f3n, eso no funciona, es posible que desee copiar la soluci\u00f3n desde Solutions/7_9 su directorio de trabajo. Ejercicio 8.1: Escritura de pruebas unitarias En un archivo separado test_stock.py , escriba un conjunto de pruebas unitarias para la clase Stock . Para comenzar, aqu\u00ed hay un peque\u00f1o fragmento de c\u00f3digo que prueba la creaci\u00f3n de instancias: # test_stock.py import unittest import stock class TestStock(unittest.TestCase): def test_create(self): s = stock.Stock('GOOG', 100, 490.1) self.assertEqual(s.name, 'GOOG') self.assertEqual(s.shares, 100) self.assertEqual(s.price, 490.1) if __name__ == '__main__': unittest.main() Ejecute sus pruebas unitarias. Deber\u00eda obtener una salida que se ve as\u00ed: . ---------------------------------------------------------------------- Ran 1 tests in 0.000s OK Una vez que est\u00e9 satisfecho de que funciona, escriba pruebas unitarias adicionales que verifiquen lo siguiente: Aseg\u00farese de que la s.cost propiedad devuelva el valor correcto ( 49010.0 ) Aseg\u00farese de que el s.sell() m\u00e9todo funcione correctamente. Deber\u00eda disminuir el valor de en s.shares consecuencia. Aseg\u00farese de que el s.sharesatributo no se pueda establecer en un valor que no sea entero. Para la \u00faltima parte, deber\u00e1 verificar que se genere una excepci\u00f3n. Una forma f\u00e1cil de hacerlo es con un c\u00f3digo como este: class TestStock(unittest.TestCase): ... def test_bad_shares(self): s = stock.Stock('GOOG', 100, 490.1) with self.assertRaises(TypeError): s.shares = '100' 8.2 Registro, manejo de errores y diagn\u00f3stico Esta secci\u00f3n presenta brevemente el m\u00f3dulo de registro. m\u00f3dulo de registro El m\u00f3dulo logging es un m\u00f3dulo de biblioteca est\u00e1ndar para registrar informaci\u00f3n de diagn\u00f3stico. Tambi\u00e9n es un m\u00f3dulo muy grande con muchas funciones sofisticadas. Mostraremos un ejemplo sencillo para ilustrar su utilidad. Excepciones revisadas En los ejercicios, escribimos una funci\u00f3n parse() que se parec\u00eda a esto: # fileparse.py def parse(f, types=None, names=None, delimiter=None): records = [] for line in f: line = line.strip() if not line: continue try: records.append(split(line,types,names,delimiter)) except ValueError as e: print(\"Couldn't parse :\", line) print(\"Reason :\", e) return records Conc\u00e9ntrese en la try-exceptdeclaraci\u00f3n. \u00bfQu\u00e9 debes hacer en el bloque except ? \u00bfDeber\u00eda imprimir un mensaje de advertencia? try: records.append(split(line,types,names,delimiter)) except ValueError as e: print(\"Couldn't parse :\", line) print(\"Reason :\", e) \u00bfO lo ignoras en silencio? try: records.append(split(line,types,names,delimiter)) except ValueError as e: pass Ninguna soluci\u00f3n es satisfactoria porque a menudo desea ambos comportamientos (seleccionables por el usuario). Usando el registro El m\u00f3dulo logging puede abordar esto. # fileparse.py import logging log = logging.getLogger(__name__) def parse(f,types=None,names=None,delimiter=None): ... try: records.append(split(line,types,names,delimiter)) except ValueError as e: log.warning(\"Couldn't parse : %s\", line) log.debug(\"Reason : %s\", e) El c\u00f3digo se modifica para emitir mensajes de advertencia o un objeto Logger especial. El creado con logging.getLogger(__name__) . Conceptos b\u00e1sicos de registro Crea un objeto de registrador. log = logging.getLogger(name) # name is a string Emitir mensajes de registro. log.critical(message [, args]) log.error(message [, args]) log.warning(message [, args]) log.info(message [, args]) log.debug(message [, args]) Cada m\u00e9todo representa un nivel de gravedad diferente. Todos ellos crean un mensaje de registro formateado. args se utiliza con el %operador para crear el mensaje. logmsg = message % args # Escrito al log Configuraci\u00f3n de registro El comportamiento de registro se configura por separado. # main.py ... if __name__ == '__main__': import logging logging.basicConfig( filename = 'app.log', # archivo de salida level = logging.INFO, # nivel de salida ) Por lo general, esta es una configuraci\u00f3n \u00fanica al inicio del programa. La configuraci\u00f3n es independiente del c\u00f3digo que realiza las llamadas de registro. Comentarios El registro es altamente configurable. Puede ajustar todos los aspectos: archivos de salida, niveles, formatos de mensajes, etc. Sin embargo, el c\u00f3digo que usa el registro no tiene que preocuparse por eso. Ejercicios Ejercicio 8.2: Agregar registro a un m\u00f3dulo En fileparse.py , hay alg\u00fan manejo de errores relacionado con las excepciones causadas por una entrada incorrecta. Se parece a esto: # fileparse.py import csv def parse_csv(lines, select=None, types=None, has_headers=True, delimiter=',', silence_errors=False): ''' Parse a CSV file into a list of records with type conversion. ''' if select and not has_headers: raise RuntimeError('select requires column headers') rows = csv.reader(lines, delimiter=delimiter) # lee el encabezado (si es que existe) headers = next(rows) if has_headers else [] # si columnas especificas fueron seleccionadas, haga indices para filtrar y defina las columnas de salida if select: indices = [ headers.index(colname) for colname in select ] headers = select records = [] for rowno, row in enumerate(rows, 1): if not row: # salte las columnas sin data continue # si columnas especificas son seleccionadas, seleccionelas if select: row = [ row[index] for index in indices] # aplique la conversi\u00f3n de tipo a la fila if types: try: row = [func(val) for func, val in zip(types, row)] except ValueError as e: if not silence_errors: print(f\"Row {rowno}: Couldn't convert {row}\") print(f\"Row {rowno}: Reason {e}\") continue # haga un diccionario o una tupla if headers: record = dict(zip(headers, row)) else: record = tuple(row) records.append(record) return records Observe las declaraciones impresas que emiten mensajes de diagn\u00f3stico. Reemplazar esas impresiones con operaciones de registro es relativamente simple. Cambie el c\u00f3digo as\u00ed: # fileparse.py import csv import logging log = logging.getLogger(__name__) def parse_csv(lines, select=None, types=None, has_headers=True, delimiter=',', silence_errors=False): ''' Parse a CSV file into a list of records with type conversion. ''' if select and not has_headers: raise RuntimeError('select requires column headers') rows = csv.reader(lines, delimiter=delimiter) # lee el encabezado (si es que existe) headers = next(rows) if has_headers else [] # si columnas especificas fueron seleccionadas, haga indices para filtrar y defina las columnas de salida if select: indices = [ headers.index(colname) for colname in select ] headers = select records = [] for rowno, row in enumerate(rows, 1): if not row: # salte las columnas sin data continue # si columnas especificas son seleccionadas, seleccionelas if select: row = [ row[index] for index in indices] # aplique la conversi\u00f3n de tipo a la fila if types: try: row = [func(val) for func, val in zip(types, row)] except ValueError as e: if not silence_errors: log.warning(\"Row %d: Couldn't convert %s\", rowno, row) log.debug(\"Row %d: Reason %s\", rowno, e) continue # haga un diccionario o una tupla if headers: record = dict(zip(headers, row)) else: record = tuple(row) records.append(record) return records Ahora que ha realizado estos cambios, intente utilizar parte de su c\u00f3digo en datos incorrectos. >>> import report >>> a = report.read_portfolio('Data/missing.csv') Row 4: Bad row: ['MSFT', '', '51.23'] Row 7: Bad row: ['IBM', '', '70.44'] >>> Si no hace nada, solo recibir\u00e1 mensajes de registro para el WARNING nivel y superior. La salida se ver\u00e1 como simples declaraciones impresas. Sin embargo, si configura el m\u00f3dulo de registro, obtendr\u00e1 informaci\u00f3n adicional sobre los niveles de registro, el m\u00f3dulo y m\u00e1s. Escriba estos pasos para ver que: >>> import logging >>> logging.basicConfig() >>> a = report.read_portfolio('Data/missing.csv') WARNING:fileparse:Row 4: Bad row: ['MSFT', '', '51.23'] WARNING:fileparse:Row 7: Bad row: ['IBM', '', '70.44'] >>> Notar\u00e1 que no ve el resultado de la operaci\u00f3n log.debug() . Escriba esto para cambiar el nivel. >>> logging.getLogger('fileparse').level = logging.DEBUG >>> a = report.read_portfolio('Data/missing.csv') WARNING:fileparse:Row 4: Bad row: ['MSFT', '', '51.23'] DEBUG:fileparse:Row 4: Reason: invalid literal for int() with base 10: '' WARNING:fileparse:Row 7: Bad row: ['IBM', '', '70.44'] DEBUG:fileparse:Row 7: Reason: invalid literal for int() with base 10: '' >>> Apague todos, excepto los mensajes de registro m\u00e1s cr\u00edticos: >>> logging.getLogger('fileparse').level=logging.CRITICAL >>> a = report.read_portfolio('Data/missing.csv') >>> Ejercicio 8.3: Agregar registro a un programa Para agregar registro a una aplicaci\u00f3n, necesita tener alg\u00fan mecanismo para inicializar el m\u00f3dulo de registro en el m\u00f3dulo principal. Una forma de hacerlo es incluir un c\u00f3digo de configuraci\u00f3n que se parezca a esto: # Este archivo crea configuraci\u00f3n basica del modulo logging # Cambie la configuracion aqui para ajustar la salida de logging import logging logging.basicConfig( filename = 'app.log', # Nombre del archivo (omita para usar stderr) filemode = 'w', # Modo de archivo (use 'a' para adjuntar) level = logging.WARNING, # Nivel de logging (DEBUG, INFO, WARNING, ERROR, or CRITICAL) ) Nuevamente, necesitar\u00eda poner esto en alg\u00fan lugar en los pasos de inicio de su programa. Por ejemplo, \u00bfd\u00f3nde pondr\u00eda esto en su programa report.py ? 8.3 Depuraci\u00f3n 8.3.1 Sugerencias de depuraci\u00f3n Entonces, su programa se bloque\u00f3... bash % python3 blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", 4, in spam line x.append(3) AttributeError: 'int' object has no attribute 'append' \u00a1\u00bfAhora que?! 8.3.2 Lectura de trazas La \u00faltima l\u00ednea es la causa espec\u00edfica del accidente. bash % python3 blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", 4, in spam line x.append(3) # Cause of the crash AttributeError: 'int' object has no attribute 'append' Sin embargo, no siempre es f\u00e1cil de leer o comprender. SUGERENCIA PRO: Pegue todo el rastreo en Google. 8.3.3 Usando el REPL Utilice la opci\u00f3n -i para mantener activo Python al ejecutar un script. bash % python3 -i blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", 4, in spam line x.append(3) AttributeError: 'int' object has no attribute 'append' >>> Conserva el estado de int\u00e9rprete. Eso significa que puedes andar hurgando despu\u00e9s del accidente. Comprobaci\u00f3n de valores de variables y otros estados. 8.3.4 Depurar con impresi\u00f3n print() la depuraci\u00f3n es bastante com\u00fan. Consejo: aseg\u00farese de utilizar repr() def spam(x): print('DEBUG:', repr(x)) ... repr() le muestra una representaci\u00f3n precisa de un valor. No es el resultado de impresi\u00f3n agradable. >>> from decimal import Decimal >>> x = Decimal('3.4') # SIN `repr` >>> print(x) 3.4 # CON `repr` >>> print(repr(x)) Decimal('3.4') >>> 8.3.5 El depurador de Python Puede iniciar manualmente el depurador dentro de un programa. def some_function(): ... breakpoint() # Ingrese al depurador (Python 3.7+) ... Esto inicia el depurador en la llamada breakpoint() . En versiones anteriores de Python, hiciste esto. A veces ver\u00e1 esto mencionado en otras gu\u00edas de depuraci\u00f3n. import pdb ... pdb.set_trace() # En vez de `breakpoint()`... 8.3.6 Ejecutar bajo depurador Tambi\u00e9n puede ejecutar un programa completo en el depurador. bash % python3 -m pdb someprogram.py Autom\u00e1ticamente ingresar\u00e1 al depurador antes de la primera declaraci\u00f3n. Permiti\u00e9ndole establecer puntos de interrupci\u00f3n y cambiar la configuraci\u00f3n. Comandos habituales del depurador: (Pdb) help # ayuda (Pdb) w(here) # imprima el rastreo (Pdb) d(own) # hacia arriba (Pdb) u(p) # hacia abajo (Pdb) b(reak) loc # fije un breakpoint (Pdb) s(tep) # ejecute una instruccion (Pdb) c(ontinue) # continue la ejecucion (Pdb) l(ist) # liste el codigo fuente (Pdb) a(rgs) # imprima los argumentos de la funcion (Pdb) !statement # ejectue la declaracion La ubicaci\u00f3n de los puntos de interrupci\u00f3n es una de las siguientes. (Pdb) b 45 # linea 45 en el archivo actual (Pdb) b file.py:45 # linea 34 en file.py (Pdb) b foo # funcion foo() en el archivo actual (Pdb) b module.foo # funcion foo() en el modulo 8.3.7 Ejercicios Ejercicio 8.4: \u00bfErrores? \u00bfQu\u00e9 errores? Corre. \u00a1Env\u00edalo!","title":"8 Prueba y Depuraci\u00f3n"},{"location":"8/#8-prueba-y-depuracion","text":"Esta secci\u00f3n introduce unos tem\u00e1s b\u00e1sicas en relaci\u00f3n a pruebas, reporter\u00eda y depuraci\u00f3n.","title":"8. Prueba y Depuraci\u00f3n"},{"location":"8/#81-prueba","text":"","title":"8.1 Prueba"},{"location":"8/#811-las-pruebas-son-buenas-la-depuracion-apesta","text":"La naturaleza din\u00e1mica de Python hace que las pruebas sean de vital importancia para la mayor\u00eda de las aplicaciones. No hay un compilador para encontrar sus errores. La \u00fanica forma de encontrar errores es ejecutar el c\u00f3digo y asegurarse de probar todas sus funciones.","title":"8.1.1 Las pruebas son buenas, la depuraci\u00f3n apesta"},{"location":"8/#812-afirmaciones","text":"La assertdeclaraci\u00f3n es una verificaci\u00f3n interna del programa. Si una expresi\u00f3n no es verdadera, genera una AssertionErrorexcepci\u00f3n. assert sintaxis de declaraci\u00f3n. assert <expression> [, 'Mensaje de diagnostico'] Por ejemplo. assert isinstance(10, int), 'Esperaba int' No debe usarse para verificar la entrada del usuario (es decir, datos ingresados \u200b\u200ben un formulario web o algo as\u00ed). Su prop\u00f3sito es m\u00e1s para controles internos e invariantes (condiciones que siempre deben ser verdaderas).","title":"8.1.2 Afirmaciones"},{"location":"8/#813-programacion-por-contrato","text":"Tambi\u00e9n conocido como Dise\u00f1o por contrato, el uso liberal de afirmaciones es un enfoque para dise\u00f1ar software. Prescribe que los dise\u00f1adores de software deben definir especificaciones de interfaz precisas para los componentes del software. Por ejemplo, puede poner aserciones en todas las entradas de una funci\u00f3n. def add(x, y): assert isinstance(x, int), 'Esperaba int' assert isinstance(y, int), 'Esperaba int' return x + y La verificaci\u00f3n de las entradas detectar\u00e1 inmediatamente a las personas que llaman que no est\u00e9n usando los argumentos adecuados. >>> add(2, 3) 5 >>> add('2', '3') Traceback (most recent call last): ... AssertionError: Expected int >>>","title":"8.1.3 Programaci\u00f3n por contrato"},{"location":"8/#814-pruebas-en-linea","text":"Las afirmaciones tambi\u00e9n se pueden utilizar para pruebas sencillas. def add(x, y): return x + y assert add(2,2) == 4 De esta manera, est\u00e1 incluyendo la prueba en el mismo m\u00f3dulo que su c\u00f3digo. Beneficio: si el c\u00f3digo est\u00e1 claramente roto, los intentos de importar el m\u00f3dulo fallar\u00e1n. Esto no se recomienda para pruebas exhaustivas. Es m\u00e1s una \"prueba de humo\" b\u00e1sica. \u00bfLa funci\u00f3n funciona en alg\u00fan ejemplo? Si no es as\u00ed, definitivamente algo est\u00e1 roto.","title":"8.1.4 Pruebas en l\u00ednea"},{"location":"8/#815-modulo-unittest","text":"Suponga que tiene alg\u00fan c\u00f3digo. # simple.py def add(x, y): return x + y Ahora, suponga que quiere probarlo. Cree un archivo de prueba separado como este. # test_simple.py import simple import unittest Luego defina una clase de prueba. # test_simple.py import simple import unittest # Notice that it inherits from unittest.TestCase class TestAdd(unittest.TestCase): ... La clase de prueba debe heredar unittest.TestCase . En la clase de prueba, define los m\u00e9todos de prueba. # test_simple.py import simple import unittest # Notice that it inherits from unittest.TestCase class TestAdd(unittest.TestCase): def test_simple(self): # Test with simple integer arguments r = simple.add(2, 2) self.assertEqual(r, 5) def test_str(self): # Test with strings r = simple.add('hello', 'world') self.assertEqual(r, 'helloworld') Importante: Cada m\u00e9todo debe comenzar con test .","title":"8.1.5 M\u00f3dulo unittest"},{"location":"8/#816-utilizando-unittest","text":"Hay varias afirmaciones integradas que vienen con unittest. Cada uno de ellos afirma algo diferente. # Afirme que expr es True self.assertTrue(expr) # Afirme que x == y self.assertEqual(x,y) # Afirme que x != y self.assertNotEqual(x,y) # Afirme que x est\u00e1 cerca de y self.assertAlmostEqual(x,y,places) # Afirme que callable(arg1,arg2,...) alza una excepcion self.assertRaises(exc, callable, arg1, arg2, ...) Esta no es una lista exhaustiva. Hay otras afirmaciones en el m\u00f3dulo.","title":"8.1.6 Utilizando unittest"},{"location":"8/#817-corriendo-unittest","text":"Para ejecutar las pruebas, convierta el c\u00f3digo en un script. # test_simple.py ... if __name__ == '__main__': unittest.main() Luego, ejecute Python en el archivo de prueba. bash % python3 test_simple.py F. ======================================================== FAIL: test_simple (__main__.TestAdd) -------------------------------------------------------- Traceback (most recent call last): File \"testsimple.py\", line 8, in test_simple self.assertEqual(r, 5) AssertionError: 4 != 5 -------------------------------------------------------- Ran 2 tests in 0.000s FAILED (failures=1)","title":"8.1.7 Corriendo unittest"},{"location":"8/#818-comentario","text":"Las pruebas unitarias efectivas son un arte y pueden volverse bastante complicadas para aplicaciones grandes. El unittest m\u00f3dulo tiene una gran cantidad de opciones relacionadas con los corredores de pruebas, la recopilaci\u00f3n de resultados y otros aspectos de las pruebas. Consulte la documentaci\u00f3n para obtener m\u00e1s detalles.","title":"8.1.8 Comentario"},{"location":"8/#819-herramientas-de-prueba-de-terceros","text":"El unittest m\u00f3dulo integrado tiene la ventaja de estar disponible en todas partes: es parte de Python. Sin embargo, a muchos programadores tambi\u00e9n les parece bastante detallado. Una alternativa popular es pytest . Con pytest , su archivo de prueba se simplifica a algo como lo siguiente: # test_simple.py import simple def test_simple(): assert simple.add(2,2) == 4 def test_str(): assert simple.add('hello','world') == 'helloworld' Para ejecutar las pruebas, simplemente escriba un comando como python -m pytest. Descubrir\u00e1 todas las pruebas y las ejecutar\u00e1. Hay mucho m\u00e1s pytestque este ejemplo, pero por lo general es bastante f\u00e1cil comenzar si decides probarlo.","title":"8.1.9 Herramientas de prueba de terceros"},{"location":"8/#8110-ejercicios","text":"En este ejercicio, explorar\u00e1 la mec\u00e1nica b\u00e1sica del uso del unittestm\u00f3dulo de Python . En ejercicios anteriores, escribi\u00f3 un archivo stock.py que conten\u00eda una clase Stock . Para este ejercicio, asumi\u00f3 que est\u00e1 usando el c\u00f3digo escrito para el Ejercicio 7.9 que involucra propiedades con tipo. Si, por alguna raz\u00f3n, eso no funciona, es posible que desee copiar la soluci\u00f3n desde Solutions/7_9 su directorio de trabajo.","title":"8.1.10 Ejercicios"},{"location":"8/#ejercicio-81-escritura-de-pruebas-unitarias","text":"En un archivo separado test_stock.py , escriba un conjunto de pruebas unitarias para la clase Stock . Para comenzar, aqu\u00ed hay un peque\u00f1o fragmento de c\u00f3digo que prueba la creaci\u00f3n de instancias: # test_stock.py import unittest import stock class TestStock(unittest.TestCase): def test_create(self): s = stock.Stock('GOOG', 100, 490.1) self.assertEqual(s.name, 'GOOG') self.assertEqual(s.shares, 100) self.assertEqual(s.price, 490.1) if __name__ == '__main__': unittest.main() Ejecute sus pruebas unitarias. Deber\u00eda obtener una salida que se ve as\u00ed: . ---------------------------------------------------------------------- Ran 1 tests in 0.000s OK Una vez que est\u00e9 satisfecho de que funciona, escriba pruebas unitarias adicionales que verifiquen lo siguiente: Aseg\u00farese de que la s.cost propiedad devuelva el valor correcto ( 49010.0 ) Aseg\u00farese de que el s.sell() m\u00e9todo funcione correctamente. Deber\u00eda disminuir el valor de en s.shares consecuencia. Aseg\u00farese de que el s.sharesatributo no se pueda establecer en un valor que no sea entero. Para la \u00faltima parte, deber\u00e1 verificar que se genere una excepci\u00f3n. Una forma f\u00e1cil de hacerlo es con un c\u00f3digo como este: class TestStock(unittest.TestCase): ... def test_bad_shares(self): s = stock.Stock('GOOG', 100, 490.1) with self.assertRaises(TypeError): s.shares = '100'","title":"Ejercicio 8.1: Escritura de pruebas unitarias"},{"location":"8/#82-registro-manejo-de-errores-y-diagnostico","text":"Esta secci\u00f3n presenta brevemente el m\u00f3dulo de registro.","title":"8.2 Registro, manejo de errores y diagn\u00f3stico"},{"location":"8/#modulo-de-registro","text":"El m\u00f3dulo logging es un m\u00f3dulo de biblioteca est\u00e1ndar para registrar informaci\u00f3n de diagn\u00f3stico. Tambi\u00e9n es un m\u00f3dulo muy grande con muchas funciones sofisticadas. Mostraremos un ejemplo sencillo para ilustrar su utilidad.","title":"m\u00f3dulo de registro"},{"location":"8/#excepciones-revisadas","text":"En los ejercicios, escribimos una funci\u00f3n parse() que se parec\u00eda a esto: # fileparse.py def parse(f, types=None, names=None, delimiter=None): records = [] for line in f: line = line.strip() if not line: continue try: records.append(split(line,types,names,delimiter)) except ValueError as e: print(\"Couldn't parse :\", line) print(\"Reason :\", e) return records Conc\u00e9ntrese en la try-exceptdeclaraci\u00f3n. \u00bfQu\u00e9 debes hacer en el bloque except ? \u00bfDeber\u00eda imprimir un mensaje de advertencia? try: records.append(split(line,types,names,delimiter)) except ValueError as e: print(\"Couldn't parse :\", line) print(\"Reason :\", e) \u00bfO lo ignoras en silencio? try: records.append(split(line,types,names,delimiter)) except ValueError as e: pass Ninguna soluci\u00f3n es satisfactoria porque a menudo desea ambos comportamientos (seleccionables por el usuario).","title":"Excepciones revisadas"},{"location":"8/#usando-el-registro","text":"El m\u00f3dulo logging puede abordar esto. # fileparse.py import logging log = logging.getLogger(__name__) def parse(f,types=None,names=None,delimiter=None): ... try: records.append(split(line,types,names,delimiter)) except ValueError as e: log.warning(\"Couldn't parse : %s\", line) log.debug(\"Reason : %s\", e) El c\u00f3digo se modifica para emitir mensajes de advertencia o un objeto Logger especial. El creado con logging.getLogger(__name__) .","title":"Usando el registro"},{"location":"8/#conceptos-basicos-de-registro","text":"Crea un objeto de registrador. log = logging.getLogger(name) # name is a string Emitir mensajes de registro. log.critical(message [, args]) log.error(message [, args]) log.warning(message [, args]) log.info(message [, args]) log.debug(message [, args]) Cada m\u00e9todo representa un nivel de gravedad diferente. Todos ellos crean un mensaje de registro formateado. args se utiliza con el %operador para crear el mensaje. logmsg = message % args # Escrito al log","title":"Conceptos b\u00e1sicos de registro"},{"location":"8/#configuracion-de-registro","text":"El comportamiento de registro se configura por separado. # main.py ... if __name__ == '__main__': import logging logging.basicConfig( filename = 'app.log', # archivo de salida level = logging.INFO, # nivel de salida ) Por lo general, esta es una configuraci\u00f3n \u00fanica al inicio del programa. La configuraci\u00f3n es independiente del c\u00f3digo que realiza las llamadas de registro.","title":"Configuraci\u00f3n de registro"},{"location":"8/#comentarios","text":"El registro es altamente configurable. Puede ajustar todos los aspectos: archivos de salida, niveles, formatos de mensajes, etc. Sin embargo, el c\u00f3digo que usa el registro no tiene que preocuparse por eso.","title":"Comentarios"},{"location":"8/#ejercicios","text":"","title":"Ejercicios"},{"location":"8/#ejercicio-82-agregar-registro-a-un-modulo","text":"En fileparse.py , hay alg\u00fan manejo de errores relacionado con las excepciones causadas por una entrada incorrecta. Se parece a esto: # fileparse.py import csv def parse_csv(lines, select=None, types=None, has_headers=True, delimiter=',', silence_errors=False): ''' Parse a CSV file into a list of records with type conversion. ''' if select and not has_headers: raise RuntimeError('select requires column headers') rows = csv.reader(lines, delimiter=delimiter) # lee el encabezado (si es que existe) headers = next(rows) if has_headers else [] # si columnas especificas fueron seleccionadas, haga indices para filtrar y defina las columnas de salida if select: indices = [ headers.index(colname) for colname in select ] headers = select records = [] for rowno, row in enumerate(rows, 1): if not row: # salte las columnas sin data continue # si columnas especificas son seleccionadas, seleccionelas if select: row = [ row[index] for index in indices] # aplique la conversi\u00f3n de tipo a la fila if types: try: row = [func(val) for func, val in zip(types, row)] except ValueError as e: if not silence_errors: print(f\"Row {rowno}: Couldn't convert {row}\") print(f\"Row {rowno}: Reason {e}\") continue # haga un diccionario o una tupla if headers: record = dict(zip(headers, row)) else: record = tuple(row) records.append(record) return records Observe las declaraciones impresas que emiten mensajes de diagn\u00f3stico. Reemplazar esas impresiones con operaciones de registro es relativamente simple. Cambie el c\u00f3digo as\u00ed: # fileparse.py import csv import logging log = logging.getLogger(__name__) def parse_csv(lines, select=None, types=None, has_headers=True, delimiter=',', silence_errors=False): ''' Parse a CSV file into a list of records with type conversion. ''' if select and not has_headers: raise RuntimeError('select requires column headers') rows = csv.reader(lines, delimiter=delimiter) # lee el encabezado (si es que existe) headers = next(rows) if has_headers else [] # si columnas especificas fueron seleccionadas, haga indices para filtrar y defina las columnas de salida if select: indices = [ headers.index(colname) for colname in select ] headers = select records = [] for rowno, row in enumerate(rows, 1): if not row: # salte las columnas sin data continue # si columnas especificas son seleccionadas, seleccionelas if select: row = [ row[index] for index in indices] # aplique la conversi\u00f3n de tipo a la fila if types: try: row = [func(val) for func, val in zip(types, row)] except ValueError as e: if not silence_errors: log.warning(\"Row %d: Couldn't convert %s\", rowno, row) log.debug(\"Row %d: Reason %s\", rowno, e) continue # haga un diccionario o una tupla if headers: record = dict(zip(headers, row)) else: record = tuple(row) records.append(record) return records Ahora que ha realizado estos cambios, intente utilizar parte de su c\u00f3digo en datos incorrectos. >>> import report >>> a = report.read_portfolio('Data/missing.csv') Row 4: Bad row: ['MSFT', '', '51.23'] Row 7: Bad row: ['IBM', '', '70.44'] >>> Si no hace nada, solo recibir\u00e1 mensajes de registro para el WARNING nivel y superior. La salida se ver\u00e1 como simples declaraciones impresas. Sin embargo, si configura el m\u00f3dulo de registro, obtendr\u00e1 informaci\u00f3n adicional sobre los niveles de registro, el m\u00f3dulo y m\u00e1s. Escriba estos pasos para ver que: >>> import logging >>> logging.basicConfig() >>> a = report.read_portfolio('Data/missing.csv') WARNING:fileparse:Row 4: Bad row: ['MSFT', '', '51.23'] WARNING:fileparse:Row 7: Bad row: ['IBM', '', '70.44'] >>> Notar\u00e1 que no ve el resultado de la operaci\u00f3n log.debug() . Escriba esto para cambiar el nivel. >>> logging.getLogger('fileparse').level = logging.DEBUG >>> a = report.read_portfolio('Data/missing.csv') WARNING:fileparse:Row 4: Bad row: ['MSFT', '', '51.23'] DEBUG:fileparse:Row 4: Reason: invalid literal for int() with base 10: '' WARNING:fileparse:Row 7: Bad row: ['IBM', '', '70.44'] DEBUG:fileparse:Row 7: Reason: invalid literal for int() with base 10: '' >>> Apague todos, excepto los mensajes de registro m\u00e1s cr\u00edticos: >>> logging.getLogger('fileparse').level=logging.CRITICAL >>> a = report.read_portfolio('Data/missing.csv') >>>","title":"Ejercicio 8.2: Agregar registro a un m\u00f3dulo"},{"location":"8/#ejercicio-83-agregar-registro-a-un-programa","text":"Para agregar registro a una aplicaci\u00f3n, necesita tener alg\u00fan mecanismo para inicializar el m\u00f3dulo de registro en el m\u00f3dulo principal. Una forma de hacerlo es incluir un c\u00f3digo de configuraci\u00f3n que se parezca a esto: # Este archivo crea configuraci\u00f3n basica del modulo logging # Cambie la configuracion aqui para ajustar la salida de logging import logging logging.basicConfig( filename = 'app.log', # Nombre del archivo (omita para usar stderr) filemode = 'w', # Modo de archivo (use 'a' para adjuntar) level = logging.WARNING, # Nivel de logging (DEBUG, INFO, WARNING, ERROR, or CRITICAL) ) Nuevamente, necesitar\u00eda poner esto en alg\u00fan lugar en los pasos de inicio de su programa. Por ejemplo, \u00bfd\u00f3nde pondr\u00eda esto en su programa report.py ?","title":"Ejercicio 8.3: Agregar registro a un programa"},{"location":"8/#83-depuracion","text":"","title":"8.3 Depuraci\u00f3n"},{"location":"8/#831-sugerencias-de-depuracion","text":"Entonces, su programa se bloque\u00f3... bash % python3 blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", 4, in spam line x.append(3) AttributeError: 'int' object has no attribute 'append' \u00a1\u00bfAhora que?!","title":"8.3.1 Sugerencias de depuraci\u00f3n"},{"location":"8/#832-lectura-de-trazas","text":"La \u00faltima l\u00ednea es la causa espec\u00edfica del accidente. bash % python3 blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", 4, in spam line x.append(3) # Cause of the crash AttributeError: 'int' object has no attribute 'append' Sin embargo, no siempre es f\u00e1cil de leer o comprender. SUGERENCIA PRO: Pegue todo el rastreo en Google.","title":"8.3.2 Lectura de trazas"},{"location":"8/#833-usando-el-repl","text":"Utilice la opci\u00f3n -i para mantener activo Python al ejecutar un script. bash % python3 -i blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", 4, in spam line x.append(3) AttributeError: 'int' object has no attribute 'append' >>> Conserva el estado de int\u00e9rprete. Eso significa que puedes andar hurgando despu\u00e9s del accidente. Comprobaci\u00f3n de valores de variables y otros estados.","title":"8.3.3 Usando el REPL"},{"location":"8/#834-depurar-con-impresion","text":"print() la depuraci\u00f3n es bastante com\u00fan. Consejo: aseg\u00farese de utilizar repr() def spam(x): print('DEBUG:', repr(x)) ... repr() le muestra una representaci\u00f3n precisa de un valor. No es el resultado de impresi\u00f3n agradable. >>> from decimal import Decimal >>> x = Decimal('3.4') # SIN `repr` >>> print(x) 3.4 # CON `repr` >>> print(repr(x)) Decimal('3.4') >>>","title":"8.3.4 Depurar con impresi\u00f3n"},{"location":"8/#835-el-depurador-de-python","text":"Puede iniciar manualmente el depurador dentro de un programa. def some_function(): ... breakpoint() # Ingrese al depurador (Python 3.7+) ... Esto inicia el depurador en la llamada breakpoint() . En versiones anteriores de Python, hiciste esto. A veces ver\u00e1 esto mencionado en otras gu\u00edas de depuraci\u00f3n. import pdb ... pdb.set_trace() # En vez de `breakpoint()`...","title":"8.3.5 El depurador de Python"},{"location":"8/#836-ejecutar-bajo-depurador","text":"Tambi\u00e9n puede ejecutar un programa completo en el depurador. bash % python3 -m pdb someprogram.py Autom\u00e1ticamente ingresar\u00e1 al depurador antes de la primera declaraci\u00f3n. Permiti\u00e9ndole establecer puntos de interrupci\u00f3n y cambiar la configuraci\u00f3n. Comandos habituales del depurador: (Pdb) help # ayuda (Pdb) w(here) # imprima el rastreo (Pdb) d(own) # hacia arriba (Pdb) u(p) # hacia abajo (Pdb) b(reak) loc # fije un breakpoint (Pdb) s(tep) # ejecute una instruccion (Pdb) c(ontinue) # continue la ejecucion (Pdb) l(ist) # liste el codigo fuente (Pdb) a(rgs) # imprima los argumentos de la funcion (Pdb) !statement # ejectue la declaracion La ubicaci\u00f3n de los puntos de interrupci\u00f3n es una de las siguientes. (Pdb) b 45 # linea 45 en el archivo actual (Pdb) b file.py:45 # linea 34 en file.py (Pdb) b foo # funcion foo() en el archivo actual (Pdb) b module.foo # funcion foo() en el modulo","title":"8.3.6 Ejecutar bajo depurador"},{"location":"8/#837-ejercicios","text":"","title":"8.3.7 Ejercicios"},{"location":"8/#ejercicio-84-errores-que-errores","text":"Corre. \u00a1Env\u00edalo!","title":"Ejercicio 8.4: \u00bfErrores? \u00bfQu\u00e9 errores?"},{"location":"9/","text":"Paquetes Concluiremos el curso con algunos detalles para la organizaci\u00f3n de c\u00f3digo en paquetes. Adem\u00e1s, discutiremos sobre la instalaci\u00f3n de paquetes de terceros y sobre la preparaci\u00f3n necesaria para entregarle nuestro c\u00f3digo a otros. El tema de empaquetamiento de c\u00f3digo essta en constante evoluci\u00f3n y es una parte compleja en el desarrollo de Python. Por tanto, esta secci\u00f3n esta enfocada en compartir algunos principios de organizaci\u00f3n general de c\u00f3digo. 9.1 Paquetes Si est\u00e1 escribiendo un programa m\u00e1s grande, realmente no desea organizarlo como una gran colecci\u00f3n de archivos independientes en el nivel superior. Esta secci\u00f3n presenta el concepto de paquete. 9.1.1 M\u00f3dulos Cualquier archivo fuente de Python es un m\u00f3dulo. # foo.py def grok(a): ... def spam(b): ... Una declaraci\u00f3n import carga y ejecuta un m\u00f3dulo. # program.py import foo a = foo.grok(2) b = foo.spam('Hello') ... 9.1.2 Paquetes vs M\u00f3dulos Para colecciones m\u00e1s grandes de c\u00f3digo, es com\u00fan organizar los m\u00f3dulos en un paquete. # From this pcost.py report.py fileparse.py # To this porty/ __init__.py pcost.py report.py fileparse.py Elige un nombre y crea un directorio de nivel superior. porty en el ejemplo anterior (claramente elegir este nombre es el primer paso m\u00e1s importante). Agregue un archivo __init__.py al directorio. Puede estar vac\u00edo. Coloque sus archivos de origen en el directorio. 9.1.3 Usando un paquete Un paquete sirve como espacio de nombres para las importaciones. Esto significa que ahora hay importaciones multinivel. import porty.report port = porty.report.read_portfolio('port.csv') Hay otras variaciones de declaraciones de importaci\u00f3n. from porty import report port = report.read_portfolio('portfolio.csv') from porty.report import read_portfolio port = read_portfolio('portfolio.csv') Dos problemas Hay dos problemas principales con este enfoque. importa entre archivos en el mismo paquete. Scripts principales colocados dentro del paquete. Entonces, b\u00e1sicamente todo se rompe. Pero, aparte de eso, funciona. 9.1.4 Problema: Importaciones Las importaciones entre archivos en el mismo paquete ahora deben incluir el nombre del paquete en la importaci\u00f3n . Recuerda la estructura. porty/ __init__.py pcost.py report.py fileparse.py Ejemplo de importaci\u00f3n modificado. # report.py from porty import fileparse def read_portfolio(filename): return fileparse.parse_csv(...) Todas las importaciones son absolutas, no relativas. # report.py import fileparse # Se ROMPE. fileparse not found ... 9.1.5 Importaciones relativas En lugar de usar directamente el nombre del paquete, puede usar . para hacer referencia al paquete actual. # report.py from . import fileparse def read_portfolio(filename): return fileparse.parse_csv(...) Sintaxis: from . import modname Esto facilita el cambio de nombre del paquete. 9.1.6 Problema: guiones principales La ejecuci\u00f3n de un subm\u00f3dulo de paquete como un script principal se rompe. bash $ python porty/pcost.py # BREAKS ... Motivo: est\u00e1 ejecutando Python en un solo archivo y Python no ve el resto de la estructura del paquete correctamente ( sys.path es incorrecto). Todas las importaciones se rompen. Para solucionar este problema, debe ejecutar su programa de una manera diferente, usando la opci\u00f3n -m . bash $ python -m porty.pcost # WORKS ... 9.1.7 archivos __init__.py El prop\u00f3sito principal de estos archivos es unir m\u00f3dulos. Ejemplo: consolidar funciones # porty/__init__.py from .pcost import portfolio_cost from .report import portfolio_report Esto hace que los nombres aparezcan en el nivel superior al importar. from porty import portfolio_cost portfolio_cost('portfolio.csv') En lugar de utilizar las importaciones multinivel. from porty import pcost pcost.portfolio_cost('portfolio.csv') 9.1.8 Otra soluci\u00f3n para scripts Como se se\u00f1al\u00f3, ahora debe usar -m paqute.modulo para ejecutar scripts dentro de su paquete. bash % python3 -m porty.pcost portfolio.csv Hay otra alternativa: escriba un nuevo script de nivel superior. #!/usr/bin/env python3 # pcost.py import porty.pcost import sys porty.pcost.main(sys.argv) Este script vive fuera del paquete. Por ejemplo, mirando la estructura del directorio: pcost.py # guion de nviel superior porty/ # directorio del paquete __init__.py pcost.py ... 9.1.9 Estructura de la aplicaci\u00f3n La organizaci\u00f3n del c\u00f3digo y la estructura de archivos es clave para el mantenimiento de una aplicaci\u00f3n. No existe un enfoque de \"talla \u00fanica\" para Python. Sin embargo, una estructura que funciona para muchos problemas es algo como esto. porty-app/ README.txt script.py # SCRIPT porty/ # codigo de la biblioteca / libreria __init__.py pcost.py report.py fileparse.py El nivel superior porty-app es un contenedor para todo lo dem\u00e1s: documentaci\u00f3n, scripts de nivel superior, ejemplos, etc. Nuevamente, los scripts de nivel superior (si los hay) deben existir fuera del paquete de c\u00f3digo. Un nivel m\u00e1s. #!/usr/bin/env python3 # porty-app/script.py import sys import porty porty.report.main(sys.argv) 9.1.10 Ejercicios En este punto, tiene un directorio con varios programas: pcost.py # computes portfolio cost report.py # Makes a report ticker.py # Produce a real-time stock ticker Hay una variedad de m\u00f3dulos de soporte con otras funcionalidades: stock.py # Stock class portfolio.py # Portfolio class fileparse.py # CSV parsing tableformat.py # Formatted tables follow.py # Follow a log file typedproperty.py # Typed class properties En este ejercicio, vamos a limpiar el c\u00f3digo y ponerlo en un paquete com\u00fan. Ejercicio 9.1: Hacer un paquete simple Cree un directorio llamado porty/y coloque todos los archivos de Python anteriores en \u00e9l. Adem\u00e1s, cree un init .pyarchivo vac\u00edo y col\u00f3quelo en el directorio. Deber\u00eda tener un directorio de archivos como este: porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Elimina el archivo __pycache__ que est\u00e1 en tu directorio. Este contiene m\u00f3dulos de Python precompilados de antes. Queremos empezar de nuevo. Intente importar algunos de los m\u00f3dulos del paquete: >>> import porty.report >>> import porty.pcost >>> import porty.ticker Si estas importaciones fallan, vaya al archivo apropiado y corrija las importaciones del m\u00f3dulo para incluir una importaci\u00f3n relativa al paquete. Por ejemplo, una declaraci\u00f3n como import fileparse podr\u00eda cambiar a lo siguiente: # report.py from . import fileparse ... Si tiene una declaraci\u00f3n como from fileparse import parse_csv, cambie el c\u00f3digo a lo siguiente: # report.py from .fileparse import parse_csv ... Ejercicio 9.2: Crear un directorio de aplicaciones Poner todo su c\u00f3digo en un \"paquete\" no suele ser suficiente para una aplicaci\u00f3n. A veces hay archivos de apoyo, documentaci\u00f3n, scripts y otras cosas. Estos archivos deben existir FUERA del directorio porty/ que cre\u00f3 anteriormente. Cree un nuevo directorio llamado porty-app. Mueva el portydirectorio que cre\u00f3 en el ejercicio 9.1 a ese directorio. Copie los archivos de prueba Data/portfolio.csv y Data/prices.csv en este directorio. Adem\u00e1s, cree un archivo README.txt con informaci\u00f3n sobre usted. Su c\u00f3digo ahora deber\u00eda estar organizado de la siguiente manera: porty-app/ portfolio.csv prices.csv README.txt porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Para ejecutar su c\u00f3digo, debe asegurarse de estar trabajando en el directorio porty-app/ de nivel superior . Por ejemplo, desde la terminal: shell % cd porty-app shell % python3 >>> import porty.report >>> Intente ejecutar algunos de sus scripts anteriores como programa principal: shell % cd porty-app shell % python3 -m porty.report portfolio.csv prices.csv txt Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 shell % Ejercicio 9.3: Scripts de nivel superior Usar el comando python -m suele ser un poco extra\u00f1o. Es posible que desee escribir un script de nivel superior que simplemente se ocupe de las rarezas de los paquetes. Cree un script print-report.py que produzca el informe anterior: #!/usr/bin/env python3 # print-report.py import sys from porty.report import main main(sys.argv) Coloque este script en el directorio porty-app/ de nivel superior. Aseg\u00farese de poder ejecutarlo en esa ubicaci\u00f3n: shell % cd porty-app shell % python3 print-report.py portfolio.csv prices.csv txt Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 shell % Su c\u00f3digo final ahora deber\u00eda estar estructurado de esta manera: porty-app/ portfolio.csv prices.csv print-report.py README.txt porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py 9.2 M\u00f3dulos de terceros Python tiene una gran biblioteca de m\u00f3dulos integrados (bater\u00edas incluidas). Incluso hay m\u00e1s m\u00f3dulos de terceros. Compru\u00e9belos en el \u00edndice de paquetes de Python o PyPi. O simplemente haga una b\u00fasqueda en Google de un tema espec\u00edfico. C\u00f3mo manejar las dependencias de terceros es un tema en constante evoluci\u00f3n con Python. Esta secci\u00f3n simplemente cubre los conceptos b\u00e1sicos para ayudarlo a comprender c\u00f3mo funciona. 9.2.1 La ruta de b\u00fasqueda del m\u00f3dulo sys.path es un directorio que contiene la lista de todos los directorios controlados por la declaraci\u00f3n import . M\u00edralo: >>> import sys >>> sys.path ... look at the result ... >>> Si importa algo y no est\u00e1 ubicado en uno de esos directorios, obtendr\u00e1 una excepci\u00f3n ImportError . 9.2.2 M\u00f3dulos de biblioteca est\u00e1ndar Los m\u00f3dulos de la biblioteca est\u00e1ndar de Python generalmente provienen de una ubicaci\u00f3n como /usr/local/lib/python3.6 . Puede averiguarlo con certeza haciendo una prueba breve: >>> import re >>> re <module 're' from '/usr/local/lib/python3.6/re.py'> >>> Simplemente mirar un m\u00f3dulo en el REPL es un buen consejo de depuraci\u00f3n que debe conocer. Le mostrar\u00e1 la ubicaci\u00f3n del archivo. 9.2.3 M\u00f3dulos de terceros Los m\u00f3dulos de terceros generalmente se encuentran en un directorio dedicado site-packages . Lo ver\u00e1 si realiza los mismos pasos que el anterior: >>> import numpy >>> numpy <module 'numpy' from '/usr/local/lib/python3.6/site-packages/numpy/__init__.py'> >>> Nuevamente, mirar un m\u00f3dulo es un buen consejo de depuraci\u00f3n si est\u00e1 tratando de averiguar por qu\u00e9 algo relacionado con import no est\u00e1 funcionando como se esperaba. 9.2.4 Instalaci\u00f3n de m\u00f3dulos La t\u00e9cnica m\u00e1s com\u00fan para instalar un m\u00f3dulo de terceros es usar pip . Por ejemplo: bash % python3 -m pip install packagename Este comando descargar\u00e1 el paquete y lo instalar\u00e1 en el directorio site-packages . 9.2.5 Problemas Es posible que est\u00e9 utilizando una instalaci\u00f3n de Python que no controla directamente. Una instalaci\u00f3n aprobada por la empresa Est\u00e1s usando la versi\u00f3n de Python que viene con el sistema operativo. Es posible que no tenga permiso para instalar paquetes globales en la computadora. Puede haber otras dependencias. 9.2.6 Ambientes virtuales Una soluci\u00f3n com\u00fan para los problemas de instalaci\u00f3n de paquetes es crear un \"entorno virtual\" para usted. Naturalmente, no hay \"una manera\" de hacer esto; de hecho, existen varias herramientas y t\u00e9cnicas en competencia. Sin embargo, si est\u00e1 utilizando una instalaci\u00f3n est\u00e1ndar de Python, puede intentar escribir esto: bash % python -m venv mypython bash % Despu\u00e9s de unos momentos de espera, tendr\u00e1 un nuevo directorio mypython que es su propia instalaci\u00f3n de Python. Dentro de ese directorio encontrar\u00e1 un directorio bin/ (Unix) o un directorio Scripts/ (Windows). Si ejecuta el script activate que se encuentra all\u00ed, \u201cactivar\u00e1\u201d esta versi\u00f3n de Python, convirti\u00e9ndola en el comando python predeterminado para el shell. Por ejemplo: bash % source mypython/bin/activate (mypython) bash % Desde aqu\u00ed, ahora puede comenzar a instalar paquetes de Python usted mismo. Por ejemplo: (mypython) bash % python -m pip install pandas ... Con el fin de experimentar y probar diferentes paquetes, un entorno virtual normalmente funcionar\u00e1 bien. Si, por otro lado, est\u00e1 creando una aplicaci\u00f3n y tiene dependencias de paquetes espec\u00edficas, ese es un problema ligeramente diferente. 9.2.7 Manejo de dependencias de terceros en su aplicaci\u00f3n Si ha escrito una aplicaci\u00f3n y tiene dependencias espec\u00edficas de terceros, un desaf\u00edo se refiere a la creaci\u00f3n y preservaci\u00f3n del entorno que incluye su c\u00f3digo y las dependencias. Lamentablemente, esta ha sido un \u00e1rea de gran confusi\u00f3n y cambios frecuentes durante la vida de Python. Contin\u00faa evolucionando incluso ahora. En lugar de proporcionar informaci\u00f3n que seguramente estar\u00e1 desactualizada pronto, le recomiendo la Gu\u00eda del usuario de Python Packaging. 9.2.8 Ejercicios Ejercicio 9.4: Creaci\u00f3n de un entorno virtual Vea si puede recrear los pasos para crear un entorno virtual e instalar pandas en \u00e9l como se muestra arriba. 9.3 Distribuci\u00f3n En alg\u00fan momento, es posible que desee dar su c\u00f3digo a otra persona, posiblemente solo a un compa\u00f1ero de trabajo. Esta secci\u00f3n brinda la t\u00e9cnica m\u00e1s b\u00e1sica para hacerlo. Para obtener informaci\u00f3n m\u00e1s detallada, deber\u00e1 consultar la Gu\u00eda del usuario de empaquetado de Python. 9.3.1 Creando un archivo setup.py Agregue un archivo setup.py al nivel superior del directorio de su proyecto. # setup.py import setuptools setuptools.setup( name=\"porty\", version=\"0.0.1\", author=\"Your Name\", author_email=\"you@example.com\", description=\"Practical Python Code\", packages=setuptools.find_packages(), ) 9.3.2 Creando MANIFEST.in Si hay archivos adicionales asociados con su proyecto, especif\u00edquelos con un MANIFEST.inarchivo. Por ejemplo: # MANIFEST.in include *.csv Coloque el archivo MANIFEST.in en el mismo directorio que setup.py . 9.3.2 Crear una distribuci\u00f3n de origen Para crear una distribuci\u00f3n de su c\u00f3digo, use el archivo setup.py . Por ejemplo: bash % python setup.py sdist Esto crear\u00e1 un archivo .tar.gzo.zip en el directorio dist/ . Ese archivo es algo que ahora puede regalar a otros. 9.3.3 Instalando su c\u00f3digo Otros pueden instalar su c\u00f3digo Python usando pi p de la misma manera que lo hacen con otros paquetes. Simplemente deben proporcionar el archivo creado en el paso anterior. Por ejemplo: bash % python -m pip install porty-0.0.1.tar.gz Comentario Los pasos anteriores describen los conceptos b\u00e1sicos m\u00e1s m\u00ednimos para crear un paquete de c\u00f3digo Python que puede darle a otra persona. En realidad, puede ser mucho m\u00e1s complicado dependiendo de las dependencias de terceros, si su aplicaci\u00f3n incluye o no c\u00f3digo externo (es decir, C / C ++), etc. Cubrir eso est\u00e1 fuera del alcance de este curso. Solo hemos dado un peque\u00f1o primer paso. 9.3.4 Ejercicios Ejercicio 9.5: hacer un paquete Tome el c\u00f3digo porty-app/ que cre\u00f3 para el ejercicio 9.3 y vea si puede recrear los pasos descritos aqu\u00ed. Espec\u00edficamente, agregue un archivo setup.py y un archivo MANIFEST.in al directorio de nivel superior. Cree un archivo de distribuci\u00f3n de origen ejecutando python setup.py sdist . Como paso final, vea si puede instalar su paquete en un entorno virtual de Python.","title":"9 Paquetes"},{"location":"9/#paquetes","text":"Concluiremos el curso con algunos detalles para la organizaci\u00f3n de c\u00f3digo en paquetes. Adem\u00e1s, discutiremos sobre la instalaci\u00f3n de paquetes de terceros y sobre la preparaci\u00f3n necesaria para entregarle nuestro c\u00f3digo a otros. El tema de empaquetamiento de c\u00f3digo essta en constante evoluci\u00f3n y es una parte compleja en el desarrollo de Python. Por tanto, esta secci\u00f3n esta enfocada en compartir algunos principios de organizaci\u00f3n general de c\u00f3digo.","title":"Paquetes"},{"location":"9/#91-paquetes","text":"Si est\u00e1 escribiendo un programa m\u00e1s grande, realmente no desea organizarlo como una gran colecci\u00f3n de archivos independientes en el nivel superior. Esta secci\u00f3n presenta el concepto de paquete.","title":"9.1 Paquetes"},{"location":"9/#911-modulos","text":"Cualquier archivo fuente de Python es un m\u00f3dulo. # foo.py def grok(a): ... def spam(b): ... Una declaraci\u00f3n import carga y ejecuta un m\u00f3dulo. # program.py import foo a = foo.grok(2) b = foo.spam('Hello') ...","title":"9.1.1 M\u00f3dulos"},{"location":"9/#912-paquetes-vs-modulos","text":"Para colecciones m\u00e1s grandes de c\u00f3digo, es com\u00fan organizar los m\u00f3dulos en un paquete. # From this pcost.py report.py fileparse.py # To this porty/ __init__.py pcost.py report.py fileparse.py Elige un nombre y crea un directorio de nivel superior. porty en el ejemplo anterior (claramente elegir este nombre es el primer paso m\u00e1s importante). Agregue un archivo __init__.py al directorio. Puede estar vac\u00edo. Coloque sus archivos de origen en el directorio.","title":"9.1.2 Paquetes vs M\u00f3dulos"},{"location":"9/#913-usando-un-paquete","text":"Un paquete sirve como espacio de nombres para las importaciones. Esto significa que ahora hay importaciones multinivel. import porty.report port = porty.report.read_portfolio('port.csv') Hay otras variaciones de declaraciones de importaci\u00f3n. from porty import report port = report.read_portfolio('portfolio.csv') from porty.report import read_portfolio port = read_portfolio('portfolio.csv') Dos problemas Hay dos problemas principales con este enfoque. importa entre archivos en el mismo paquete. Scripts principales colocados dentro del paquete. Entonces, b\u00e1sicamente todo se rompe. Pero, aparte de eso, funciona.","title":"9.1.3 Usando un paquete"},{"location":"9/#914-problema-importaciones","text":"Las importaciones entre archivos en el mismo paquete ahora deben incluir el nombre del paquete en la importaci\u00f3n . Recuerda la estructura. porty/ __init__.py pcost.py report.py fileparse.py Ejemplo de importaci\u00f3n modificado. # report.py from porty import fileparse def read_portfolio(filename): return fileparse.parse_csv(...) Todas las importaciones son absolutas, no relativas. # report.py import fileparse # Se ROMPE. fileparse not found ...","title":"9.1.4 Problema: Importaciones"},{"location":"9/#915-importaciones-relativas","text":"En lugar de usar directamente el nombre del paquete, puede usar . para hacer referencia al paquete actual. # report.py from . import fileparse def read_portfolio(filename): return fileparse.parse_csv(...) Sintaxis: from . import modname Esto facilita el cambio de nombre del paquete.","title":"9.1.5 Importaciones relativas"},{"location":"9/#916-problema-guiones-principales","text":"La ejecuci\u00f3n de un subm\u00f3dulo de paquete como un script principal se rompe. bash $ python porty/pcost.py # BREAKS ... Motivo: est\u00e1 ejecutando Python en un solo archivo y Python no ve el resto de la estructura del paquete correctamente ( sys.path es incorrecto). Todas las importaciones se rompen. Para solucionar este problema, debe ejecutar su programa de una manera diferente, usando la opci\u00f3n -m . bash $ python -m porty.pcost # WORKS ...","title":"9.1.6 Problema: guiones principales"},{"location":"9/#917-archivos-__init__py","text":"El prop\u00f3sito principal de estos archivos es unir m\u00f3dulos. Ejemplo: consolidar funciones # porty/__init__.py from .pcost import portfolio_cost from .report import portfolio_report Esto hace que los nombres aparezcan en el nivel superior al importar. from porty import portfolio_cost portfolio_cost('portfolio.csv') En lugar de utilizar las importaciones multinivel. from porty import pcost pcost.portfolio_cost('portfolio.csv')","title":"9.1.7 archivos __init__.py"},{"location":"9/#918-otra-solucion-para-scripts","text":"Como se se\u00f1al\u00f3, ahora debe usar -m paqute.modulo para ejecutar scripts dentro de su paquete. bash % python3 -m porty.pcost portfolio.csv Hay otra alternativa: escriba un nuevo script de nivel superior. #!/usr/bin/env python3 # pcost.py import porty.pcost import sys porty.pcost.main(sys.argv) Este script vive fuera del paquete. Por ejemplo, mirando la estructura del directorio: pcost.py # guion de nviel superior porty/ # directorio del paquete __init__.py pcost.py ...","title":"9.1.8 Otra soluci\u00f3n para scripts"},{"location":"9/#919-estructura-de-la-aplicacion","text":"La organizaci\u00f3n del c\u00f3digo y la estructura de archivos es clave para el mantenimiento de una aplicaci\u00f3n. No existe un enfoque de \"talla \u00fanica\" para Python. Sin embargo, una estructura que funciona para muchos problemas es algo como esto. porty-app/ README.txt script.py # SCRIPT porty/ # codigo de la biblioteca / libreria __init__.py pcost.py report.py fileparse.py El nivel superior porty-app es un contenedor para todo lo dem\u00e1s: documentaci\u00f3n, scripts de nivel superior, ejemplos, etc. Nuevamente, los scripts de nivel superior (si los hay) deben existir fuera del paquete de c\u00f3digo. Un nivel m\u00e1s. #!/usr/bin/env python3 # porty-app/script.py import sys import porty porty.report.main(sys.argv)","title":"9.1.9 Estructura de la aplicaci\u00f3n"},{"location":"9/#9110-ejercicios","text":"En este punto, tiene un directorio con varios programas: pcost.py # computes portfolio cost report.py # Makes a report ticker.py # Produce a real-time stock ticker Hay una variedad de m\u00f3dulos de soporte con otras funcionalidades: stock.py # Stock class portfolio.py # Portfolio class fileparse.py # CSV parsing tableformat.py # Formatted tables follow.py # Follow a log file typedproperty.py # Typed class properties En este ejercicio, vamos a limpiar el c\u00f3digo y ponerlo en un paquete com\u00fan.","title":"9.1.10 Ejercicios"},{"location":"9/#ejercicio-91-hacer-un-paquete-simple","text":"Cree un directorio llamado porty/y coloque todos los archivos de Python anteriores en \u00e9l. Adem\u00e1s, cree un init .pyarchivo vac\u00edo y col\u00f3quelo en el directorio. Deber\u00eda tener un directorio de archivos como este: porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Elimina el archivo __pycache__ que est\u00e1 en tu directorio. Este contiene m\u00f3dulos de Python precompilados de antes. Queremos empezar de nuevo. Intente importar algunos de los m\u00f3dulos del paquete: >>> import porty.report >>> import porty.pcost >>> import porty.ticker Si estas importaciones fallan, vaya al archivo apropiado y corrija las importaciones del m\u00f3dulo para incluir una importaci\u00f3n relativa al paquete. Por ejemplo, una declaraci\u00f3n como import fileparse podr\u00eda cambiar a lo siguiente: # report.py from . import fileparse ... Si tiene una declaraci\u00f3n como from fileparse import parse_csv, cambie el c\u00f3digo a lo siguiente: # report.py from .fileparse import parse_csv ...","title":"Ejercicio 9.1: Hacer un paquete simple"},{"location":"9/#ejercicio-92-crear-un-directorio-de-aplicaciones","text":"Poner todo su c\u00f3digo en un \"paquete\" no suele ser suficiente para una aplicaci\u00f3n. A veces hay archivos de apoyo, documentaci\u00f3n, scripts y otras cosas. Estos archivos deben existir FUERA del directorio porty/ que cre\u00f3 anteriormente. Cree un nuevo directorio llamado porty-app. Mueva el portydirectorio que cre\u00f3 en el ejercicio 9.1 a ese directorio. Copie los archivos de prueba Data/portfolio.csv y Data/prices.csv en este directorio. Adem\u00e1s, cree un archivo README.txt con informaci\u00f3n sobre usted. Su c\u00f3digo ahora deber\u00eda estar organizado de la siguiente manera: porty-app/ portfolio.csv prices.csv README.txt porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py Para ejecutar su c\u00f3digo, debe asegurarse de estar trabajando en el directorio porty-app/ de nivel superior . Por ejemplo, desde la terminal: shell % cd porty-app shell % python3 >>> import porty.report >>> Intente ejecutar algunos de sus scripts anteriores como programa principal: shell % cd porty-app shell % python3 -m porty.report portfolio.csv prices.csv txt Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 shell %","title":"Ejercicio 9.2: Crear un directorio de aplicaciones"},{"location":"9/#ejercicio-93-scripts-de-nivel-superior","text":"Usar el comando python -m suele ser un poco extra\u00f1o. Es posible que desee escribir un script de nivel superior que simplemente se ocupe de las rarezas de los paquetes. Cree un script print-report.py que produzca el informe anterior: #!/usr/bin/env python3 # print-report.py import sys from porty.report import main main(sys.argv) Coloque este script en el directorio porty-app/ de nivel superior. Aseg\u00farese de poder ejecutarlo en esa ubicaci\u00f3n: shell % cd porty-app shell % python3 print-report.py portfolio.csv prices.csv txt Name Shares Price Change ---------- ---------- ---------- ---------- AA 100 9.22 -22.98 IBM 50 106.28 15.18 CAT 150 35.46 -47.98 MSFT 200 20.89 -30.34 GE 95 13.48 -26.89 MSFT 50 20.89 -44.21 IBM 100 106.28 35.84 shell % Su c\u00f3digo final ahora deber\u00eda estar estructurado de esta manera: porty-app/ portfolio.csv prices.csv print-report.py README.txt porty/ __init__.py fileparse.py follow.py pcost.py portfolio.py report.py stock.py tableformat.py ticker.py typedproperty.py","title":"Ejercicio 9.3: Scripts de nivel superior"},{"location":"9/#92-modulos-de-terceros","text":"Python tiene una gran biblioteca de m\u00f3dulos integrados (bater\u00edas incluidas). Incluso hay m\u00e1s m\u00f3dulos de terceros. Compru\u00e9belos en el \u00edndice de paquetes de Python o PyPi. O simplemente haga una b\u00fasqueda en Google de un tema espec\u00edfico. C\u00f3mo manejar las dependencias de terceros es un tema en constante evoluci\u00f3n con Python. Esta secci\u00f3n simplemente cubre los conceptos b\u00e1sicos para ayudarlo a comprender c\u00f3mo funciona.","title":"9.2 M\u00f3dulos de terceros"},{"location":"9/#921-la-ruta-de-busqueda-del-modulo","text":"sys.path es un directorio que contiene la lista de todos los directorios controlados por la declaraci\u00f3n import . M\u00edralo: >>> import sys >>> sys.path ... look at the result ... >>> Si importa algo y no est\u00e1 ubicado en uno de esos directorios, obtendr\u00e1 una excepci\u00f3n ImportError .","title":"9.2.1 La ruta de b\u00fasqueda del m\u00f3dulo"},{"location":"9/#922-modulos-de-biblioteca-estandar","text":"Los m\u00f3dulos de la biblioteca est\u00e1ndar de Python generalmente provienen de una ubicaci\u00f3n como /usr/local/lib/python3.6 . Puede averiguarlo con certeza haciendo una prueba breve: >>> import re >>> re <module 're' from '/usr/local/lib/python3.6/re.py'> >>> Simplemente mirar un m\u00f3dulo en el REPL es un buen consejo de depuraci\u00f3n que debe conocer. Le mostrar\u00e1 la ubicaci\u00f3n del archivo.","title":"9.2.2 M\u00f3dulos de biblioteca est\u00e1ndar"},{"location":"9/#923-modulos-de-terceros","text":"Los m\u00f3dulos de terceros generalmente se encuentran en un directorio dedicado site-packages . Lo ver\u00e1 si realiza los mismos pasos que el anterior: >>> import numpy >>> numpy <module 'numpy' from '/usr/local/lib/python3.6/site-packages/numpy/__init__.py'> >>> Nuevamente, mirar un m\u00f3dulo es un buen consejo de depuraci\u00f3n si est\u00e1 tratando de averiguar por qu\u00e9 algo relacionado con import no est\u00e1 funcionando como se esperaba.","title":"9.2.3 M\u00f3dulos de terceros"},{"location":"9/#924-instalacion-de-modulos","text":"La t\u00e9cnica m\u00e1s com\u00fan para instalar un m\u00f3dulo de terceros es usar pip . Por ejemplo: bash % python3 -m pip install packagename Este comando descargar\u00e1 el paquete y lo instalar\u00e1 en el directorio site-packages .","title":"9.2.4 Instalaci\u00f3n de m\u00f3dulos"},{"location":"9/#925-problemas","text":"Es posible que est\u00e9 utilizando una instalaci\u00f3n de Python que no controla directamente. Una instalaci\u00f3n aprobada por la empresa Est\u00e1s usando la versi\u00f3n de Python que viene con el sistema operativo. Es posible que no tenga permiso para instalar paquetes globales en la computadora. Puede haber otras dependencias.","title":"9.2.5 Problemas"},{"location":"9/#926-ambientes-virtuales","text":"Una soluci\u00f3n com\u00fan para los problemas de instalaci\u00f3n de paquetes es crear un \"entorno virtual\" para usted. Naturalmente, no hay \"una manera\" de hacer esto; de hecho, existen varias herramientas y t\u00e9cnicas en competencia. Sin embargo, si est\u00e1 utilizando una instalaci\u00f3n est\u00e1ndar de Python, puede intentar escribir esto: bash % python -m venv mypython bash % Despu\u00e9s de unos momentos de espera, tendr\u00e1 un nuevo directorio mypython que es su propia instalaci\u00f3n de Python. Dentro de ese directorio encontrar\u00e1 un directorio bin/ (Unix) o un directorio Scripts/ (Windows). Si ejecuta el script activate que se encuentra all\u00ed, \u201cactivar\u00e1\u201d esta versi\u00f3n de Python, convirti\u00e9ndola en el comando python predeterminado para el shell. Por ejemplo: bash % source mypython/bin/activate (mypython) bash % Desde aqu\u00ed, ahora puede comenzar a instalar paquetes de Python usted mismo. Por ejemplo: (mypython) bash % python -m pip install pandas ... Con el fin de experimentar y probar diferentes paquetes, un entorno virtual normalmente funcionar\u00e1 bien. Si, por otro lado, est\u00e1 creando una aplicaci\u00f3n y tiene dependencias de paquetes espec\u00edficas, ese es un problema ligeramente diferente.","title":"9.2.6 Ambientes virtuales"},{"location":"9/#927-manejo-de-dependencias-de-terceros-en-su-aplicacion","text":"Si ha escrito una aplicaci\u00f3n y tiene dependencias espec\u00edficas de terceros, un desaf\u00edo se refiere a la creaci\u00f3n y preservaci\u00f3n del entorno que incluye su c\u00f3digo y las dependencias. Lamentablemente, esta ha sido un \u00e1rea de gran confusi\u00f3n y cambios frecuentes durante la vida de Python. Contin\u00faa evolucionando incluso ahora. En lugar de proporcionar informaci\u00f3n que seguramente estar\u00e1 desactualizada pronto, le recomiendo la Gu\u00eda del usuario de Python Packaging.","title":"9.2.7 Manejo de dependencias de terceros en su aplicaci\u00f3n"},{"location":"9/#928-ejercicios","text":"","title":"9.2.8 Ejercicios"},{"location":"9/#ejercicio-94-creacion-de-un-entorno-virtual","text":"Vea si puede recrear los pasos para crear un entorno virtual e instalar pandas en \u00e9l como se muestra arriba.","title":"Ejercicio 9.4: Creaci\u00f3n de un entorno virtual"},{"location":"9/#93-distribucion","text":"En alg\u00fan momento, es posible que desee dar su c\u00f3digo a otra persona, posiblemente solo a un compa\u00f1ero de trabajo. Esta secci\u00f3n brinda la t\u00e9cnica m\u00e1s b\u00e1sica para hacerlo. Para obtener informaci\u00f3n m\u00e1s detallada, deber\u00e1 consultar la Gu\u00eda del usuario de empaquetado de Python.","title":"9.3 Distribuci\u00f3n"},{"location":"9/#931-creando-un-archivo-setuppy","text":"Agregue un archivo setup.py al nivel superior del directorio de su proyecto. # setup.py import setuptools setuptools.setup( name=\"porty\", version=\"0.0.1\", author=\"Your Name\", author_email=\"you@example.com\", description=\"Practical Python Code\", packages=setuptools.find_packages(), )","title":"9.3.1 Creando un archivo setup.py"},{"location":"9/#932-creando-manifestin","text":"Si hay archivos adicionales asociados con su proyecto, especif\u00edquelos con un MANIFEST.inarchivo. Por ejemplo: # MANIFEST.in include *.csv Coloque el archivo MANIFEST.in en el mismo directorio que setup.py .","title":"9.3.2 Creando MANIFEST.in"},{"location":"9/#932-crear-una-distribucion-de-origen","text":"Para crear una distribuci\u00f3n de su c\u00f3digo, use el archivo setup.py . Por ejemplo: bash % python setup.py sdist Esto crear\u00e1 un archivo .tar.gzo.zip en el directorio dist/ . Ese archivo es algo que ahora puede regalar a otros.","title":"9.3.2 Crear una distribuci\u00f3n de origen"},{"location":"9/#933-instalando-su-codigo","text":"Otros pueden instalar su c\u00f3digo Python usando pi p de la misma manera que lo hacen con otros paquetes. Simplemente deben proporcionar el archivo creado en el paso anterior. Por ejemplo: bash % python -m pip install porty-0.0.1.tar.gz","title":"9.3.3 Instalando su c\u00f3digo"},{"location":"9/#comentario","text":"Los pasos anteriores describen los conceptos b\u00e1sicos m\u00e1s m\u00ednimos para crear un paquete de c\u00f3digo Python que puede darle a otra persona. En realidad, puede ser mucho m\u00e1s complicado dependiendo de las dependencias de terceros, si su aplicaci\u00f3n incluye o no c\u00f3digo externo (es decir, C / C ++), etc. Cubrir eso est\u00e1 fuera del alcance de este curso. Solo hemos dado un peque\u00f1o primer paso.","title":"Comentario"},{"location":"9/#934-ejercicios","text":"","title":"9.3.4 Ejercicios"},{"location":"9/#ejercicio-95-hacer-un-paquete","text":"Tome el c\u00f3digo porty-app/ que cre\u00f3 para el ejercicio 9.3 y vea si puede recrear los pasos descritos aqu\u00ed. Espec\u00edficamente, agregue un archivo setup.py y un archivo MANIFEST.in al directorio de nivel superior. Cree un archivo de distribuci\u00f3n de origen ejecutando python setup.py sdist . Como paso final, vea si puede instalar su paquete en un entorno virtual de Python.","title":"Ejercicio 9.5: hacer un paquete"},{"location":"faq/","text":"Preguntas Frecuentes Estaremos agregando m\u00e1s preguntas frecuentes en la medida que se formulen. Instalaci\u00f3n No quiero instalar Python, \u00bfpuedo hacer el curso online? Es preferible que haga el curso en su ordenador; sin embargo, plataformas como Repl.it ponen a su disposici\u00f3n un editor y consola con un ambiente de ejecuci\u00f3n Python y una terminal Linux, sin costo alguno. Hemos puesto a su disposici\u00f3n todo lo que necesita en Repl.it para trabajar cada m\u00f3dulo desde el navegador, accediento al enlace proporcionado en el m\u00f3dulo correspondiente. \u00bfD\u00f3nde y c\u00f3mo instalo Python? La respuesta depende de su sistema operativo y modo preferible de instalaci\u00f3n. La forma m\u00e1s com\u00fan de hacerlo es accediendo a la p\u00e1gina oficial de Python, descargar el ejecutable e instalarlo en su ordenador. Ayuda Necesito ayuda, \u00bfd\u00f3nde la consigo? En muchas ocasiones, podemos resolver nuestras dudas leyendo documentaci\u00f3n oficial o haciendo una b\u00fasqueda online. No obstante, una de las mejores cosas que puede hacer es aprender en p\u00fablico e interactuar con otras personas. En ese sentido, la comunidad Python Panam\u00e1 ha puesto a disposici\u00f3n su servidor en Discord, acceda aqu\u00ed .","title":"Preguntas"},{"location":"faq/#preguntas-frecuentes","text":"Estaremos agregando m\u00e1s preguntas frecuentes en la medida que se formulen.","title":"Preguntas Frecuentes"},{"location":"faq/#instalacion","text":"No quiero instalar Python, \u00bfpuedo hacer el curso online? Es preferible que haga el curso en su ordenador; sin embargo, plataformas como Repl.it ponen a su disposici\u00f3n un editor y consola con un ambiente de ejecuci\u00f3n Python y una terminal Linux, sin costo alguno. Hemos puesto a su disposici\u00f3n todo lo que necesita en Repl.it para trabajar cada m\u00f3dulo desde el navegador, accediento al enlace proporcionado en el m\u00f3dulo correspondiente. \u00bfD\u00f3nde y c\u00f3mo instalo Python? La respuesta depende de su sistema operativo y modo preferible de instalaci\u00f3n. La forma m\u00e1s com\u00fan de hacerlo es accediendo a la p\u00e1gina oficial de Python, descargar el ejecutable e instalarlo en su ordenador.","title":"Instalaci\u00f3n"},{"location":"faq/#ayuda","text":"Necesito ayuda, \u00bfd\u00f3nde la consigo? En muchas ocasiones, podemos resolver nuestras dudas leyendo documentaci\u00f3n oficial o haciendo una b\u00fasqueda online. No obstante, una de las mejores cosas que puede hacer es aprender en p\u00fablico e interactuar con otras personas. En ese sentido, la comunidad Python Panam\u00e1 ha puesto a disposici\u00f3n su servidor en Discord, acceda aqu\u00ed .","title":"Ayuda"},{"location":"licencia/","text":"creative commons Attribution-ShareAlike 4.0 International Creative Commons Corporation (\u201cCreative Commons\u201d) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an \u201cas-is\u201d basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible. Using Creative Commons Public Licenses Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses. Considerations for licensors: Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC-licensed material, or material used under an exception or limitation to copyright. More considerations for licensors . Considerations for the public: By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensor\u2019s permission is not necessary for any reason\u2013for example, because of any applicable exception or limitation to copyright\u2013then that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. More considerations for the public . Creative Commons Attribution-ShareAlike 4.0 International Public License By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-ShareAlike 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions. Section 1 \u2013 Definitions. a. Adapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image. b. Adapter's License means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License. c. BY-SA Compatible License means a license listed at creativecommons.org/compatiblelicenses , approved by Creative Commons as essentially the equivalent of this Public License. d. Copyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights. e. Effective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements. f. Exceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material. g. License Elements means the license attributes listed in the name of a Creative Commons Public License. The License Elements of this Public License are Attribution and ShareAlike. h. Licensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License. i. Licensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license. j. Licensor means the individual(s) or entity(ies) granting rights under this Public License. k. Share means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them. l. Sui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world. m. You means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning. Section 2 \u2013 Scope. a. License grant. 1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to: A. reproduce and Share the Licensed Material, in whole or in part; and B. produce, reproduce, and Share Adapted Material. 2. __Exceptions and Limitations.__ For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions. 3. __Term.__ The term of this Public License is specified in Section 6(a). 4. __Media and formats; technical modifications allowed.__ The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material. 5. __Downstream recipients.__ A. __Offer from the Licensor \u2013 Licensed Material.__ Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License. B. __Additional offer from the Licensor \u2013 Adapted Material. Every recipient of Adapted Material from You automatically receives an offer from the Licensor to exercise the Licensed Rights in the Adapted Material under the conditions of the Adapter\u2019s License You apply. C. __No downstream restrictions.__ You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material. 6. __No endorsement.__ Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i). b. Other rights. 1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise. 2. Patent and trademark rights are not licensed under this Public License. 3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties. Section 3 \u2013 License Conditions. Your exercise of the Licensed Rights is expressly made subject to the following conditions. a. Attribution. 1. If You Share the Licensed Material (including in modified form), You must: A. retain the following if it is supplied by the Licensor with the Licensed Material: i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated); ii. a copyright notice; iii. a notice that refers to this Public License; iv. a notice that refers to the disclaimer of warranties; v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable; B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License. 2. You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information. 3. If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable. b. ShareAlike. In addition to the conditions in Section 3(a), if You Share Adapted Material You produce, the following conditions also apply. The Adapter\u2019s License You apply must be a Creative Commons license with the same License Elements, this version or later, or a BY-SA Compatible License. You must include the text of, or the URI or hyperlink to, the Adapter's License You apply. You may satisfy this condition in any reasonable manner based on the medium, means, and context in which You Share Adapted Material. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, Adapted Material that restrict exercise of the rights granted under the Adapter's License You apply. Section 4 \u2013 Sui Generis Database Rights. Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material: a. for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database; b. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material, including for purposes of Section 3(b); and c. You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database. For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights. Section 5 \u2013 Disclaimer of Warranties and Limitation of Liability. a. Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You. b. To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You. c. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability. Section 6 \u2013 Term and Termination. a. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically. b. Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates: 1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or 2. upon express reinstatement by the Licensor. For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License. c. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License. d. Sections 1, 5, 6, 7, and 8 survive termination of this Public License. Section 7 \u2013 Other Terms and Conditions. a. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed. b. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.t stated herein are separate from and independent of the terms and conditions of this Public License. Section 8 \u2013 Interpretation. a. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License. b. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions. c. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor. d. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority. Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the \u201cLicensor.\u201d Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at [creativecommons.org/policies](http://creativecommons.org/policies), Creative Commons does not authorize the use of the trademark \u201cCreative Commons\u201d or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses. Creative Commons may be contacted at creativecommons.org","title":"Licencia"},{"location":"licencia/#creative-commons","text":"","title":"creative commons"},{"location":"licencia/#attribution-sharealike-40-international","text":"Creative Commons Corporation (\u201cCreative Commons\u201d) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an \u201cas-is\u201d basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.","title":"Attribution-ShareAlike 4.0 International"},{"location":"licencia/#using-creative-commons-public-licenses","text":"Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses. Considerations for licensors: Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC-licensed material, or material used under an exception or limitation to copyright. More considerations for licensors . Considerations for the public: By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensor\u2019s permission is not necessary for any reason\u2013for example, because of any applicable exception or limitation to copyright\u2013then that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. More considerations for the public .","title":"Using Creative Commons Public Licenses"},{"location":"licencia/#creative-commons-attribution-sharealike-40-international-public-license","text":"By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-ShareAlike 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.","title":"Creative Commons Attribution-ShareAlike 4.0 International Public License"},{"location":"licencia/#section-1-definitions","text":"a. Adapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image. b. Adapter's License means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License. c. BY-SA Compatible License means a license listed at creativecommons.org/compatiblelicenses , approved by Creative Commons as essentially the equivalent of this Public License. d. Copyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights. e. Effective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements. f. Exceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material. g. License Elements means the license attributes listed in the name of a Creative Commons Public License. The License Elements of this Public License are Attribution and ShareAlike. h. Licensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License. i. Licensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license. j. Licensor means the individual(s) or entity(ies) granting rights under this Public License. k. Share means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them. l. Sui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world. m. You means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.","title":"Section 1 \u2013 Definitions."},{"location":"licencia/#section-2-scope","text":"a. License grant. 1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to: A. reproduce and Share the Licensed Material, in whole or in part; and B. produce, reproduce, and Share Adapted Material. 2. __Exceptions and Limitations.__ For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions. 3. __Term.__ The term of this Public License is specified in Section 6(a). 4. __Media and formats; technical modifications allowed.__ The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material. 5. __Downstream recipients.__ A. __Offer from the Licensor \u2013 Licensed Material.__ Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License. B. __Additional offer from the Licensor \u2013 Adapted Material. Every recipient of Adapted Material from You automatically receives an offer from the Licensor to exercise the Licensed Rights in the Adapted Material under the conditions of the Adapter\u2019s License You apply. C. __No downstream restrictions.__ You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material. 6. __No endorsement.__ Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i). b. Other rights. 1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise. 2. Patent and trademark rights are not licensed under this Public License. 3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties.","title":"Section 2 \u2013 Scope."},{"location":"licencia/#section-3-license-conditions","text":"Your exercise of the Licensed Rights is expressly made subject to the following conditions. a. Attribution. 1. If You Share the Licensed Material (including in modified form), You must: A. retain the following if it is supplied by the Licensor with the Licensed Material: i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated); ii. a copyright notice; iii. a notice that refers to this Public License; iv. a notice that refers to the disclaimer of warranties; v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable; B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License. 2. You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information. 3. If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable. b. ShareAlike. In addition to the conditions in Section 3(a), if You Share Adapted Material You produce, the following conditions also apply. The Adapter\u2019s License You apply must be a Creative Commons license with the same License Elements, this version or later, or a BY-SA Compatible License. You must include the text of, or the URI or hyperlink to, the Adapter's License You apply. You may satisfy this condition in any reasonable manner based on the medium, means, and context in which You Share Adapted Material. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, Adapted Material that restrict exercise of the rights granted under the Adapter's License You apply.","title":"Section 3 \u2013 License Conditions."},{"location":"licencia/#section-4-sui-generis-database-rights","text":"Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material: a. for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database; b. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material, including for purposes of Section 3(b); and c. You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database. For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.","title":"Section 4 \u2013 Sui Generis Database Rights."},{"location":"licencia/#section-5-disclaimer-of-warranties-and-limitation-of-liability","text":"a. Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You. b. To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You. c. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.","title":"Section 5 \u2013 Disclaimer of Warranties and Limitation of Liability."},{"location":"licencia/#section-6-term-and-termination","text":"a. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically. b. Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates: 1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or 2. upon express reinstatement by the Licensor. For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License. c. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License. d. Sections 1, 5, 6, 7, and 8 survive termination of this Public License.","title":"Section 6 \u2013 Term and Termination."},{"location":"licencia/#section-7-other-terms-and-conditions","text":"a. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed. b. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.t stated herein are separate from and independent of the terms and conditions of this Public License.","title":"Section 7 \u2013 Other Terms and Conditions."},{"location":"licencia/#section-8-interpretation","text":"a. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License. b. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions. c. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor. d. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority. Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the \u201cLicensor.\u201d Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at [creativecommons.org/policies](http://creativecommons.org/policies), Creative Commons does not authorize the use of the trademark \u201cCreative Commons\u201d or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses. Creative Commons may be contacted at creativecommons.org","title":"Section 8 \u2013 Interpretation."},{"location":"temario/","text":"Temario Introducci\u00f3n a Python El objetivo de este cap\u00edtulo es introducir las bases de Python. Iniciaremos desde cero y aprenderemos a editar, ejecutar, y depurar programas. Adem\u00e1s, escribiremos una secuencia de comandos que lee data en un archivo CSV y ejecuta un c\u00e1lculo. Trabajando con data Conoceremos las estructuras de datos de fundamental importancia en Python: tuples, lists, sets y dictionaries. Presentaremos algunos patrones comunes para el manejo de datos y discutiremos el modelo de objetos en Python. Organizaci\u00f3n de un programa En este modulo nos empapamos de m\u00e1s detalles sobre la composici\u00f3n de funciones, el manejo de errores y la introducci\u00f3n de modulos. Al final seremos capaces de escribir programas que son subdivididos en funciones esparcidas en varios archivos. Veremos algunas plantillas de c\u00f3digo que les ser\u00e1 \u00fatil para la creaci\u00f3n de programas. Clases y Objetos Introduciremos el concepto de clases y objetos. Aprenderemos sobre la declaraci\u00f3n class que nos permite crear nuevos objetos. Tambi\u00e9n introcimos el concepto de inherencia, unaherramienta que es comunmente utilizada para construir programar extensibles. Finalmente, veremos otras caracter\u00edsticas de clases como los m\u00e9todos especiales, b\u00fasqueda dinamica de atributos, y la definici\u00f3n de nuevas excepciones. Funcionamiento interno del objeto Python En esta secci\u00f3n aprenderemos sobre el funcionamiento interno de los objetos en Python. Algunos programadores con experiencia en otros lenguajes de programaci\u00f3n a menudo encuentran que la noci\u00f3n de clases en Python carece de ciertas caracter\u00edsticas. Por ejemplo, no existe la noci\u00f3n de control de accesso (e.g. privado, protegido), el argumento self lo encuentran extra\u00f1o, y trabajar con objetos se siente como una actividad con mucho libertinaje. Conoceremos como todo funciona y algunos patrones comunes para la encapsulaci\u00f3n interna de objetos. Generadores La iteraci\u00f3n es uno de los m\u00e1s comunes patrones de programaci\u00f3n en Python. Los programas hacen mucha iteraci\u00f3n para procesar listas, leer archivos, consultar una base de datos, y m\u00e1s. Una de las caracter\u00edsticas mas poderosas de Python es la habilidad de costumizar y redefinir la iteraci\u00f3n en una funci\u00f3n generadora. Al final de la secci\u00f3n, escribiremos algunos programas que procesan datos en tiempo real en una manera interesante. Temas avanzados En esta secci\u00f3n, veremos una peque\u00f1a colecci\u00f3n de algunas caracter\u00edsticas avanzadas de Python que posiblemente encontremos en nuestra programaci\u00f3n cotidiana. Los temas en esta secci\u00f3n son s\u00f3lo una introducci\u00f3n a estas ideas. Prueba y Depuraci\u00f3n Esta secci\u00f3n introduce unos tem\u00e1s b\u00e1sicas en relaci\u00f3n a pruebas, reporter\u00eda y depuraci\u00f3n. Paquetes Concluiremos el curso con algunos detalles para la organizaci\u00f3n de c\u00f3digo en paquetes. Adem\u00e1s, discutiremos sobre la instalaci\u00f3n de paquetes de terceros y sobre la preparaci\u00f3n necesaria para entregarle nuestro c\u00f3digo a otros. El tema de empaquetamiento de c\u00f3digo essta en constante evoluci\u00f3n y es una parte compleja en el desarrollo de Python. Por tanto, esta secci\u00f3n esta enfocada en compartir algunos principios de organizaci\u00f3n general de c\u00f3digo.","title":"Temario"},{"location":"temario/#temario","text":"Introducci\u00f3n a Python El objetivo de este cap\u00edtulo es introducir las bases de Python. Iniciaremos desde cero y aprenderemos a editar, ejecutar, y depurar programas. Adem\u00e1s, escribiremos una secuencia de comandos que lee data en un archivo CSV y ejecuta un c\u00e1lculo. Trabajando con data Conoceremos las estructuras de datos de fundamental importancia en Python: tuples, lists, sets y dictionaries. Presentaremos algunos patrones comunes para el manejo de datos y discutiremos el modelo de objetos en Python. Organizaci\u00f3n de un programa En este modulo nos empapamos de m\u00e1s detalles sobre la composici\u00f3n de funciones, el manejo de errores y la introducci\u00f3n de modulos. Al final seremos capaces de escribir programas que son subdivididos en funciones esparcidas en varios archivos. Veremos algunas plantillas de c\u00f3digo que les ser\u00e1 \u00fatil para la creaci\u00f3n de programas. Clases y Objetos Introduciremos el concepto de clases y objetos. Aprenderemos sobre la declaraci\u00f3n class que nos permite crear nuevos objetos. Tambi\u00e9n introcimos el concepto de inherencia, unaherramienta que es comunmente utilizada para construir programar extensibles. Finalmente, veremos otras caracter\u00edsticas de clases como los m\u00e9todos especiales, b\u00fasqueda dinamica de atributos, y la definici\u00f3n de nuevas excepciones. Funcionamiento interno del objeto Python En esta secci\u00f3n aprenderemos sobre el funcionamiento interno de los objetos en Python. Algunos programadores con experiencia en otros lenguajes de programaci\u00f3n a menudo encuentran que la noci\u00f3n de clases en Python carece de ciertas caracter\u00edsticas. Por ejemplo, no existe la noci\u00f3n de control de accesso (e.g. privado, protegido), el argumento self lo encuentran extra\u00f1o, y trabajar con objetos se siente como una actividad con mucho libertinaje. Conoceremos como todo funciona y algunos patrones comunes para la encapsulaci\u00f3n interna de objetos. Generadores La iteraci\u00f3n es uno de los m\u00e1s comunes patrones de programaci\u00f3n en Python. Los programas hacen mucha iteraci\u00f3n para procesar listas, leer archivos, consultar una base de datos, y m\u00e1s. Una de las caracter\u00edsticas mas poderosas de Python es la habilidad de costumizar y redefinir la iteraci\u00f3n en una funci\u00f3n generadora. Al final de la secci\u00f3n, escribiremos algunos programas que procesan datos en tiempo real en una manera interesante. Temas avanzados En esta secci\u00f3n, veremos una peque\u00f1a colecci\u00f3n de algunas caracter\u00edsticas avanzadas de Python que posiblemente encontremos en nuestra programaci\u00f3n cotidiana. Los temas en esta secci\u00f3n son s\u00f3lo una introducci\u00f3n a estas ideas. Prueba y Depuraci\u00f3n Esta secci\u00f3n introduce unos tem\u00e1s b\u00e1sicas en relaci\u00f3n a pruebas, reporter\u00eda y depuraci\u00f3n. Paquetes Concluiremos el curso con algunos detalles para la organizaci\u00f3n de c\u00f3digo en paquetes. Adem\u00e1s, discutiremos sobre la instalaci\u00f3n de paquetes de terceros y sobre la preparaci\u00f3n necesaria para entregarle nuestro c\u00f3digo a otros. El tema de empaquetamiento de c\u00f3digo essta en constante evoluci\u00f3n y es una parte compleja en el desarrollo de Python. Por tanto, esta secci\u00f3n esta enfocada en compartir algunos principios de organizaci\u00f3n general de c\u00f3digo.","title":"Temario"},{"location":"prueba/preguntas/","text":"Prueba de conocimiento \u00bfCu\u00e1l es el resultado de la operaci\u00f3n >>> True + 1 ? error True 2 False \u00bfCu\u00e1l es el resultado de la operaci\u00f3n >>> 2 >= 2 ? True False error 2 \u00bfCu\u00e1l es el resultado de la operaci\u00f3n >>> int(3.33) ? 3.3 3.0 3 error \u00bfCu\u00e1l es el resultado de la siguiente operaci\u00f3n? >>> a = 'Hello world' >>> a[-1] 'H' 'e' 'd' error \u00bfCu\u00e1l es el resultado de la siguiente operaci\u00f3n? >>> a = 'Hello world' >>> 'e' in a False 1 'e' True \u00bfCu\u00e1l es el resultado de la siguiente operaci\u00f3n? >>> numeros = [39, 38, 42, 65, 111] >>> numeros[1:4] [39, 38, 42, 65] [38, 42, 65, 111] [38, 42, 65] [38, 111] \u00bfCu\u00e1l es el resultado de la siguiente operaci\u00f3n? >>> t = (1, 2, 3) >>> t[1] = 2 + 2 (1, 4, 3) error (4, 2, 3) (1, 6, 3) Si tengo d = {1: 0, 2: 1, 3: 2} , \u00bfcu\u00e1l es el resultado de >>> 4 in d ? False error True 4 \u00bfCu\u00e1l es el resultado de >>> {1, 1, 1, 2, 2, 3 } ? {1, 1, 1, 2, 2, 3} {1, 2, 2, 3} {1, 1, 1, 2, 3} {1, 2, 3} \u00bfCu\u00e1l es el reultado de la siguiente operaci\u00f3n? >>> a = [1, 2, 3] >>> b = [2*x for x in a] >>> b [2, 4, 6] [1, 2, 3, 1, 2, 3] [[1, 2, 3], [1, 2, 3]] [1, 2, 3]","title":"Prueba de conocimiento"},{"location":"prueba/preguntas/#prueba-de-conocimiento","text":"\u00bfCu\u00e1l es el resultado de la operaci\u00f3n >>> True + 1 ? error True 2 False \u00bfCu\u00e1l es el resultado de la operaci\u00f3n >>> 2 >= 2 ? True False error 2 \u00bfCu\u00e1l es el resultado de la operaci\u00f3n >>> int(3.33) ? 3.3 3.0 3 error \u00bfCu\u00e1l es el resultado de la siguiente operaci\u00f3n? >>> a = 'Hello world' >>> a[-1] 'H' 'e' 'd' error \u00bfCu\u00e1l es el resultado de la siguiente operaci\u00f3n? >>> a = 'Hello world' >>> 'e' in a False 1 'e' True \u00bfCu\u00e1l es el resultado de la siguiente operaci\u00f3n? >>> numeros = [39, 38, 42, 65, 111] >>> numeros[1:4] [39, 38, 42, 65] [38, 42, 65, 111] [38, 42, 65] [38, 111] \u00bfCu\u00e1l es el resultado de la siguiente operaci\u00f3n? >>> t = (1, 2, 3) >>> t[1] = 2 + 2 (1, 4, 3) error (4, 2, 3) (1, 6, 3) Si tengo d = {1: 0, 2: 1, 3: 2} , \u00bfcu\u00e1l es el resultado de >>> 4 in d ? False error True 4 \u00bfCu\u00e1l es el resultado de >>> {1, 1, 1, 2, 2, 3 } ? {1, 1, 1, 2, 2, 3} {1, 2, 2, 3} {1, 1, 1, 2, 3} {1, 2, 3} \u00bfCu\u00e1l es el reultado de la siguiente operaci\u00f3n? >>> a = [1, 2, 3] >>> b = [2*x for x in a] >>> b [2, 4, 6] [1, 2, 3, 1, 2, 3] [[1, 2, 3], [1, 2, 3]] [1, 2, 3]","title":"Prueba de conocimiento"},{"location":"prueba/respuestas/","text":"2 True 3 d True [38, 42, 65] error {1, 2, 3} [2, 4, 6]","title":"Respuestas"}]}