<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>3 Organización de un Programa - Python Práctico</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "3 Organizaci\u00f3n de un Programa";
    var mkdocs_page_input_path = "3.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/shell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Python Práctico</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Sobre el curso</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../temario/">Temario</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../faq/">Preguntas</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../0/">0 Empiece aqui</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../1/">1 Intro a Python</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../2/">2 Trabajando con Data</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">3 Organización de un Programa</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#31-scripting">3.1 Scripting</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#311-que-es-un-guion-script">3.1.1 ¿Qué es un guión / script?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#312-un-problema">3.1.2 Un problema</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#313-definiendo-cosas">3.1.3 Definiendo cosas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#314-definicion-de-funciones">3.1.4 Definición de funciones</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#315-que-es-una-funcion">3.1.5 ¿Qué es una función?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#316-definicion-de-funcion">3.1.6 Definición de función</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#317-estilo-de-abajo-hacia-arriba">3.1.7 Estilo de abajo hacia arriba</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#318-diseno-de-funciones">3.1.8 Diseño de funciones</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#319-documentacion-en-cadenas">3.1.9 Documentación en cadenas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3110-tipo-de-anotaciones">3.1.10 Tipo de anotaciones</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3111-ejercicios">3.1.11 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-31-estructurar-un-programa-como-una-coleccion-de-funciones">Ejercicio 3.1: Estructurar un programa como una colección de funciones</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-32-creacion-de-una-funcion-de-nivel-superior-para-la-ejecucion-del-programa">Ejercicio 3.2: Creación de una función de nivel superior para la ejecución del programa</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#comentario">Comentario</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#32-mas-sobre-funciones">3.2 Más sobre funciones</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#321-llamar-a-una-funcion">3.2.1 Llamar a una función</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#322-argumentos-predeterminados">3.2.2 Argumentos predeterminados</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#323-prefiera-argumentos-de-palabras-clave-vs-argumentos-opcionales">3.2.3 Prefiera argumentos de palabras clave vs argumentos opcionales</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#324-mejores-practicas-de-diseno">3.2.4 Mejores prácticas de diseño</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#325-devolucion-de-valores">3.2.5 Devolución de valores</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#326-multiples-valores-de-retorno">3.2.6 Múltiples valores de retorno</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#327-alcance-de-una-variable">3.2.7 Alcance de una variable</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#328-variables-locales">3.2.8 Variables locales</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#329-variables-globales">3.2.9 Variables globales</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3210-modificar-variables-globales">3.2.10 Modificar variables globales</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3211-transferencia-de-argumentos">3.2.11 Transferencia de argumentos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3212-reasignacion-vs-modificacion">3.2.12 Reasignación vs modificación</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3213-ejercicios">3.2.13 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-33-lectura-de-archivos-csv">Ejercicio 3.3: lectura de archivos CSV</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ejercicio-34-creacion-de-un-selector-de-columnas">Ejercicio 3.4: Creación de un selector de columnas</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-35-realizacion-de-conversion-de-tipos">Ejercicio 3.5: Realización de conversión de tipos</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-36-trabajar-sin-encabezados">Ejercicio 3.6: Trabajar sin encabezados</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ejercicio-37-elegir-un-delimitador-de-columna-diferente">Ejercicio 3.7: elegir un delimitador de columna diferente</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#comentario_1">Comentario</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#33-comprobacion-de-errores">3.3 Comprobación de errores</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#331-como-fallan-los-programas">3.3.1 Cómo fallan los programas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#332-excepciones">3.3.2 Excepciones</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#333-manejo-de-excepciones">3.3.3 Manejo de excepciones</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#334-excepciones-integradas">3.3.4 Excepciones integradas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#335-valores-de-excepcion">3.3.5 Valores de excepción</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#336-detectar-varios-errores">3.3.6 Detectar varios errores</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#337-detectar-todos-los-errores">3.3.7 Detectar todos los errores</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#338-manera-incorrecta-de-detectar-errores">3.3.8 Manera incorrecta de detectar errores</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#339-otro-enfoque">3.3.9 Otro enfoque</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#337-volver-a-plantear-una-excepcion">3.3.7 Volver a plantear una excepción</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#338-mejores-practicas-de-excepcion">3.3.8 Mejores prácticas de excepción</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#339-declaracion-finally">3.3.9 declaración finally</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3310-declaracion-with">3.3.10 declaración with</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#339-ejercicios">3.3.9 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-38-generacion-de-excepciones">Ejercicio 3.8: Generación de excepciones</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-39-captura-de-excepciones">Ejercicio 3.9: captura de excepciones</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-310-silenciar-errores">Ejercicio 3.10: Silenciar errores</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#34-modulos">3.4 Módulos</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#341-modulos-e-importacion">3.4.1 Módulos e importación</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#342-ambito-o-espacio-de-nombres">3.4.2 Ámbito o espacio de nombres</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#343-definiciones-globales">3.4.3 Definiciones globales</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#344-modulos-como-entornos">3.4.4 Módulos como entornos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#345-ejecucion-del-modulo">3.4.5 Ejecución del módulo</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#346-declaracion-import-as">3.4.6 declaración import as</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#347-importacion-de-modulo-con-from">3.4.7 importación de módulo con from</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#348-comentarios-sobre-la-importacion">3.4.8 Comentarios sobre la importación</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#349-carga-del-modulo">3.4.9 Carga del módulo</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3410-localizacion-de-modulos">3.4.10 Localización de módulos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3411-ruta-de-busqueda-del-modulo">3.4.11 Ruta de búsqueda del módulo</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#ejercicios">Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-311-importaciones-de-modulos">Ejercicio 3.11: Importaciones de módulos</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-312-uso-de-su-modulo-de-biblioteca">Ejercicio 3.12: Uso de su módulo de biblioteca</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-314-uso-de-mas-importaciones-de-bibliotecas">Ejercicio 3.14: Uso de más importaciones de bibliotecas</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#comentario_2">Comentario</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#35-modulo-principal">3.5 Módulo principal</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#351-funciones-principales">3.5.1 Funciones principales</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#352-modulo-principal-de-python">3.5.2 Módulo principal de Python</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#352-main">3.5.2 main</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#353-programas-principales-frente-a-importaciones-de-bibliotecas">3.5.3 Programas principales frente a importaciones de bibliotecas</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#353-plantilla-de-programa">3.5.3 Plantilla de programa</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#354-herramientas-de-linea-de-comandos">3.5.4 Herramientas de línea de comandos</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#355-argumentos-de-linea-de-comando">3.5.5 Argumentos de línea de comando</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#356-estandar-io-entradasalida">3.5.6  Estándar I/O (Entrada/Salida)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#357-variables-de-entorno">3.5.7 Variables de entorno</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#358-saliendo-del-programa">3.5.8 Saliendo del programa</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#359-la-linea">3.5.9 La #!linea</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3510-plantilla-de-script">3.5.10 Plantilla de script</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3511-ejercicios">3.5.11 Ejercicios</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ejercicio-315-funciones-main">Ejercicio 3.15: funciones main()</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../4/">4 Clases y Objetos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../5/">5 Entrañas del Objeto</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../6/">6 Generadores</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../7/">7 Temas avanzados</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../8/">8 Prueba y Depuración</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../9/">9 Paquetes</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../licencia/">Licencia</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Python Práctico</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>3 Organización de un Programa</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="3-organizacion-de-un-programa">3. Organización de un Programa</h1>
<p>En este modulo nos empapamos de más detalles sobre la composición de funciones, el manejo de errores y la introducción de modulos. Al final seremos capaces de escribir programas que son subdivididos en funciones esparcidas en varios archivos. Veremos algunas plantillas de código que les será útil para la creación de programas.</p>
<p><em>Nota: estaremos publicando el contenido de este módulo a más tardar el 18 de enero.</em></p>
<h2 id="31-scripting">3.1 Scripting</h2>
<p>En esta parte, veremos más de cerca la práctica de escribir scripts en Python.</p>
<h3 id="311-que-es-un-guion-script">3.1.1 ¿Qué es un guión / script?</h3>
<p>Un script es un programa que ejecuta una serie de declaraciones y se detiene.</p>
<pre><code class="language-python"># programa.py 
declaracion1
declaracion2
declaracion3
...
</code></pre>
<p>Hasta ahora, vale destacar que hemos estado escribiendo <em>scripts</em>.</p>
<h3 id="312-un-problema">3.1.2 Un problema</h3>
<p>Si escribe un script útil, crecerá en características y funcionalidad. Es posible que desee aplicarlo a otros problemas relacionados. Con el tiempo, podría convertirse en una aplicación crítica. Sin embargo, podría convertirse en un gran enredado si no tiene cuidado. Entonces, es importante tener algún tipo de organización.</p>
<h3 id="313-definiendo-cosas">3.1.3 Definiendo cosas</h3>
<p>Los nombres siempre deben definirse antes de que se utilicen más tarde.</p>
<pre><code class="language-python">def square(x):
    return x*x

a = 42
b = a + 2     # requiere que `a` esté definida 
z = square(b) # require que `square` y `b` esten definidas 
</code></pre>
<p>El orden es importante. Casi siempre colocas las definiciones de variables y funciones cerca de la parte superior.</p>
<h3 id="314-definicion-de-funciones">3.1.4 Definición de funciones</h3>
<p>Es una buena idea poner todo el código relacionado con una sola tarea en un solo lugar. Para esto, haga uso de una función.</p>
<pre><code class="language-python">def read_prices(filename):
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
</code></pre>
<p>Una función también simplifica las operaciones repetidas.</p>
<pre><code class="language-python">oldprices = read_prices('oldprices.csv')
newprices = read_prices('newprices.csv')
</code></pre>
<h3 id="315-que-es-una-funcion">3.1.5 ¿Qué es una función?</h3>
<p>Una función es una secuencia de declaraciones con nombre.</p>
<pre><code class="language-python">def funcname(args):
  declaracion
  declaracion
  ...
  return result
</code></pre>
<p>Cualquier declaración de Python se puede utilizar dentro.</p>
<pre><code class="language-python">def foo():
    import math
    print(math.sqrt(2))
    help(math)
</code></pre>
<p>No hay declaraciones <em>especiales</em> en Python (lo que hace que sea fácil de recordar).</p>
<h3 id="316-definicion-de-funcion">3.1.6 Definición de función</h3>
<p>Las funciones se pueden definir en cualquier orden.</p>
<pre><code class="language-python">def foo(x):
    bar(x)

def bar(x):
    declaracion

# OR 
def bar(x):
    declaracion

def foo(x):
    bar(x)
</code></pre>
<p>Las funciones solo deben definirse antes de ser utilizadas (o llamadas) durante la ejecución del programa.</p>
<pre><code class="language-python">foo(3)        # foo debió haber estado definida 
</code></pre>
<p>Estilísticamente, probablemente sea más común ver las funciones definidas de abajo hacia arriba.</p>
<h3 id="317-estilo-de-abajo-hacia-arriba">3.1.7 Estilo de abajo hacia arriba</h3>
<p>Las funciones se tratan como bloques de construcción. Los bloques más pequeños / simples van primero.</p>
<pre><code class="language-python"># myprogram.py 
def foo(x):
    ...

def bar(x):
    ...
    foo(x)          # Definida anteriormente
    ...

def spam(x):
    ...
    bar(x)          # Definida anteriormente
    ...

spam(42)            # Código que utiliza las funciones esta definido anteriormente 
</code></pre>
<p>Las funciones posteriores se basan en funciones anteriores. Nuevamente, esto es solo una cuestión de estilo. Lo único que importa en el programa anterior es que la llamada <code>spam(42)</code> sea ​​la última.</p>
<h3 id="318-diseno-de-funciones">3.1.8 Diseño de funciones</h3>
<p>Idealmente, las funciones deberían ser una caja negra . Solo deben operar con entradas pasadas y evitar variables globales y efectos secundarios misteriosos. Sus principales objetivos: <strong>modularidad</strong> y <strong>previsibilidad</strong>.</p>
<h3 id="319-documentacion-en-cadenas">3.1.9 Documentación en cadenas</h3>
<p>La documentación en cadenas, comunmente conocida en inglés como <em>doc strings</em>, es una buena práctica que incluye un breve resumen de una oración de lo que hace la función. Si se necesita más información, se incluye un breve ejemplo de uso junto con una descripción más detallada de los argumentos. Las mismas se escriben inmediatamente después del nombre de la función y alimentan a <code>help()</code>, el IDE (ambiente integrado de desarrollo) y otras herramientas.</p>
<pre><code class="language-python">def read_prices(filename):
    '''Lee precios de un archivo CSV file de nombre, precio, y data'''
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
</code></pre>
<h3 id="3110-tipo-de-anotaciones">3.1.10 Tipo de anotaciones</h3>
<p>También puede agregar sugerencias de tipo opcionales a las definiciones de funciones.</p>
<pre><code class="language-python">def read_prices(filename: str) -&gt; dict:
    '''Lee precios de un archivo CSV file de nombre, precio, y data'''
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
</code></pre>
<p>Las sugerencias no hacen nada operativamente. Son puramente informativos. Sin embargo, pueden ser utilizados por IDE, verificadores de código y otras herramientas para hacer más.</p>
<h3 id="3111-ejercicios">3.1.11 Ejercicios</h3>
<p>En la sección 2, escribió un programa llamado report.pyque imprimía un informe que mostraba el rendimiento de una cartera de acciones. Este programa constaba de algunas funciones. Por ejemplo:</p>
<pre><code class="language-python"># report.py 
import csv

def read_portfolio(filename):
    '''Lee un archivo de cartera de acciones en una lista de diccionarios con 
    la clave siendo nombre, acciones y precio.'''
    portfolio = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)

        for row in rows:
            record = dict(zip(headers, row))
            stock = {
                'name' : record['name'],
                'shares' : int(record['shares']),
                'price' : float(record['price'])
            }
            portfolio.append(stock)
    return portfolio
...
</code></pre>
<p>Sin embargo, también hubo partes del programa que solo realizaron una serie de 
cálculos con guión. Este código apareció cerca del final del programa. 
Por ejemplo:</p>
<pre><code class="language-python">...

# Salida/output del reporte
headers = ('Name', 'Shares', 'Price', 'Change')
print('%10s %10s %10s %10s'  % headers)
print(('-' * 10 + ' ') * len(headers))
for row in report:
    print('%10s %10d %10.2f %10.2f' % row)
...
</code></pre>
<p>En este ejercicio, tomaremos el programa anterior y lo organizaremos con un poco más de fuerza en torno al uso de funciones.</p>
<h4 id="ejercicio-31-estructurar-un-programa-como-una-coleccion-de-funciones">Ejercicio 3.1: Estructurar un programa como una colección de funciones</h4>
<p>Modifique su programa <code>report.py</code> para que todas las operaciones principales, incluyendo los cálculos y la salida, se lleven a cabo mediante una colección de funciones. </p>
<p>Específicamente:</p>
<ul>
<li>Cree una función <code>print_report(report)</code> que imprima el informe.</li>
<li>Cambie la última parte del programa para que no sea más que una serie de llamadas a funciones y ningún otro cálculo.</li>
</ul>
<h4 id="ejercicio-32-creacion-de-una-funcion-de-nivel-superior-para-la-ejecucion-del-programa">Ejercicio 3.2: Creación de una función de nivel superior para la ejecución del programa</h4>
<p>Tome la última parte de su programa y empaquelo en una sola función <code>portfolio_report(portfolio_filename, prices_filename)</code>. Haga que la función funcione para que la siguiente llamada de función cree el informe como antes:</p>
<p><code>portfolio_report('Data/portfolio.csv', 'Data/prices.csv')</code></p>
<p>En esta versión final, su programa no será más que una serie de definiciones de funciones seguidas de una única llamada de función <code>portfolio_report()</code> final al (que ejecuta todos los pasos involucrados en el programa).</p>
<p>Al convertir su programa en una sola función, es fácil ejecutarlo en diferentes entradas. Por ejemplo, pruebe estas declaraciones de forma interactiva después de ejecutar su programa:</p>
<pre><code class="language-python">&gt;&gt;&gt; portfolio_report('Data/portfolio2.csv', 'Data/prices.csv')
&gt;&gt;&gt; # mire la salida de la linea anterior
&gt;&gt;&gt; files = ['Data/portfolio.csv', 'Data/portfolio2.csv']
&gt;&gt;&gt; for name in files:
        print(f'{name:-^43s}')
        portfolio_report(name, 'Data/prices.csv')
        print()

&gt;&gt;&gt; # mire la salida del ciclo anterior
&gt;&gt;&gt;
</code></pre>
<h3 id="comentario">Comentario</h3>
<p>Python hace que sea muy fácil escribir código de <em>scripting</em> relativamente no estructurado en el que solo tiene un archivo con una secuencia de declaraciones. En el panorama general, casi siempre es mejor utilizar funciones cuando pueda. En algún momento, ese <em>script</em> crecerá y deseará tener un poco más de organización. Además, un hecho poco conocido es que Python se ejecuta un poco más rápido si usa funciones.</p>
<h2 id="32-mas-sobre-funciones">3.2 Más sobre funciones</h2>
<p>Aunque las funciones se introdujeron antes, se proporcionaron muy pocos detalles sobre cómo funcionan realmente a un nivel más profundo. Esta sección tiene como objetivo llenar algunos vacíos y discutir asuntos como convenciones de llamadas, reglas de alcance y más.</p>
<h3 id="321-llamar-a-una-funcion">3.2.1 Llamar a una función</h3>
<p>Considere esta función:</p>
<pre><code class="language-python">def read_prices(filename, debug):
    ...
</code></pre>
<p>Puede llamar a la función con argumentos posicionales:</p>
<pre><code class="language-python">prices = read_prices('prices.csv', True)
</code></pre>
<p>O puede llamar a la función con argumentos de palabras clave:</p>
<pre><code class="language-python">prices = read_prices(filename='prices.csv', debug=True)
</code></pre>
<h3 id="322-argumentos-predeterminados">3.2.2 Argumentos predeterminados</h3>
<p>A veces quieres que un argumento sea opcional. Si es así, asigne un valor predeterminado en la definición de función.</p>
<pre><code class="language-python">def read_prices(filename, debug=False):
    ...
</code></pre>
<p>Si se asigna un valor predeterminado, el argumento es opcional en las llamadas a funciones.</p>
<pre><code class="language-python">d = read_prices('prices.csv')
e = read_prices('prices.dat', True)
</code></pre>
<p><em>Nota: Los argumentos con valores predeterminados deben aparecer al final de la lista de argumentos (todos los argumentos no opcionales van primero).</em></p>
<h3 id="323-prefiera-argumentos-de-palabras-clave-vs-argumentos-opcionales">3.2.3 Prefiera argumentos de palabras clave vs argumentos opcionales</h3>
<p>Compare y contraste estos dos estilos de llamadas diferentes:</p>
<pre><code class="language-python">parse_data(data, False, True) # ????? 
parse_data(data, ignore_errors=True)
parse_data(data, debug=True)
parse_data(data, debug=True, ignore_errors=True)
</code></pre>
<p>En la mayoría de los casos, los argumentos de palabras clave mejoran la claridad del código, especialmente para argumentos que sirven como indicadores o que están relacionados con características opcionales.</p>
<h3 id="324-mejores-practicas-de-diseno">3.2.4 Mejores prácticas de diseño</h3>
<p>Siempre proporcione nombres cortos pero significativos a los argumentos de las funciones.</p>
<p>Alguien que use una función puede querer usar el estilo de llamada de palabras clave.</p>
<pre><code class="language-python">d = read_prices('prices.csv', debug=True)
</code></pre>
<p>Las herramientas de desarrollo de Python mostrarán los nombres en las funciones de ayuda y la documentación.</p>
<h3 id="325-devolucion-de-valores">3.2.5 Devolución de valores</h3>
<p>La declaración <code>return</code> devuelve un valor</p>
<pre><code class="language-python">def square(x):
    return x * x
</code></pre>
<p>Si no se proporciona ningún valor de retorno o el <code>return</code> falta, se devuelve <code>None</code>.</p>
<pre><code class="language-python">def bar(x):
    ...declaraciones
    return

a = bar(4)      # a = None 

# O
def foo(x):
    ...declaraciones  # Sin `return` 

b = foo(4)      # b = None 
</code></pre>
<h3 id="326-multiples-valores-de-retorno">3.2.6 Múltiples valores de retorno</h3>
<p>Las funciones solo pueden devolver un valor. Sin embargo, una función puede devolver varios valores devolviéndolos en una tupla.</p>
<pre><code class="language-python">def divide(a,b):
    q = a // b      # Cociente     
    r = a % b       # Remanente     
    return q, r     # Retorna una tuple 
</code></pre>
<p>Ejemplo de uso:</p>
<pre><code class="language-python">x, y = divide(37,5) # x = 7, y = 2 
x = divide(37, 5)   # x = (7, 2) 
</code></pre>
<h3 id="327-alcance-de-una-variable">3.2.7 Alcance de una variable</h3>
<p>Los programas asignan valores a las variables.</p>
<pre><code class="language-python">x = value # variable Global  
def foo():
    y = value # variable Local  
</code></pre>
<p>Las asignaciones de variables ocurren fuera y dentro de las definiciones de funciones. Las variables definidas en el exterior son "globales". Las variables dentro de una función son "locales".</p>
<h3 id="328-variables-locales">3.2.8 Variables locales</h3>
<p>Las variables asignadas dentro de las funciones son privadas.</p>
<pre><code class="language-python">def read_portfolio(filename):
    portfolio = []
    for line in open(filename):
        fields = line.split(',')
        s = (fields[0], int(fields[1]), float(fields[2]))
        portfolio.append(s)
    return portfolio
</code></pre>
<p>En este ejemplo, <code>filename</code>, <code>portfolio</code>, <code>line</code>, <code>fields</code> y <code>s</code> son variables locales. Esas variables no se conservan ni se puede acceder a ellas después de la llamada a la función.</p>
<pre><code class="language-shell">&gt;&gt;&gt; stocks = read_portfolio('portfolio.csv')
&gt;&gt;&gt; fields
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: name 'fields' is not defined
&gt;&gt;&gt;
</code></pre>
<p>Los locales tampoco pueden entrar en conflicto con las variables que se encuentran en otros lugares.</p>
<h3 id="329-variables-globales">3.2.9 Variables globales</h3>
<p>Las funciones pueden acceder libremente a los valores de globales definidos en el mismo archivo.</p>
<pre><code class="language-python">name = 'Dave'

def greeting():
    print('Hello', name)  # Usando `name` variable global
</code></pre>
<p>Sin embargo, las funciones no pueden modificar los globales:</p>
<pre><code class="language-python">name = 'Dave'

def spam():
  name = 'Guido'

spam()
print(name) # prints 'Dave' 
</code></pre>
<p><em>Recuerde: todas las asignaciones en funciones son locales.</em></p>
<h3 id="3210-modificar-variables-globales">3.2.10 Modificar variables globales</h3>
<p>Si debe modificar una variable global, debe declararla como tal.</p>
<pre><code class="language-python">name = 'Dave'

def spam():
    global name
    name = 'Guido' # cambia el nombre global anterior
</code></pre>
<p>La declaración <code>global</code> debe aparecer antes de su uso y la variable correspondiente debe existir en el mismo archivo que la función. Habiendo visto esto, sepa que se considera de mala forma. De hecho, trate de evitarlo <code>global</code> completo si puede. Si necesita una función para modificar algún tipo de estado fuera de la función, es mejor usar una clase en su lugar (más sobre esto más adelante).</p>
<h3 id="3211-transferencia-de-argumentos">3.2.11 Transferencia de argumentos</h3>
<p>Cuando llama a una función, las variables de argumento son nombres que hacen referencia a los valores pasados. Estos valores NO son copias (consulte la sección 2.7). Si se pasan tipos de datos mutables (por ejemplo, listas, diccionarios), se pueden modificar en el lugar.</p>
<pre><code class="language-python">def foo(items):
    items.append(42)    # Modifica el objeto de entrada 

a = [1, 2, 3]
foo(a)
print(a)                # [1, 2, 3, 42] 
</code></pre>
<p><em>Punto clave: las funciones no reciben una copia de los argumentos de entrada.</em></p>
<h3 id="3212-reasignacion-vs-modificacion">3.2.12 Reasignación vs modificación</h3>
<p>Asegúrese de comprender la sutil diferencia entre modificar un valor y reasignar un nombre de variable.</p>
<pre><code class="language-python">def foo(items):
    items.append(42)    # Modifica el objeto de entrada  

a = [1, 2, 3]
foo(a)
print(a)                # [1, 2, 3, 42] 

# VS 
def bar(items):
    items = [4,5,6]    # Reasigna variable local `items` a otro objeto 

b = [1, 2, 3]
bar(b)
print(b)                # [1, 2, 3] 
</code></pre>
<p><em>Recordatorio: la asignación de variables nunca sobrescribe la memoria. El nombre simplemente está vinculado a un nuevo valor.</em></p>
<h3 id="3213-ejercicios">3.2.13 Ejercicios</h3>
<p>Este conjunto de ejercicios le permite implementar lo que es, quizás, la parte más poderosa y difícil del curso. Hay muchos pasos y muchos conceptos de ejercicios anteriores que se juntan todos a la vez. La solución final es solo de unas 25 líneas de código, pero tómese su tiempo y asegúrese de comprender cada parte.</p>
<p>Una parte central de su programa <code>report.py</code> se centra en la lectura de archivos CSV. Por ejemplo, la función <code>read_portfolio()</code> lee un archivo que contiene filas de datos de cartera y la función <code>read_prices()</code> lee un archivo que contiene filas de datos de precios. En ambas funciones, hay muchas partes "complicadas" de bajo nivel y características similares. Por ejemplo, ambos abren un archivo y lo envuelven con el módulo <code>csv</code> y ambos convierten varios campos en nuevos tipos.</p>
<p>Si estuvieses haciendo mucho análisis de archivos, probablemente queras limpiar algo de esto y hacerlo más general. Ese es nuestro objetivo.</p>
<p>Comience este ejercicio abriendo un archivo llamado <code>fileparse.py</code>. Aquí es donde estaremos haciendo nuestro trabajo.</p>
<h4 id="ejercicio-33-lectura-de-archivos-csv">Ejercicio 3.3: lectura de archivos CSV</h4>
<p>Para empezar, centrémonos en el problema de leer un archivo CSV en una lista de diccionarios. En el archivo <code>fileparse.py</code>, defina una función que se vea así:</p>
<pre><code class="language-python"># fileparse.py 
import csv

def parse_csv(filename):
    ''' Convierte un archivo CSV a una lista de registro '''
    with open(filename) as f:
        rows = csv.reader(f)

        headers = next(rows)  # Lee la primera fila con el encabezado
        records = []
        for row in rows:
            if not row:    # Omite filas sin data                 
                continue
            record = dict(zip(headers, row))
            records.append(record)

    return records
</code></pre>
<p>Esta función lee un archivo CSV en una lista de diccionarios mientras oculta los detalles de la apertura del archivo, lo envuelve con el módulo <code>csv</code>, ignora las líneas en blanco, etc.</p>
<p>Pruébelo:</p>
<p>Sugerencia: <code>$ python3 -i fileparse.py</code>.</p>
<pre><code class="language-shell">&gt;&gt;&gt; portfolio = parse_csv('Data/portfolio.csv')
&gt;&gt;&gt; portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]
&gt;&gt;&gt;
</code></pre>
<p>Esto es bueno, excepto que no puede hacer ningún tipo de cálculo útil con los datos porque todo está representado como una cadena. Arreglaremos esto en breve, pero sigamos mejorandolo.</p>
<h3 id="ejercicio-34-creacion-de-un-selector-de-columnas">Ejercicio 3.4: Creación de un selector de columnas</h3>
<p>En muchos casos, solo le interesan las columnas seleccionadas de un archivo CSV, no todos los datos. Modifique la función <code>parse_csv()</code> para que, opcionalmente, permita que las columnas especificadas por el usuario se seleccionen de la siguiente manera:</p>
<pre><code class="language-shell">&gt;&gt;&gt; # Lea toda la data 
&gt;&gt;&gt; portfolio = parse_csv('Data/portfolio.csv')
&gt;&gt;&gt; portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]

&gt;&gt;&gt; # Lee solo parte de la data 
&gt;&gt;&gt; shares_held = parse_csv('Data/portfolio.csv', select=['name','shares'])
&gt;&gt;&gt; shares_held
[{'name': 'AA', 'shares': '100'}, {'name': 'IBM', 'shares': '50'}, {'name': 'CAT', 'shares': '150'}, {'name': 'MSFT', 'shares': '200'}, {'name': 'GE', 'shares': '95'}, {'name': 'MSFT', 'shares': '50'}, {'name': 'IBM', 'shares': '100'}]
&gt;&gt;&gt;
</code></pre>
<p>En el ejercicio 2.23 se dio un ejemplo de selector de columnas. Sin embargo, aquí hay una forma de hacerlo:</p>
<pre><code class="language-python"># fileparse.py 
import csv

def parse_csv(filename, select=None):
    ''' Convierte un archivo CSV file a una lista de registros '''
    with open(filename) as f:
        rows = csv.reader(f)

        # Read the file headers         
        headers = next(rows)

        # Si se proporcionó un selector de columna, busque los índices de las columnas especificadas.
        # También reduzca el conjunto de encabezados utilizados para los diccionarios resultantes   
        if select:
            indices = [headers.index(colname) for colname in select]
            headers = select
        else:
            indices = []

        records = []
        for row in rows:
            if not row:    # Omitir filas sin data                
                continue
            # Filtrar la fila si se seleccionaron columnas específicas          
            if indices:
                row = [ row[index] for index in indices ]

            # Crear diccionario           
            record = dict(zip(headers, row))
            records.append(record)

    return records
</code></pre>
<p>Hay una serie de partes complicadas en esta parte. Probablemente lo más importante es el mapeo de las columnas seleccionadas a los índices de filas. Por ejemplo, suponga que el archivo de entrada tiene los siguientes encabezados:</p>
<pre><code class="language-shell">&gt;&gt;&gt; headers = ['name', 'date', 'time', 'shares', 'price']
&gt;&gt;&gt;
</code></pre>
<p>Ahora, suponga que las columnas seleccionadas fueran las siguientes:</p>
<pre><code class="language-shell">&gt;&gt;&gt; select = ['name', 'shares']
&gt;&gt;&gt;
</code></pre>
<p>Para realizar la selección adecuada, debe asignar los nombres de las columnas seleccionadas a los índices de las columnas en el archivo. Eso es lo que está haciendo este paso:</p>
<pre><code class="language-shell">&gt;&gt;&gt; indices = [headers.index(colname) for colname in select]
&gt;&gt;&gt; indices
[0, 3]
&gt;&gt;&gt;
</code></pre>
<p>En otras palabras, "nombre" es la columna <code>0</code> y "recursos compartidos" es la columna <code>3</code>. Cuando lee una fila de datos del archivo, los índices se utilizan para filtrarla:</p>
<pre><code class="language-shell">&gt;&gt;&gt; row = ['AA', '6/11/2007', '9:50am', '100', '32.20' ]
&gt;&gt;&gt; row = [ row[index] for index in indices ]
&gt;&gt;&gt; row
['AA', '100']
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-35-realizacion-de-conversion-de-tipos">Ejercicio 3.5: Realización de conversión de tipos</h4>
<p>Modifique la función <code>parse_csv()</code> para que, opcionalmente, permita que se apliquen conversiones de tipo a los datos devueltos. Por ejemplo:</p>
<pre><code class="language-shell">&gt;&gt;&gt; portfolio = parse_csv('Data/portfolio.csv', types=[str, int, float])
&gt;&gt;&gt; portfolio
[{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}]

&gt;&gt;&gt; shares_held = parse_csv('Data/portfolio.csv', select=['name', 'shares'], types=[str, int])
&gt;&gt;&gt; shares_held
[{'name': 'AA', 'shares': 100}, {'name': 'IBM', 'shares': 50}, {'name': 'CAT', 'shares': 150}, {'name': 'MSFT', 'shares': 200}, {'name': 'GE', 'shares': 95}, {'name': 'MSFT', 'shares': 50}, {'name': 'IBM', 'shares': 100}]
&gt;&gt;&gt;
</code></pre>
<p>Ya exploró esto en el ejercicio 2.24. Deberá insertar el siguiente fragmento de código en su solución:</p>
<pre><code class="language-python">...
if types:
    row = [func(val) for func, val in zip(types, row) ]
...
</code></pre>
<h4 id="ejercicio-36-trabajar-sin-encabezados">Ejercicio 3.6: Trabajar sin encabezados</h4>
<p>Algunos archivos CSV no incluyen información de encabezado. Por ejemplo, el archivo se prices.csvve así:</p>
<pre><code class="language-csv">&quot;AA&quot;,9.22
&quot;AXP&quot;,24.85
&quot;BA&quot;,44.85
&quot;BAC&quot;,11.27
...
</code></pre>
<p>Modifique la <code>parse_csv()</code> función para que pueda trabajar con dichos archivos creando una lista de tuplas. Por ejemplo:</p>
<pre><code class="language-shell">&gt;&gt;&gt; prices = parse_csv('Data/prices.csv', types=[str,float], has_headers=False)
&gt;&gt;&gt; prices
[('AA', 9.22), ('AXP', 24.85), ('BA', 44.85), ('BAC', 11.27), ('C', 3.72), ('CAT', 35.46), ('CVX', 66.67), ('DD', 28.47), ('DIS', 24.22), ('GE', 13.48), ('GM', 0.75), ('HD', 23.16), ('HPQ', 34.35), ('IBM', 106.28), ('INTC', 15.72), ('JNJ', 55.16), ('JPM', 36.9), ('KFT', 26.11), ('KO', 49.16), ('MCD', 58.99), ('MMM', 57.1), ('MRK', 27.58), ('MSFT', 20.89), ('PFE', 15.19), ('PG', 51.94), ('T', 24.79), ('UTX', 52.61), ('VZ', 29.26), ('WMT', 49.74), ('XOM', 69.35)]
&gt;&gt;&gt;
</code></pre>
<p>Para realizar este cambio, deberá modificar el código para que la primera línea de datos no se interprete como una línea de encabezado. Además, deberá asegurarse de no crear diccionarios, ya que ya no hay nombres de columna para usar como claves.</p>
<h3 id="ejercicio-37-elegir-un-delimitador-de-columna-diferente">Ejercicio 3.7: elegir un delimitador de columna diferente</h3>
<p>Aunque los archivos CSV son bastante comunes, también es posible que encuentre un archivo que use un separador de columna diferente, como una sangría (tab) o un espacio. Por ejemplo, el archivo se Data/portfolio.datve así:</p>
<pre><code class="language-csv">name shares price
&quot;AA&quot; 100 32.20
&quot;IBM&quot; 50 91.10
&quot;CAT&quot; 150 83.44
&quot;MSFT&quot; 200 51.23
&quot;GE&quot; 95 40.37
&quot;MSFT&quot; 50 65.10
&quot;IBM&quot; 100 70.44
</code></pre>
<p>La función <code>csv.reader()</code> permite dar un delimitador de columna diferente de la siguiente manera:</p>
<p>rows = csv.reader(f, delimiter=' ')</p>
<p>Modifique su función <code>parse_csv()</code> para que también permita cambiar el delimitador.</p>
<p>Por ejemplo:</p>
<pre><code class="language-shell">&gt;&gt;&gt; portfolio = parse_csv('Data/portfolio.dat', types=[str, int, float], delimiter=' ')
&gt;&gt;&gt; portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]
&gt;&gt;&gt;
</code></pre>
<h3 id="comentario_1">Comentario</h3>
<p>Si ha llegado hasta aquí, ha creado una agradable función de biblioteca que es realmente útil. Puede usarla para analizar archivos CSV arbitrarios, seleccionar columnas de interés, realizar conversiones de tipos, sin tener que preocuparse demasiado por el funcionamiento interno de los archivos o el csvmódulo.</p>
<h2 id="33-comprobacion-de-errores">3.3 Comprobación de errores</h2>
<p>Aunque las excepciones se introdujeron anteriormente, esta sección incluye algunos detalles adicionales sobre la verificación de errores y el manejo de excepciones.</p>
<h3 id="331-como-fallan-los-programas">3.3.1 Cómo fallan los programas</h3>
<p>Python no realiza ninguna verificación ni validación de los tipos o valores de los argumentos de la función. Una función funcionará con cualquier dato que sea compatible con las declaraciones de la función.</p>
<pre><code class="language-python">def add(x, y):
    return x + y

add(3, 4)               # 7 
add('Hello', 'World')   # 'HelloWorld' 
add('3', '4')           # '34' 
</code></pre>
<p>Si hay errores en una función, aparecen en tiempo de ejecución (como excepción).</p>
<pre><code class="language-shell">def add(x, y):
    return x + y

&gt;&gt;&gt; add(3, '4')
Traceback (most recent call last):
...
TypeError: unsupported operand type(s) for +:
    'int' and 'str'
&gt;&gt;&gt;
</code></pre>
<p>Para verificar el código, hay un fuerte énfasis en las pruebas (se tratará más adelante).</p>
<h3 id="332-excepciones">3.3.2 Excepciones</h3>
<p>Las excepciones se utilizan para señalar errores. Para plantear una excepción usted mismo, haga uso de la declaración raise.</p>
<pre><code class="language-python">if name not in authorized:
    raise RuntimeError(f'{name} not authorized')
</code></pre>
<p>Para detectar una excepción, utilice try-except.</p>
<pre><code class="language-python">try:
    authenticate(username)
except RuntimeError as e:
    print(e)
</code></pre>
<h3 id="333-manejo-de-excepciones">3.3.3 Manejo de excepciones</h3>
<p>Las excepciones se propagan a la primera coincidencia except.</p>
<pre><code class="language-python">def grok():
    ...
    raise RuntimeError('Whoa!')   # Excepción se alza aquí 

def spam():
    grok()                        # Esto alzrá la excepción 

def bar():
    try:
       spam()
    except RuntimeError as e:     # La excepción se atrapa aquí         
        ...

def foo():
    try:
         bar()
    except RuntimeError as e:     # La excepción no llega aquí
        ...

foo()
</code></pre>
<p>Para manejar la excepción, coloque declaraciones en el exceptbloque. Puede 
agregar cualquier declaración que desee para manejar el error.</p>
<pre><code class="language-python">def grok(): 
    ...
    raise RuntimeError('Whoa!')

def bar():
    try:
      grok()
    except RuntimeError as e:   # Excepción se atrapa aquí         
        declaraciones           # Use estas declaraciones         
        declaraciones
        ...

bar()
</code></pre>
<p>Después del manejo, la ejecución se reanuda con la primera declaración después 
de try-except.</p>
<pre><code class="language-python">def grok(): ...
    raise RuntimeError('Whoa!')

def bar():
    try:
      grok()
    except RuntimeError as e:   # Excepción se atrapa aquí          
        statements
        statements
        ...
    statements              # Reanuda ejecución aquí     
    statements              # y continúa aquí    
    ...

bar()
</code></pre>
<h3 id="334-excepciones-integradas">3.3.4 Excepciones integradas</h3>
<p>Hay alrededor de dos docenas de excepciones integradas. Por lo general, 
el nombre de la excepción es indicativo de lo que está mal (por ejemplo, 
<code>ValueError</code> se genera a porque proporcionó un valor incorrecto). Esta no es 
una lista exhaustiva. Consulte la documentación para obtener más información.</p>
<pre><code class="language-code">ArithmeticError
AssertionError
EnvironmentError
EOFError
ImportError
IndexError
KeyboardInterrupt
KeyError
MemoryError
NameError
ReferenceError
RuntimeError
SyntaxError
SystemError
TypeError
ValueError
</code></pre>
<h3 id="335-valores-de-excepcion">3.3.5 Valores de excepción</h3>
<p>Las excepciones tienen un valor asociado. Contiene información más específica 
sobre lo que está mal.</p>
<pre><code class="language-python">raise RuntimeError('Invalid user name')
</code></pre>
<p>Este valor es parte de la instancia de excepción que se coloca en la variable 
proporcionada a except.</p>
<pre><code class="language-python">try:
    ...
except RuntimeError as e:   # `e` holds the exception raised
    ...
</code></pre>
<p><code>e</code> es una instancia del tipo de excepción. Sin embargo, a menudo parece una 
cadena cuando se imprime.</p>
<pre><code class="language-python">except RuntimeError as e:
    print('Failed : Reason', e)
</code></pre>
<h3 id="336-detectar-varios-errores">3.3.6 Detectar varios errores</h3>
<p>Puede detectar diferentes tipos de excepciones utilizando varios bloques 
<code>except</code>.</p>
<pre><code class="language-python">try:
  ...
except LookupError as e:
  ...
except RuntimeError as e:
  ...
except IOError as e:
  ...
except KeyboardInterrupt as e:
  ...
</code></pre>
<p>Alternativamente, si las declaraciones para gestionar las excepciones son las 
mismas, puede agruparlas:</p>
<pre><code>try:
  ...
except (IOError,LookupError,RuntimeError) as e:
  ...
</code></pre>
<h3 id="337-detectar-todos-los-errores">3.3.7 Detectar todos los errores</h3>
<p>Para detectar cualquier excepción, use <code>Exception</code> así:</p>
<pre><code class="language-python">try:
    ...
except Exception:       # PELIGRO. Mire abajo.     
    print('An error occurred')
</code></pre>
<p>En general, escribir código como ese es una mala idea porque no sabrá la razón 
del fallo, toda vez que está atrapando todos los errores.</p>
<h3 id="338-manera-incorrecta-de-detectar-errores">3.3.8 Manera incorrecta de detectar errores</h3>
<p>Esta es la forma incorrecta de usar las excepciones.</p>
<pre><code class="language-python">try:
    go_do_something()
except Exception:
    print('Computer says no')
</code></pre>
<p>Esto detecta todos los errores posibles y puede hacer que sea imposible depurar 
cuando el código falla por alguna razón que no esperaba (por ejemplo, módulo 
Python desinstalado, etc.).</p>
<h3 id="339-otro-enfoque">3.3.9 Otro enfoque</h3>
<p>Si va a detectar todos los errores, este es un enfoque más sensato.</p>
<pre><code class="language-python">try:
    go_do_something()
except Exception as e:
    print('Computer says no. Reason :', e)
</code></pre>
<p>Informe sobre el motivo específico de la falla. Casi siempre es una buena idea 
tener algún mecanismo para ver / informar errores cuando escribe código que 
detecta todas las posibles excepciones.</p>
<p>Sin embargo, en general, es mejor detectar el error de la forma más precisa 
posible. Solo detecte los errores que realmente pueda manejar. Deje pasar otros 
errores, tal vez algún otro código pueda manejarlos.</p>
<h3 id="337-volver-a-plantear-una-excepcion">3.3.7 Volver a plantear una excepción</h3>
<p>Úse <code>raise</code> para propagar un error detectado.</p>
<pre><code class="language-python">try:
    go_do_something()
except Exception as e:
    print('Computer says no. Reason :', e)
    raise
</code></pre>
<p>Esto le permite tomar medidas (por ejemplo, reportería) y transmitir el error al 
objeto que llama la función.</p>
<h3 id="338-mejores-practicas-de-excepcion">3.3.8 Mejores prácticas de excepción</h3>
<p>No atrapes excepciones. Falle rápido y fuerte. Si es importante, alguien más se 
ocupará del problema. Solo capture una excepción si se puede recuperar y seguir 
adelante con el programa.</p>
<h3 id="339-declaracion-finally">3.3.9 declaración <code>finally</code></h3>
<p>Especifique el código que debe ejecutarse independientemente de si se produce 
una excepción o no.</p>
<pre><code class="language-python">candado = Candado()
...
candado.acquire()
try:
    ...
finally:
    candado.release()  # esto SIEMPRE se ejecutará. Con y sin excepción.
</code></pre>
<p>Se usa comúnmente para administrar recursos de manera segura (especialmente 
bloqueos (locks), archivos, etc.).</p>
<h3 id="3310-declaracion-with">3.3.10 declaración <code>with</code></h3>
<p>En código de hoy en día, un try-finally a menudo se reemplaza con la declaración 
<code>with</code>.</p>
<pre><code class="language-python">candado = Candado()
with candado:
    # candado adquirido     
    ...
# candado liberado 
</code></pre>
<p>Un ejemplo más familiar:</p>
<pre><code class="language-python">with open(filename) as f:
    # Utilice el archivo     
    ...
# Archivo cerrado 
</code></pre>
<p><code>with</code> define un contexto de uso para un recurso. Cuando la ejecución sale de 
ese contexto, se liberan los recursos. <code>with</code> solo funciona con ciertos objetos 
que han sido programados específicamente para soportarlo.</p>
<h3 id="339-ejercicios">3.3.9 Ejercicios</h3>
<h4 id="ejercicio-38-generacion-de-excepciones">Ejercicio 3.8: Generación de excepciones</h4>
<p>La función <code>parse_csv()</code> que escribió en la última sección permite seleccionar 
columnas especificadas por el usuario, pero eso solo funciona si el archivo de 
datos de entrada tiene encabezados de columna.</p>
<p>Modifique el código para que se genere una excepción si se pasan los argumentos 
<code>select</code> y <code>has_headers=False</code>. Por ejemplo:</p>
<pre><code class="language-shell">&gt;&gt;&gt; parse_csv('Data/prices.csv', select=['name','price'], has_headers=False)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;fileparse.py&quot;, line 9, in parse_csv
    raise RuntimeError(&quot;select argument requires column headers&quot;)
RuntimeError: select argument requires column headers
&gt;&gt;&gt;
</code></pre>
<p>Una vez haya agregado esta comprobación, puede preguntarse si debería realizar 
otros tipos de comprobaciones en la función. Por ejemplo, ¿debería comprobar 
que el nombre del archivo es una cadena, que los tipos son una lista o algo por 
el estilo?</p>
<p>Como regla general, es mejor omitir tales pruebas y dejar que el programa falle 
en entradas incorrectas. El mensaje de rastreo señalará la fuente del problema 
y puede ayudar en la depuración.</p>
<p>La razón principal para agregar la verificación anterior es evitar ejecutar el 
código en un modo sin sentido (por ejemplo, usando una función que requiere 
encabezados de columna, pero especificando simultáneamente que no hay 
encabezados).</p>
<p>Esto indica un error de programación por parte del código de llamada. A menudo, 
es una buena idea verificar los casos que "no se supone que sucedan".</p>
<h4 id="ejercicio-39-captura-de-excepciones">Ejercicio 3.9: captura de excepciones</h4>
<p>La función <code>parse_csv()</code> que escribió se utiliza para procesar todo el 
contenido de un archivo. Sin embargo, en el mundo real, es posible que los 
archivos de entrada tengan datos dañados, faltantes o sucios. </p>
<p>Pruebe este experimento:</p>
<pre><code class="language-shell">&gt;&gt;&gt; portfolio = parse_csv('Data/missing.csv', types=[str, int, float])
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;fileparse.py&quot;, line 36, in parse_csv
    row = [func(val) for func, val in zip(types, row)]
ValueError: invalid literal for int() with base 10: ''
&gt;&gt;&gt;
</code></pre>
<p>Modifique la función <code>parse_csv()</code> para detectar todas las excepciones 
<code>ValueError</code> generadas durante la creación de registros e imprima un mensaje de 
advertencia para las filas que no se pueden convertir.</p>
<p>El mensaje debe incluir el número de fila e información sobre la razón por la 
que falló. Para probar su función, intente leer el archivo de 
<code>Data/missing.csv</code> arriba. Por ejemplo:</p>
<pre><code class="language-shell">&gt;&gt;&gt; portfolio = parse_csv('Data/missing.csv', types=[str, int, float])
Row 4: Couldn't convert ['MSFT', '', '51.23'] Row 4: Reason invalid literal for 
int() with base 10: '' Row 7: Couldn't convert ['IBM', '', '70.44']
Row 7: Reason invalid literal for int() with base 10: ''
&gt;&gt;&gt;
&gt;&gt;&gt; portfolio
[{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}]
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-310-silenciar-errores">Ejercicio 3.10: Silenciar errores</h4>
<p>Modifique la función <code>parse_csv()</code> para que los mensajes de error de análisis 
puedan silenciarse si el usuario lo desea explícitamente. Por ejemplo:</p>
<pre><code class="language-shell">&gt;&gt;&gt; portfolio = parse_csv('Data/missing.csv', types=[str,int,float], silence_errors=True)
&gt;&gt;&gt; portfolio
[{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}]
&gt;&gt;&gt;
</code></pre>
<p>El manejo de errores es una de las cosas más difíciles de corregir en la 
mayoría de los programas. Como regla general, <em>no debe ignorar silenciosamente 
los errores</em>. En su lugar, <em>es mejor informar problemas y darle al usuario la 
opción</em> de silenciar el mensaje de error si así lo desea.</p>
<h2 id="34-modulos">3.4 Módulos</h2>
<p>Esta sección presenta el concepto de módulos y el trabajo con funciones que 
abarcan varios archivos.</p>
<h3 id="341-modulos-e-importacion">3.4.1 Módulos e importación</h3>
<p>Cualquier archivo fuente de Python es un módulo.</p>
<pre><code class="language-python"># foo.py 
def grok(a):
    ...

def spam(b):
    ...
</code></pre>
<p>La declaración <code>import</code> carga y ejecuta un módulo.</p>
<pre><code class="language-python"># program.py import foo

a = foo.grok(2)
b = foo.spam('Hello')
...
</code></pre>
<h3 id="342-ambito-o-espacio-de-nombres">3.4.2 Ámbito o espacio de nombres</h3>
<p>Un módulo es una colección de valores con nombre y, a veces, se dice que es un 
espacio de nombres. Es un contenedor abstracto creado para alojar una 
agrupación lógica de identificadores únicos. Los nombres son todas las 
variables y funciones globales definidas en el archivo fuente. Después de la 
importación, el nombre del módulo se utiliza como prefijo. De ahí es donde 
viene el concepto de ámbti o espacio de nombres.</p>
<pre><code class="language-python">import foo

a = foo.grok(2)
b = foo.spam('Hello')
...
</code></pre>
<p>El nombre del módulo está directamente vinculado al nombre del archivo 
(foo -&gt; foo.py).</p>
<h3 id="343-definiciones-globales">3.4.3 Definiciones globales</h3>
<p>Todo lo definido en el ámbito global es lo que llena el espacio de nombres del 
módulo. Considere dos módulos que definen la misma variable x.</p>
<pre><code class="language-python"># foo.py 
x = 42
def grok(a):
    ...
</code></pre>
<pre><code class="language-python"># bar.py 
x = 37
def spam(a):
    ...
</code></pre>
<p>En este caso, las definiciones <code>x</code> se refieren a diferentes variables. Uno es 
<code>foo.x</code> y el otro es <code>bar.x</code>. Diferentes módulos pueden usar los mismos nombres 
y esos nombres no entrarán en conflicto entre sí.</p>
<p><strong>Los módulos están aislados.</strong></p>
<h3 id="344-modulos-como-entornos">3.4.4 Módulos como entornos</h3>
<p>Los módulos forman un entorno envolvente para todo el código definido en el 
interior.</p>
<pre><code class="language-python"># foo.py 

x = 42
def grok(a):
    print(x)
</code></pre>
<p>Las variables globales siempre están vinculadas al módulo adjunto (mismo 
archivo). Cada archivo fuente es su propio pequeño universo.</p>
<h3 id="345-ejecucion-del-modulo">3.4.5 Ejecución del módulo</h3>
<p>Cuando se importa un módulo, todas las declaraciones del módulo se ejecutan una 
tras otra hasta que se llega al final del archivo. El contenido del espacio de 
nombres del módulo son todos los nombres globales que aún están definidos al 
final del proceso de ejecución. Si hay sentencias de scripting que llevan a 
cabo tareas en el ámbito global (impresión, creación de archivos, etc.) las 
verá ejecutar en la importación.</p>
<h3 id="346-declaracion-import-as">3.4.6 declaración <code>import as</code></h3>
<p>Puede cambiar el nombre de un módulo a medida que lo importa:</p>
<pre><code class="language-python">import math as m

def rectangular(r, theta):
    x = r * m.cos(theta)
    y = r * m.sin(theta)
    return x, y
</code></pre>
<p>Funciona igual que una importación normal. Simplemente cambia el nombre del 
módulo en ese archivo.</p>
<h3 id="347-importacion-de-modulo-con-from">3.4.7 importación de módulo con <code>from</code></h3>
<p>Esto selecciona los símbolos seleccionados de un módulo y los hace disponibles 
localmente.</p>
<pre><code class="language-python">from math import sin, cos

def rectangular(r, theta):
    x = r * cos(theta)
    y = r * sin(theta)
    return x, y
</code></pre>
<p>Esto permite utilizar partes de un módulo sin tener que escribir el prefijo del 
módulo. Es útil para nombres de uso frecuente.</p>
<h3 id="348-comentarios-sobre-la-importacion">3.4.8 Comentarios sobre la importación</h3>
<p>Las variaciones en la importación no cambian la forma en que funcionan los 
módulos.</p>
<pre><code class="language-python">import math
# vs import math as m
# vs from math import cos, sin
...
</code></pre>
<p>En concreto, <code>import</code> siempre ejecuta todo el archivo y los módulos siguen 
siendo entornos aislados.</p>
<p>La declaración <code>import as</code> solo cambia el nombre localmente. La declaración 
<code>from math import cos, sin</code> todavía carga todo el módulo de matemáticas detrás 
de escena. Simplemente copia los nombres <code>cos</code> y <code>sin</code> del módulo en el espacio 
local una vez hecho.</p>
<h3 id="349-carga-del-modulo">3.4.9 Carga del módulo</h3>
<p>Cada módulo se carga y se ejecuta solo una vez. <em>Nota: Las importaciones 
repetidas solo devuelven una referencia al módulo cargado anteriormente.</em></p>
<p><code>sys.modules</code> es un dictado de todos los módulos cargados.</p>
<pre><code class="language-shell">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.modules.keys()
['copy_reg', '__main__', 'site', '__builtin__', 'encodings', 'encodings.encodings', 'posixpath', ...]
&gt;&gt;&gt;
</code></pre>
<p><strong>Precaución:</strong> surge una común confusión si repite una declaración <code>import</code> 
después de cambiar el código fuente de un módulo. Debido a la memoria caché del 
módulo sys.modules, las importaciones repetidas siempre devuelven el módulo 
cargado anteriormente, incluso si se realizó un cambio. La forma más segura de 
cargar código modificado en Python es salir y reiniciar el intérprete.</p>
<h3 id="3410-localizacion-de-modulos">3.4.10 Localización de módulos</h3>
<p>Python consulta una lista de rutas (<code>sys.path</code>) cuando busca módulos.</p>
<pre><code class="language-shell">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[
  '',
  '/usr/local/lib/python36/python36.zip',
  '/usr/local/lib/python36',
  ...
]
</code></pre>
<p>El directorio de trabajo actual suele ser el primero.</p>
<h3 id="3411-ruta-de-busqueda-del-modulo">3.4.11 Ruta de búsqueda del módulo</h3>
<p>Como se señaló anteriormente, <code>sys.path</code> contiene las rutas de búsqueda. Puede 
ajustarlo manualmente si es necesario.</p>
<pre><code class="language-python">import sys
sys.path.append('/project/foo/pyfiles')
</code></pre>
<p>Las rutas también se pueden agregar mediante variables de entorno.</p>
<pre><code class="language-shell">$ env PYTHONPATH=/project/foo/pyfiles python3
Python 3.6.0 (default, Feb 3 2017, 05:53:21)
[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)]
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['','/project/foo/pyfiles', ...]
</code></pre>
<p>Como regla general, no debería ser necesario ajustar manualmente la ruta de 
búsqueda del módulo. Sin embargo, a veces surge si está intentando importar 
código Python que se encuentra en una ubicación inusual o que no es fácilmente 
accesible desde el directorio de trabajo actual.</p>
<h3 id="ejercicios">Ejercicios</h3>
<p>Para este ejercicio que involucra módulos, es de vital importancia asegurarse 
de que está ejecutando Python en un entorno adecuado. Los módulos a menudo 
presentan a los nuevos programadores problemas relacionados con el directorio 
de trabajo actual o con la configuración de la ruta de Python. Para este curso, 
se asume que está escribiendo todo su código en el directorio donde están todos 
sus archivos de trabajo. Para obtener los mejores resultados, debe asegurarse 
de estar también en ese directorio cuando inicie el intérprete. De lo 
contrario, debe asegurarse de que su directorio de trabajo se agregue a 
<code>sys.path</code>.</p>
<h4 id="ejercicio-311-importaciones-de-modulos">Ejercicio 3.11: Importaciones de módulos</h4>
<p>En la sección 3, creamos una función de propósito general <code>parse_csv()</code> para 
analizar el contenido de los archivos de datos CSV.</p>
<p>Ahora, veremos cómo usar esa función en otros programas. Primero, comience en 
una nueva ventana de shell. Navega hasta la carpeta donde tienes todos tus 
archivos. Los vamos a importar.</p>
<p>Inicie el modo interactivo de Python.</p>
<pre><code>$ python
Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre>
<p>Una vez que haya hecho eso, intente importar algunos de los programas que 
escribió anteriormente. Debería ver su salida exactamente como antes. Solo para 
enfatizar: la importación de un módulo ejecuta su código.</p>
<pre><code class="language-python">&gt;&gt;&gt; import bounce
... mire la salida ...
&gt;&gt;&gt; import mortgage
... mire la salida ...
&gt;&gt;&gt; import report
... mire la salida ...
&gt;&gt;&gt;
</code></pre>
<p>Si nada de esto funciona, probablemente esté ejecutando Python en el directorio 
incorrecto. Ahora, intente importar su módulo <code>fileparse</code> y obtenga ayuda sobre 
él.</p>
<pre><code class="language-python">&gt;&gt;&gt; import fileparse
&gt;&gt;&gt; help(fileparse)
... mire la salida ...
&gt;&gt;&gt; dir(fileparse)
... mire la salida ...
&gt;&gt;&gt;
</code></pre>
<p>Intente usar el módulo para leer algunos datos:</p>
<pre><code class="language-python">&gt;&gt;&gt; portfolio = fileparse.parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float])
&gt;&gt;&gt; portfolio
... look at the output ...
&gt;&gt;&gt; pricelist = fileparse.parse_csv('Data/prices.csv', types=[str,float], has_headers=False)
&gt;&gt;&gt; pricelist
... look at the output ...
&gt;&gt;&gt; prices = dict(pricelist)
&gt;&gt;&gt; prices
... look at the output ...
&gt;&gt;&gt; prices['IBM']
106.11
&gt;&gt;&gt;
</code></pre>
<p>Intente importar una función para que no necesite incluir el nombre del módulo:</p>
<pre><code class="language-python">&gt;&gt;&gt; from fileparse import parse_csv
&gt;&gt;&gt; portfolio = parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float])
&gt;&gt;&gt; portfolio
... look at the output ...
&gt;&gt;&gt;
</code></pre>
<h4 id="ejercicio-312-uso-de-su-modulo-de-biblioteca">Ejercicio 3.12: Uso de su módulo de biblioteca</h4>
<p>En la sección 2, escribió un programa <code>report.py</code> que produjo un informe de 
acciones como este:</p>
<pre><code class="language-shell">      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
</code></pre>
<p>Tome ese programa y modifíquelo para que todo el procesamiento del archivo de 
entrada se realice usando funciones en su módulo <code>fileparse</code>. Para hacer eso, 
importe <code>fileparse</code> como módulo y cambie las funciones <code>read_portfolio()</code> y 
<code>read_prices()</code> para usar la función <code>parse_csv()</code>.</p>
<p>Utilice el ejemplo interactivo al comienzo de este ejercicio como guía. 
Posteriormente, debería obtener exactamente el mismo resultado que antes.</p>
<h4 id="ejercicio-314-uso-de-mas-importaciones-de-bibliotecas">Ejercicio 3.14: Uso de más importaciones de bibliotecas</h4>
<p>En la sección 1, escribió un programa <code>pcost.py</code> que leyó una cartera y calculó 
su costo.</p>
<pre><code class="language-python">&gt;&gt;&gt; import pcost
&gt;&gt;&gt; pcost.portfolio_cost('Data/portfolio.csv')
44671.15
&gt;&gt;&gt;
</code></pre>
<p>Modifique el archivo <code>pcost.py</code> para que use la función 
<code>report.read_portfolio()</code>.</p>
<h3 id="comentario_2">Comentario</h3>
<p>Cuando haya terminado con este ejercicio, debe tener tres programas. 
1. <code>fileparse.py</code> que contiene una función <code>parse_csv()</code> de propósito general. 
2. <code>report.py</code> que produce un informe agradable, pero también contiene 
<code>read_portfolio()</code> y <code>read_prices()</code>. 
3. Y finalmente, <code>pcost.py</code> que calcula el costo de la cartera, pero hace uso 
de la <code>read_portfolio()</code> función escrita para el <code>report.py</code> programa.</p>
<h2 id="35-modulo-principal">3.5 Módulo principal</h2>
<p>Esta sección presenta el concepto de programa principal o módulo principal.</p>
<h3 id="351-funciones-principales">3.5.1 Funciones principales</h3>
<p>En muchos lenguajes de programación, hay un concepto de principal función o método.</p>
<pre><code class="language-c">// c / c++
int main(int argc, char *argv[]) {
    ...
}
</code></pre>
<pre><code class="language-java">// java
class myprog {
    public static void main(String args[]) {
        ...
    }
}
</code></pre>
<p>Esta es la primera función que se ejecuta cuando se inicia una aplicación.</p>
<h3 id="352-modulo-principal-de-python">3.5.2 Módulo principal de Python</h3>
<p>Python no tiene principal función o método. En cambio, hay un módulo principal. 
El módulo principal es el archivo fuente que se ejecuta primero.</p>
<pre><code class="language-shell">$ python3 prog.py
...
</code></pre>
<p>Cualquier archivo que le dé al intérprete al inicio se convierte en principal. 
No importa el nombre.</p>
<h3 id="352-main">3.5.2 <strong>main</strong></h3>
<p>Es una práctica estándar para los módulos que se ejecutan como un script 
principal utilizar esta convención:</p>
<pre><code class="language-python"># prog.py ...
if __name__ == '__main__':
    # Ejecutando el programa principal ...     
    declaraciones
    ...
</code></pre>
<p>Las declaraciones incluidas dentro de la declaración <code>if</code> se convierten en el 
programa principal .</p>
<h3 id="353-programas-principales-frente-a-importaciones-de-bibliotecas">3.5.3 Programas principales frente a importaciones de bibliotecas</h3>
<p>Cualquier archivo de Python puede ejecutarse como principal o como una 
importación de biblioteca:</p>
<pre><code class="language-shell">$ python prog.py 
# Running as main

import prog   # Running as library import 
</code></pre>
<p>En ambos casos, <code>__name__</code> es el nombre del módulo. Sin embargo, solo se 
establecerá en __main__si se ejecuta como main. Por lo general, no desea que 
las instrucciones que forman parte del programa principal se ejecuten en una 
importación de biblioteca. Por lo tanto, es común tener un if-código de 
verificación que se puede usar de cualquier manera.</p>
<pre><code>if __name__ == '__main__':
    # Does not execute if loaded with import ... 
</code></pre>
<h3 id="353-plantilla-de-programa">3.5.3 Plantilla de programa</h3>
<p>Aquí hay una plantilla de programa común para escribir un programa Python:</p>
<pre><code># prog.py 
# Import statements (libraries) 
import modules

# Functions 
def spam():
    ...

def blah():
    ...

# Main function 
def main():
    ...

if __name__ == '__main__':
    main()
</code></pre>
<h3 id="354-herramientas-de-linea-de-comandos">3.5.4 Herramientas de línea de comandos</h3>
<p>Python se usa a menudo para herramientas de línea de comandos</p>
<pre><code class="language-shell">python report.py portfolio.csv prices.csv
</code></pre>
<p>Significa que los scripts se ejecutan desde el shell / terminal. Los casos de uso comunes son para automatización, tareas en segundo plano, etc.</p>
<h3 id="355-argumentos-de-linea-de-comando">3.5.5 Argumentos de línea de comando</h3>
<p>La línea de comando es una lista de cadenas de texto.</p>
<pre><code class="language-python">python report.py portfolio.csv prices.csv
</code></pre>
<p>Esta lista de cadenas de texto se encuentra en <code>sys.argv</code>.</p>
<pre><code class="language-python"># In the previous bash command 
sys.argv # ['report.py, 'portfolio.csv', 'prices.csv'] 
</code></pre>
<p>Aquí hay un ejemplo simple de procesamiento de argumentos:</p>
<pre><code class="language-python">import sys

if len(sys.argv) != 3:
    raise SystemExit(f'Usage: {sys.argv[0]} ' 'portfile pricefile')
portfile = sys.argv[1]
pricefile = sys.argv[2]
...
</code></pre>
<h3 id="356-estandar-io-entradasalida">3.5.6  Estándar I/O (Entrada/Salida)</h3>
<p>La entrada / salida estándar (o <code>stdio</code>) son archivos que funcionan igual que 
los archivos normales.</p>
<pre><code class="language-python">sys.stdout
sys.stderr
sys.stdin
</code></pre>
<p>De forma predeterminada, la impresión está dirigida a sys.stdout. Se lee la 
entrada <code>sys.stdin</code>. Los rastreos y errores están dirigidos a <code>sys.stderr</code>.</p>
<p>Tenga en cuenta que stdio podría estar conectado a terminales, archivos, 
tuberías, etc.</p>
<pre><code class="language-shell">$ python prog.py &gt; results.txt
# o
$ cmd1 | python3 prog.py | cmd2
</code></pre>
<h3 id="357-variables-de-entorno">3.5.7 Variables de entorno</h3>
<p>Las variables de entorno se establecen en el shell.</p>
<pre><code class="language-shell">$ setenv NAME dave
$ setenv RSH ssh
$ python prog.py
</code></pre>
<p><code>os.environ</code> es un diccionario que contiene estos valores.</p>
<pre><code class="language-python">import os
name = os.environ['NAME'] # 'dave' 
</code></pre>
<p>Los cambios se reflejan en cualquier subproceso que el programa inicie 
posteriormente.</p>
<h3 id="358-saliendo-del-programa">3.5.8 Saliendo del programa</h3>
<p>La salida de un programa se maneja mediante excepciones.</p>
<pre><code class="language-shell">raise SystemExit
raise SystemExit(exitcode)
raise SystemExit('Informative message')
</code></pre>
<p>Una alternativa.</p>
<pre><code class="language-python">import sys
sys.exit(exitcode)
</code></pre>
<p>Un código de salida distinto de cero indica un error.</p>
<h3 id="359-la-linea">3.5.9 La #!linea</h3>
<p>En Unix, la <code>#!línea</code> puede lanzar un script como Python. Agregue lo siguiente 
a la primera línea de su archivo de secuencia de comandos.</p>
<pre><code class="language-python">#!/usr/bin/env python3
# prog.py
...
</code></pre>
<p>Requiere el permiso ejecutable.</p>
<pre><code>bash % chmod +x prog.py
# Then you can execute
bash % prog.py
... output ...
</code></pre>
<p>Nota: Python Launcher en Windows también busca la #!línea para indicar la 
versión del idioma.</p>
<h3 id="3510-plantilla-de-script">3.5.10 Plantilla de script</h3>
<p>Finalmente, aquí hay una plantilla de código común para los programas de Python 
que se ejecutan como scripts de línea de comandos:</p>
<pre><code class="language-python">#!/usr/bin/env python3 
# prog.py 
# Import statements (libraries) 

import modules

# Functions 
def spam():
    ...

def blah():
    ...

# Main function 
def main(argv):
    # Parse command line args, environment, etc.
    ...

if __name__ == '__main__':
    import sys
    main(sys.argv)
</code></pre>
<h3 id="3511-ejercicios">3.5.11 Ejercicios</h3>
<h4 id="ejercicio-315-funciones-main">Ejercicio 3.15: funciones <code>main()</code></h4>
<p>En el archivo, report.pyagregue una función <code>main()</code> que acepte una lista de 
opciones de línea de comando y produzca el mismo resultado que antes. Debería 
poder ejecutarlo de forma interactiva así:</p>
<pre><code>&gt;&gt;&gt; import report
&gt;&gt;&gt; report.main(['report.py', 'Data/portfolio.csv', 'Data/prices.csv'])
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
&gt;&gt;&gt;
</code></pre>
<p>Modifique el <code>pcost.py</code> archivo para que tenga una <code>main()</code> función similar:</p>
<pre><code>&gt;&gt;&gt; import pcost
&gt;&gt;&gt; pcost.main(['pcost.py', 'Data/portfolio.csv'])
Total cost: 44671.15
&gt;&gt;&gt;
</code></pre>
<p>Ejercicio 3.16: Creación de guiones</p>
<p>Modifique los programas <code>report.py</code> y <code>pcost.py</code> para que puedan ejecutarse 
como un script en la línea de comando:</p>
<p><code>$ python3 report.py Data/portfolio.csv Data/prices.csv</code></p>
<pre><code class="language-code">      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
</code></pre>
<pre><code class="language-shell">$ python pcost.py Data/portfolio.csv
Total cost: 44671.15
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../4/" class="btn btn-neutral float-right" title="4 Clases y Objetos">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../2/" class="btn btn-neutral" title="2 Trabajando con Data"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../2/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../4/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
